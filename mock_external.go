// Code generated by MockGen. DO NOT EDIT.
// Source: ./external.go
//
// Generated by this command:
//
//	mockgen -destination ./mock_external.go -package rbft -source ./external.go -typed
//

// Package rbft is a generated GoMock package.
package rbft

import (
	context "context"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"

	types2 "github.com/axiomesh/axiom-kit/types"

	consensus "github.com/axiomesh/axiom-bft/common/consensus"
	"github.com/axiomesh/axiom-bft/types"
)

// MockStorage is a mock of Storage interface.
type MockStorage struct {
	ctrl     *gomock.Controller
	recorder *MockStorageMockRecorder
}

// MockStorageMockRecorder is the mock recorder for MockStorage.
type MockStorageMockRecorder struct {
	mock *MockStorage
}

// NewMockStorage creates a new mock instance.
func NewMockStorage(ctrl *gomock.Controller) *MockStorage {
	mock := &MockStorage{ctrl: ctrl}
	mock.recorder = &MockStorageMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStorage) EXPECT() *MockStorageMockRecorder {
	return m.recorder
}

// DelState mocks base method.
func (m *MockStorage) DelState(key string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DelState", key)
	ret0, _ := ret[0].(error)
	return ret0
}

// DelState indicates an expected call of DelState.
func (mr *MockStorageMockRecorder) DelState(key any) *StorageDelStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DelState", reflect.TypeOf((*MockStorage)(nil).DelState), key)
	return &StorageDelStateCall{Call: call}
}

// StorageDelStateCall wrap *gomock.Call
type StorageDelStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StorageDelStateCall) Return(arg0 error) *StorageDelStateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StorageDelStateCall) Do(f func(string) error) *StorageDelStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StorageDelStateCall) DoAndReturn(f func(string) error) *StorageDelStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadState mocks base method.
func (m *MockStorage) ReadState(key string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadState", key)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadState indicates an expected call of ReadState.
func (mr *MockStorageMockRecorder) ReadState(key any) *StorageReadStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadState", reflect.TypeOf((*MockStorage)(nil).ReadState), key)
	return &StorageReadStateCall{Call: call}
}

// StorageReadStateCall wrap *gomock.Call
type StorageReadStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StorageReadStateCall) Return(arg0 []byte, arg1 error) *StorageReadStateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StorageReadStateCall) Do(f func(string) ([]byte, error)) *StorageReadStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StorageReadStateCall) DoAndReturn(f func(string) ([]byte, error)) *StorageReadStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadStateSet mocks base method.
func (m *MockStorage) ReadStateSet(key string) (map[string][]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadStateSet", key)
	ret0, _ := ret[0].(map[string][]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadStateSet indicates an expected call of ReadStateSet.
func (mr *MockStorageMockRecorder) ReadStateSet(key any) *StorageReadStateSetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadStateSet", reflect.TypeOf((*MockStorage)(nil).ReadStateSet), key)
	return &StorageReadStateSetCall{Call: call}
}

// StorageReadStateSetCall wrap *gomock.Call
type StorageReadStateSetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StorageReadStateSetCall) Return(arg0 map[string][]byte, arg1 error) *StorageReadStateSetCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StorageReadStateSetCall) Do(f func(string) (map[string][]byte, error)) *StorageReadStateSetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StorageReadStateSetCall) DoAndReturn(f func(string) (map[string][]byte, error)) *StorageReadStateSetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StoreState mocks base method.
func (m *MockStorage) StoreState(key string, value []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreState", key, value)
	ret0, _ := ret[0].(error)
	return ret0
}

// StoreState indicates an expected call of StoreState.
func (mr *MockStorageMockRecorder) StoreState(key, value any) *StorageStoreStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreState", reflect.TypeOf((*MockStorage)(nil).StoreState), key, value)
	return &StorageStoreStateCall{Call: call}
}

// StorageStoreStateCall wrap *gomock.Call
type StorageStoreStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StorageStoreStateCall) Return(arg0 error) *StorageStoreStateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StorageStoreStateCall) Do(f func(string, []byte) error) *StorageStoreStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StorageStoreStateCall) DoAndReturn(f func(string, []byte) error) *StorageStoreStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockNetwork is a mock of Network interface.
type MockNetwork struct {
	ctrl     *gomock.Controller
	recorder *MockNetworkMockRecorder
}

// MockNetworkMockRecorder is the mock recorder for MockNetwork.
type MockNetworkMockRecorder struct {
	mock *MockNetwork
}

// NewMockNetwork creates a new mock instance.
func NewMockNetwork(ctrl *gomock.Controller) *MockNetwork {
	mock := &MockNetwork{ctrl: ctrl}
	mock.recorder = &MockNetworkMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNetwork) EXPECT() *MockNetworkMockRecorder {
	return m.recorder
}

// Broadcast mocks base method.
func (m *MockNetwork) Broadcast(ctx context.Context, msg *consensus.ConsensusMessage) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Broadcast", ctx, msg)
	ret0, _ := ret[0].(error)
	return ret0
}

// Broadcast indicates an expected call of Broadcast.
func (mr *MockNetworkMockRecorder) Broadcast(ctx, msg any) *NetworkBroadcastCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Broadcast", reflect.TypeOf((*MockNetwork)(nil).Broadcast), ctx, msg)
	return &NetworkBroadcastCall{Call: call}
}

// NetworkBroadcastCall wrap *gomock.Call
type NetworkBroadcastCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *NetworkBroadcastCall) Return(arg0 error) *NetworkBroadcastCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *NetworkBroadcastCall) Do(f func(context.Context, *consensus.ConsensusMessage) error) *NetworkBroadcastCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *NetworkBroadcastCall) DoAndReturn(f func(context.Context, *consensus.ConsensusMessage) error) *NetworkBroadcastCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Unicast mocks base method.
func (m *MockNetwork) Unicast(ctx context.Context, msg *consensus.ConsensusMessage, to string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unicast", ctx, msg, to)
	ret0, _ := ret[0].(error)
	return ret0
}

// Unicast indicates an expected call of Unicast.
func (mr *MockNetworkMockRecorder) Unicast(ctx, msg, to any) *NetworkUnicastCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unicast", reflect.TypeOf((*MockNetwork)(nil).Unicast), ctx, msg, to)
	return &NetworkUnicastCall{Call: call}
}

// NetworkUnicastCall wrap *gomock.Call
type NetworkUnicastCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *NetworkUnicastCall) Return(arg0 error) *NetworkUnicastCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *NetworkUnicastCall) Do(f func(context.Context, *consensus.ConsensusMessage, string) error) *NetworkUnicastCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *NetworkUnicastCall) DoAndReturn(f func(context.Context, *consensus.ConsensusMessage, string) error) *NetworkUnicastCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockCrypto is a mock of Crypto interface.
type MockCrypto struct {
	ctrl     *gomock.Controller
	recorder *MockCryptoMockRecorder
}

// MockCryptoMockRecorder is the mock recorder for MockCrypto.
type MockCryptoMockRecorder struct {
	mock *MockCrypto
}

// NewMockCrypto creates a new mock instance.
func NewMockCrypto(ctrl *gomock.Controller) *MockCrypto {
	mock := &MockCrypto{ctrl: ctrl}
	mock.recorder = &MockCryptoMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCrypto) EXPECT() *MockCryptoMockRecorder {
	return m.recorder
}

// Sign mocks base method.
func (m *MockCrypto) Sign(msg []byte) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Sign", msg)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Sign indicates an expected call of Sign.
func (mr *MockCryptoMockRecorder) Sign(msg any) *CryptoSignCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Sign", reflect.TypeOf((*MockCrypto)(nil).Sign), msg)
	return &CryptoSignCall{Call: call}
}

// CryptoSignCall wrap *gomock.Call
type CryptoSignCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *CryptoSignCall) Return(arg0 []byte, arg1 error) *CryptoSignCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *CryptoSignCall) Do(f func([]byte) ([]byte, error)) *CryptoSignCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *CryptoSignCall) DoAndReturn(f func([]byte) ([]byte, error)) *CryptoSignCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Verify mocks base method.
func (m *MockCrypto) Verify(peerHash string, signature, msg []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Verify", peerHash, signature, msg)
	ret0, _ := ret[0].(error)
	return ret0
}

// Verify indicates an expected call of Verify.
func (mr *MockCryptoMockRecorder) Verify(peerHash, signature, msg any) *CryptoVerifyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Verify", reflect.TypeOf((*MockCrypto)(nil).Verify), peerHash, signature, msg)
	return &CryptoVerifyCall{Call: call}
}

// CryptoVerifyCall wrap *gomock.Call
type CryptoVerifyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *CryptoVerifyCall) Return(arg0 error) *CryptoVerifyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *CryptoVerifyCall) Do(f func(string, []byte, []byte) error) *CryptoVerifyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *CryptoVerifyCall) DoAndReturn(f func(string, []byte, []byte) error) *CryptoVerifyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockServiceOutbound is a mock of ServiceOutbound interface.
type MockServiceOutbound[T any, Constraint types2.TXConstraint[T]] struct {
	ctrl     *gomock.Controller
	recorder *MockServiceOutboundMockRecorder[T, Constraint]
}

// MockServiceOutboundMockRecorder is the mock recorder for MockServiceOutbound.
type MockServiceOutboundMockRecorder[T any, Constraint types2.TXConstraint[T]] struct {
	mock *MockServiceOutbound[T, Constraint]
}

// NewMockServiceOutbound creates a new mock instance.
func NewMockServiceOutbound[T any, Constraint types2.TXConstraint[T]](ctrl *gomock.Controller) *MockServiceOutbound[T, Constraint] {
	mock := &MockServiceOutbound[T, Constraint]{ctrl: ctrl}
	mock.recorder = &MockServiceOutboundMockRecorder[T, Constraint]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockServiceOutbound[T, Constraint]) EXPECT() *MockServiceOutboundMockRecorder[T, Constraint] {
	return m.recorder
}

// Execute mocks base method.
func (m *MockServiceOutbound[T, Constraint]) Execute(txs []*T, localList []bool, seqNo uint64, timestamp int64, proposerAccount string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Execute", txs, localList, seqNo, timestamp, proposerAccount)
}

// Execute indicates an expected call of Execute.
func (mr *MockServiceOutboundMockRecorder[T, Constraint]) Execute(txs, localList, seqNo, timestamp, proposerAccount any) *ServiceOutboundExecuteCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockServiceOutbound[T, Constraint])(nil).Execute), txs, localList, seqNo, timestamp, proposerAccount)
	return &ServiceOutboundExecuteCall[T, Constraint]{Call: call}
}

// ServiceOutboundExecuteCall wrap *gomock.Call
type ServiceOutboundExecuteCall[T any, Constraint types2.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ServiceOutboundExecuteCall[T, Constraint]) Return() *ServiceOutboundExecuteCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ServiceOutboundExecuteCall[T, Constraint]) Do(f func([]*T, []bool, uint64, int64, string)) *ServiceOutboundExecuteCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ServiceOutboundExecuteCall[T, Constraint]) DoAndReturn(f func([]*T, []bool, uint64, int64, string)) *ServiceOutboundExecuteCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SendFilterEvent mocks base method.
func (m *MockServiceOutbound[T, Constraint]) SendFilterEvent(informType types.InformType, message ...any) {
	m.ctrl.T.Helper()
	varargs := []any{informType}
	for _, a := range message {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "SendFilterEvent", varargs...)
}

// SendFilterEvent indicates an expected call of SendFilterEvent.
func (mr *MockServiceOutboundMockRecorder[T, Constraint]) SendFilterEvent(informType any, message ...any) *ServiceOutboundSendFilterEventCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{informType}, message...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendFilterEvent", reflect.TypeOf((*MockServiceOutbound[T, Constraint])(nil).SendFilterEvent), varargs...)
	return &ServiceOutboundSendFilterEventCall[T, Constraint]{Call: call}
}

// ServiceOutboundSendFilterEventCall wrap *gomock.Call
type ServiceOutboundSendFilterEventCall[T any, Constraint types2.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ServiceOutboundSendFilterEventCall[T, Constraint]) Return() *ServiceOutboundSendFilterEventCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ServiceOutboundSendFilterEventCall[T, Constraint]) Do(f func(types.InformType, ...any)) *ServiceOutboundSendFilterEventCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ServiceOutboundSendFilterEventCall[T, Constraint]) DoAndReturn(f func(types.InformType, ...any)) *ServiceOutboundSendFilterEventCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StateUpdate mocks base method.
func (m *MockServiceOutbound[T, Constraint]) StateUpdate(localLowWatermark, seqNo uint64, digest string, checkpoints []*consensus.SignedCheckpoint, epochChanges ...*consensus.EpochChange) {
	m.ctrl.T.Helper()
	varargs := []any{localLowWatermark, seqNo, digest, checkpoints}
	for _, a := range epochChanges {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "StateUpdate", varargs...)
}

// StateUpdate indicates an expected call of StateUpdate.
func (mr *MockServiceOutboundMockRecorder[T, Constraint]) StateUpdate(localLowWatermark, seqNo, digest, checkpoints any, epochChanges ...any) *ServiceOutboundStateUpdateCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{localLowWatermark, seqNo, digest, checkpoints}, epochChanges...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StateUpdate", reflect.TypeOf((*MockServiceOutbound[T, Constraint])(nil).StateUpdate), varargs...)
	return &ServiceOutboundStateUpdateCall[T, Constraint]{Call: call}
}

// ServiceOutboundStateUpdateCall wrap *gomock.Call
type ServiceOutboundStateUpdateCall[T any, Constraint types2.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ServiceOutboundStateUpdateCall[T, Constraint]) Return() *ServiceOutboundStateUpdateCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ServiceOutboundStateUpdateCall[T, Constraint]) Do(f func(uint64, uint64, string, []*consensus.SignedCheckpoint, ...*consensus.EpochChange)) *ServiceOutboundStateUpdateCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ServiceOutboundStateUpdateCall[T, Constraint]) DoAndReturn(f func(uint64, uint64, string, []*consensus.SignedCheckpoint, ...*consensus.EpochChange)) *ServiceOutboundStateUpdateCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockEpochService is a mock of EpochService interface.
type MockEpochService struct {
	ctrl     *gomock.Controller
	recorder *MockEpochServiceMockRecorder
}

// MockEpochServiceMockRecorder is the mock recorder for MockEpochService.
type MockEpochServiceMockRecorder struct {
	mock *MockEpochService
}

// NewMockEpochService creates a new mock instance.
func NewMockEpochService(ctrl *gomock.Controller) *MockEpochService {
	mock := &MockEpochService{ctrl: ctrl}
	mock.recorder = &MockEpochServiceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEpochService) EXPECT() *MockEpochServiceMockRecorder {
	return m.recorder
}

// GetCurrentEpochInfo mocks base method.
func (m *MockEpochService) GetCurrentEpochInfo() (*EpochInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCurrentEpochInfo")
	ret0, _ := ret[0].(*EpochInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCurrentEpochInfo indicates an expected call of GetCurrentEpochInfo.
func (mr *MockEpochServiceMockRecorder) GetCurrentEpochInfo() *EpochServiceGetCurrentEpochInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCurrentEpochInfo", reflect.TypeOf((*MockEpochService)(nil).GetCurrentEpochInfo))
	return &EpochServiceGetCurrentEpochInfoCall{Call: call}
}

// EpochServiceGetCurrentEpochInfoCall wrap *gomock.Call
type EpochServiceGetCurrentEpochInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *EpochServiceGetCurrentEpochInfoCall) Return(arg0 *EpochInfo, arg1 error) *EpochServiceGetCurrentEpochInfoCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *EpochServiceGetCurrentEpochInfoCall) Do(f func() (*EpochInfo, error)) *EpochServiceGetCurrentEpochInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *EpochServiceGetCurrentEpochInfoCall) DoAndReturn(f func() (*EpochInfo, error)) *EpochServiceGetCurrentEpochInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetEpochInfo mocks base method.
func (m *MockEpochService) GetEpochInfo(epoch uint64) (*EpochInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetEpochInfo", epoch)
	ret0, _ := ret[0].(*EpochInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetEpochInfo indicates an expected call of GetEpochInfo.
func (mr *MockEpochServiceMockRecorder) GetEpochInfo(epoch any) *EpochServiceGetEpochInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEpochInfo", reflect.TypeOf((*MockEpochService)(nil).GetEpochInfo), epoch)
	return &EpochServiceGetEpochInfoCall{Call: call}
}

// EpochServiceGetEpochInfoCall wrap *gomock.Call
type EpochServiceGetEpochInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *EpochServiceGetEpochInfoCall) Return(arg0 *EpochInfo, arg1 error) *EpochServiceGetEpochInfoCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *EpochServiceGetEpochInfoCall) Do(f func(uint64) (*EpochInfo, error)) *EpochServiceGetEpochInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *EpochServiceGetEpochInfoCall) DoAndReturn(f func(uint64) (*EpochInfo, error)) *EpochServiceGetEpochInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadEpochState mocks base method.
func (m *MockEpochService) ReadEpochState(key string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadEpochState", key)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadEpochState indicates an expected call of ReadEpochState.
func (mr *MockEpochServiceMockRecorder) ReadEpochState(key any) *EpochServiceReadEpochStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadEpochState", reflect.TypeOf((*MockEpochService)(nil).ReadEpochState), key)
	return &EpochServiceReadEpochStateCall{Call: call}
}

// EpochServiceReadEpochStateCall wrap *gomock.Call
type EpochServiceReadEpochStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *EpochServiceReadEpochStateCall) Return(arg0 []byte, arg1 error) *EpochServiceReadEpochStateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *EpochServiceReadEpochStateCall) Do(f func(string) ([]byte, error)) *EpochServiceReadEpochStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *EpochServiceReadEpochStateCall) DoAndReturn(f func(string) ([]byte, error)) *EpochServiceReadEpochStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StoreEpochState mocks base method.
func (m *MockEpochService) StoreEpochState(key string, value []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreEpochState", key, value)
	ret0, _ := ret[0].(error)
	return ret0
}

// StoreEpochState indicates an expected call of StoreEpochState.
func (mr *MockEpochServiceMockRecorder) StoreEpochState(key, value any) *EpochServiceStoreEpochStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreEpochState", reflect.TypeOf((*MockEpochService)(nil).StoreEpochState), key, value)
	return &EpochServiceStoreEpochStateCall{Call: call}
}

// EpochServiceStoreEpochStateCall wrap *gomock.Call
type EpochServiceStoreEpochStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *EpochServiceStoreEpochStateCall) Return(arg0 error) *EpochServiceStoreEpochStateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *EpochServiceStoreEpochStateCall) Do(f func(string, []byte) error) *EpochServiceStoreEpochStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *EpochServiceStoreEpochStateCall) DoAndReturn(f func(string, []byte) error) *EpochServiceStoreEpochStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockExternalStack is a mock of ExternalStack interface.
type MockExternalStack[T any, Constraint types2.TXConstraint[T]] struct {
	ctrl     *gomock.Controller
	recorder *MockExternalStackMockRecorder[T, Constraint]
}

// MockExternalStackMockRecorder is the mock recorder for MockExternalStack.
type MockExternalStackMockRecorder[T any, Constraint types2.TXConstraint[T]] struct {
	mock *MockExternalStack[T, Constraint]
}

// NewMockExternalStack creates a new mock instance.
func NewMockExternalStack[T any, Constraint types2.TXConstraint[T]](ctrl *gomock.Controller) *MockExternalStack[T, Constraint] {
	mock := &MockExternalStack[T, Constraint]{ctrl: ctrl}
	mock.recorder = &MockExternalStackMockRecorder[T, Constraint]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExternalStack[T, Constraint]) EXPECT() *MockExternalStackMockRecorder[T, Constraint] {
	return m.recorder
}

// Broadcast mocks base method.
func (m *MockExternalStack[T, Constraint]) Broadcast(ctx context.Context, msg *consensus.ConsensusMessage) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Broadcast", ctx, msg)
	ret0, _ := ret[0].(error)
	return ret0
}

// Broadcast indicates an expected call of Broadcast.
func (mr *MockExternalStackMockRecorder[T, Constraint]) Broadcast(ctx, msg any) *ExternalStackBroadcastCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Broadcast", reflect.TypeOf((*MockExternalStack[T, Constraint])(nil).Broadcast), ctx, msg)
	return &ExternalStackBroadcastCall[T, Constraint]{Call: call}
}

// ExternalStackBroadcastCall wrap *gomock.Call
type ExternalStackBroadcastCall[T any, Constraint types2.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ExternalStackBroadcastCall[T, Constraint]) Return(arg0 error) *ExternalStackBroadcastCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ExternalStackBroadcastCall[T, Constraint]) Do(f func(context.Context, *consensus.ConsensusMessage) error) *ExternalStackBroadcastCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ExternalStackBroadcastCall[T, Constraint]) DoAndReturn(f func(context.Context, *consensus.ConsensusMessage) error) *ExternalStackBroadcastCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DelState mocks base method.
func (m *MockExternalStack[T, Constraint]) DelState(key string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DelState", key)
	ret0, _ := ret[0].(error)
	return ret0
}

// DelState indicates an expected call of DelState.
func (mr *MockExternalStackMockRecorder[T, Constraint]) DelState(key any) *ExternalStackDelStateCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DelState", reflect.TypeOf((*MockExternalStack[T, Constraint])(nil).DelState), key)
	return &ExternalStackDelStateCall[T, Constraint]{Call: call}
}

// ExternalStackDelStateCall wrap *gomock.Call
type ExternalStackDelStateCall[T any, Constraint types2.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ExternalStackDelStateCall[T, Constraint]) Return(arg0 error) *ExternalStackDelStateCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ExternalStackDelStateCall[T, Constraint]) Do(f func(string) error) *ExternalStackDelStateCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ExternalStackDelStateCall[T, Constraint]) DoAndReturn(f func(string) error) *ExternalStackDelStateCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Execute mocks base method.
func (m *MockExternalStack[T, Constraint]) Execute(txs []*T, localList []bool, seqNo uint64, timestamp int64, proposerAccount string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Execute", txs, localList, seqNo, timestamp, proposerAccount)
}

// Execute indicates an expected call of Execute.
func (mr *MockExternalStackMockRecorder[T, Constraint]) Execute(txs, localList, seqNo, timestamp, proposerAccount any) *ExternalStackExecuteCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockExternalStack[T, Constraint])(nil).Execute), txs, localList, seqNo, timestamp, proposerAccount)
	return &ExternalStackExecuteCall[T, Constraint]{Call: call}
}

// ExternalStackExecuteCall wrap *gomock.Call
type ExternalStackExecuteCall[T any, Constraint types2.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ExternalStackExecuteCall[T, Constraint]) Return() *ExternalStackExecuteCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ExternalStackExecuteCall[T, Constraint]) Do(f func([]*T, []bool, uint64, int64, string)) *ExternalStackExecuteCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ExternalStackExecuteCall[T, Constraint]) DoAndReturn(f func([]*T, []bool, uint64, int64, string)) *ExternalStackExecuteCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCurrentEpochInfo mocks base method.
func (m *MockExternalStack[T, Constraint]) GetCurrentEpochInfo() (*EpochInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCurrentEpochInfo")
	ret0, _ := ret[0].(*EpochInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCurrentEpochInfo indicates an expected call of GetCurrentEpochInfo.
func (mr *MockExternalStackMockRecorder[T, Constraint]) GetCurrentEpochInfo() *ExternalStackGetCurrentEpochInfoCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCurrentEpochInfo", reflect.TypeOf((*MockExternalStack[T, Constraint])(nil).GetCurrentEpochInfo))
	return &ExternalStackGetCurrentEpochInfoCall[T, Constraint]{Call: call}
}

// ExternalStackGetCurrentEpochInfoCall wrap *gomock.Call
type ExternalStackGetCurrentEpochInfoCall[T any, Constraint types2.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ExternalStackGetCurrentEpochInfoCall[T, Constraint]) Return(arg0 *EpochInfo, arg1 error) *ExternalStackGetCurrentEpochInfoCall[T, Constraint] {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ExternalStackGetCurrentEpochInfoCall[T, Constraint]) Do(f func() (*EpochInfo, error)) *ExternalStackGetCurrentEpochInfoCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ExternalStackGetCurrentEpochInfoCall[T, Constraint]) DoAndReturn(f func() (*EpochInfo, error)) *ExternalStackGetCurrentEpochInfoCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetEpochInfo mocks base method.
func (m *MockExternalStack[T, Constraint]) GetEpochInfo(epoch uint64) (*EpochInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetEpochInfo", epoch)
	ret0, _ := ret[0].(*EpochInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetEpochInfo indicates an expected call of GetEpochInfo.
func (mr *MockExternalStackMockRecorder[T, Constraint]) GetEpochInfo(epoch any) *ExternalStackGetEpochInfoCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEpochInfo", reflect.TypeOf((*MockExternalStack[T, Constraint])(nil).GetEpochInfo), epoch)
	return &ExternalStackGetEpochInfoCall[T, Constraint]{Call: call}
}

// ExternalStackGetEpochInfoCall wrap *gomock.Call
type ExternalStackGetEpochInfoCall[T any, Constraint types2.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ExternalStackGetEpochInfoCall[T, Constraint]) Return(arg0 *EpochInfo, arg1 error) *ExternalStackGetEpochInfoCall[T, Constraint] {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ExternalStackGetEpochInfoCall[T, Constraint]) Do(f func(uint64) (*EpochInfo, error)) *ExternalStackGetEpochInfoCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ExternalStackGetEpochInfoCall[T, Constraint]) DoAndReturn(f func(uint64) (*EpochInfo, error)) *ExternalStackGetEpochInfoCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadEpochState mocks base method.
func (m *MockExternalStack[T, Constraint]) ReadEpochState(key string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadEpochState", key)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadEpochState indicates an expected call of ReadEpochState.
func (mr *MockExternalStackMockRecorder[T, Constraint]) ReadEpochState(key any) *ExternalStackReadEpochStateCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadEpochState", reflect.TypeOf((*MockExternalStack[T, Constraint])(nil).ReadEpochState), key)
	return &ExternalStackReadEpochStateCall[T, Constraint]{Call: call}
}

// ExternalStackReadEpochStateCall wrap *gomock.Call
type ExternalStackReadEpochStateCall[T any, Constraint types2.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ExternalStackReadEpochStateCall[T, Constraint]) Return(arg0 []byte, arg1 error) *ExternalStackReadEpochStateCall[T, Constraint] {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ExternalStackReadEpochStateCall[T, Constraint]) Do(f func(string) ([]byte, error)) *ExternalStackReadEpochStateCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ExternalStackReadEpochStateCall[T, Constraint]) DoAndReturn(f func(string) ([]byte, error)) *ExternalStackReadEpochStateCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadState mocks base method.
func (m *MockExternalStack[T, Constraint]) ReadState(key string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadState", key)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadState indicates an expected call of ReadState.
func (mr *MockExternalStackMockRecorder[T, Constraint]) ReadState(key any) *ExternalStackReadStateCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadState", reflect.TypeOf((*MockExternalStack[T, Constraint])(nil).ReadState), key)
	return &ExternalStackReadStateCall[T, Constraint]{Call: call}
}

// ExternalStackReadStateCall wrap *gomock.Call
type ExternalStackReadStateCall[T any, Constraint types2.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ExternalStackReadStateCall[T, Constraint]) Return(arg0 []byte, arg1 error) *ExternalStackReadStateCall[T, Constraint] {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ExternalStackReadStateCall[T, Constraint]) Do(f func(string) ([]byte, error)) *ExternalStackReadStateCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ExternalStackReadStateCall[T, Constraint]) DoAndReturn(f func(string) ([]byte, error)) *ExternalStackReadStateCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReadStateSet mocks base method.
func (m *MockExternalStack[T, Constraint]) ReadStateSet(key string) (map[string][]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadStateSet", key)
	ret0, _ := ret[0].(map[string][]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadStateSet indicates an expected call of ReadStateSet.
func (mr *MockExternalStackMockRecorder[T, Constraint]) ReadStateSet(key any) *ExternalStackReadStateSetCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadStateSet", reflect.TypeOf((*MockExternalStack[T, Constraint])(nil).ReadStateSet), key)
	return &ExternalStackReadStateSetCall[T, Constraint]{Call: call}
}

// ExternalStackReadStateSetCall wrap *gomock.Call
type ExternalStackReadStateSetCall[T any, Constraint types2.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ExternalStackReadStateSetCall[T, Constraint]) Return(arg0 map[string][]byte, arg1 error) *ExternalStackReadStateSetCall[T, Constraint] {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ExternalStackReadStateSetCall[T, Constraint]) Do(f func(string) (map[string][]byte, error)) *ExternalStackReadStateSetCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ExternalStackReadStateSetCall[T, Constraint]) DoAndReturn(f func(string) (map[string][]byte, error)) *ExternalStackReadStateSetCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SendFilterEvent mocks base method.
func (m *MockExternalStack[T, Constraint]) SendFilterEvent(informType types.InformType, message ...any) {
	m.ctrl.T.Helper()
	varargs := []any{informType}
	for _, a := range message {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "SendFilterEvent", varargs...)
}

// SendFilterEvent indicates an expected call of SendFilterEvent.
func (mr *MockExternalStackMockRecorder[T, Constraint]) SendFilterEvent(informType any, message ...any) *ExternalStackSendFilterEventCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{informType}, message...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendFilterEvent", reflect.TypeOf((*MockExternalStack[T, Constraint])(nil).SendFilterEvent), varargs...)
	return &ExternalStackSendFilterEventCall[T, Constraint]{Call: call}
}

// ExternalStackSendFilterEventCall wrap *gomock.Call
type ExternalStackSendFilterEventCall[T any, Constraint types2.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ExternalStackSendFilterEventCall[T, Constraint]) Return() *ExternalStackSendFilterEventCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ExternalStackSendFilterEventCall[T, Constraint]) Do(f func(types.InformType, ...any)) *ExternalStackSendFilterEventCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ExternalStackSendFilterEventCall[T, Constraint]) DoAndReturn(f func(types.InformType, ...any)) *ExternalStackSendFilterEventCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Sign mocks base method.
func (m *MockExternalStack[T, Constraint]) Sign(msg []byte) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Sign", msg)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Sign indicates an expected call of Sign.
func (mr *MockExternalStackMockRecorder[T, Constraint]) Sign(msg any) *ExternalStackSignCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Sign", reflect.TypeOf((*MockExternalStack[T, Constraint])(nil).Sign), msg)
	return &ExternalStackSignCall[T, Constraint]{Call: call}
}

// ExternalStackSignCall wrap *gomock.Call
type ExternalStackSignCall[T any, Constraint types2.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ExternalStackSignCall[T, Constraint]) Return(arg0 []byte, arg1 error) *ExternalStackSignCall[T, Constraint] {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ExternalStackSignCall[T, Constraint]) Do(f func([]byte) ([]byte, error)) *ExternalStackSignCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ExternalStackSignCall[T, Constraint]) DoAndReturn(f func([]byte) ([]byte, error)) *ExternalStackSignCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StateUpdate mocks base method.
func (m *MockExternalStack[T, Constraint]) StateUpdate(localLowWatermark, seqNo uint64, digest string, checkpoints []*consensus.SignedCheckpoint, epochChanges ...*consensus.EpochChange) {
	m.ctrl.T.Helper()
	varargs := []any{localLowWatermark, seqNo, digest, checkpoints}
	for _, a := range epochChanges {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "StateUpdate", varargs...)
}

// StateUpdate indicates an expected call of StateUpdate.
func (mr *MockExternalStackMockRecorder[T, Constraint]) StateUpdate(localLowWatermark, seqNo, digest, checkpoints any, epochChanges ...any) *ExternalStackStateUpdateCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{localLowWatermark, seqNo, digest, checkpoints}, epochChanges...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StateUpdate", reflect.TypeOf((*MockExternalStack[T, Constraint])(nil).StateUpdate), varargs...)
	return &ExternalStackStateUpdateCall[T, Constraint]{Call: call}
}

// ExternalStackStateUpdateCall wrap *gomock.Call
type ExternalStackStateUpdateCall[T any, Constraint types2.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ExternalStackStateUpdateCall[T, Constraint]) Return() *ExternalStackStateUpdateCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ExternalStackStateUpdateCall[T, Constraint]) Do(f func(uint64, uint64, string, []*consensus.SignedCheckpoint, ...*consensus.EpochChange)) *ExternalStackStateUpdateCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ExternalStackStateUpdateCall[T, Constraint]) DoAndReturn(f func(uint64, uint64, string, []*consensus.SignedCheckpoint, ...*consensus.EpochChange)) *ExternalStackStateUpdateCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StoreEpochState mocks base method.
func (m *MockExternalStack[T, Constraint]) StoreEpochState(key string, value []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreEpochState", key, value)
	ret0, _ := ret[0].(error)
	return ret0
}

// StoreEpochState indicates an expected call of StoreEpochState.
func (mr *MockExternalStackMockRecorder[T, Constraint]) StoreEpochState(key, value any) *ExternalStackStoreEpochStateCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreEpochState", reflect.TypeOf((*MockExternalStack[T, Constraint])(nil).StoreEpochState), key, value)
	return &ExternalStackStoreEpochStateCall[T, Constraint]{Call: call}
}

// ExternalStackStoreEpochStateCall wrap *gomock.Call
type ExternalStackStoreEpochStateCall[T any, Constraint types2.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ExternalStackStoreEpochStateCall[T, Constraint]) Return(arg0 error) *ExternalStackStoreEpochStateCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ExternalStackStoreEpochStateCall[T, Constraint]) Do(f func(string, []byte) error) *ExternalStackStoreEpochStateCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ExternalStackStoreEpochStateCall[T, Constraint]) DoAndReturn(f func(string, []byte) error) *ExternalStackStoreEpochStateCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StoreState mocks base method.
func (m *MockExternalStack[T, Constraint]) StoreState(key string, value []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreState", key, value)
	ret0, _ := ret[0].(error)
	return ret0
}

// StoreState indicates an expected call of StoreState.
func (mr *MockExternalStackMockRecorder[T, Constraint]) StoreState(key, value any) *ExternalStackStoreStateCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreState", reflect.TypeOf((*MockExternalStack[T, Constraint])(nil).StoreState), key, value)
	return &ExternalStackStoreStateCall[T, Constraint]{Call: call}
}

// ExternalStackStoreStateCall wrap *gomock.Call
type ExternalStackStoreStateCall[T any, Constraint types2.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ExternalStackStoreStateCall[T, Constraint]) Return(arg0 error) *ExternalStackStoreStateCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ExternalStackStoreStateCall[T, Constraint]) Do(f func(string, []byte) error) *ExternalStackStoreStateCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ExternalStackStoreStateCall[T, Constraint]) DoAndReturn(f func(string, []byte) error) *ExternalStackStoreStateCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Unicast mocks base method.
func (m *MockExternalStack[T, Constraint]) Unicast(ctx context.Context, msg *consensus.ConsensusMessage, to string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unicast", ctx, msg, to)
	ret0, _ := ret[0].(error)
	return ret0
}

// Unicast indicates an expected call of Unicast.
func (mr *MockExternalStackMockRecorder[T, Constraint]) Unicast(ctx, msg, to any) *ExternalStackUnicastCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unicast", reflect.TypeOf((*MockExternalStack[T, Constraint])(nil).Unicast), ctx, msg, to)
	return &ExternalStackUnicastCall[T, Constraint]{Call: call}
}

// ExternalStackUnicastCall wrap *gomock.Call
type ExternalStackUnicastCall[T any, Constraint types2.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ExternalStackUnicastCall[T, Constraint]) Return(arg0 error) *ExternalStackUnicastCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ExternalStackUnicastCall[T, Constraint]) Do(f func(context.Context, *consensus.ConsensusMessage, string) error) *ExternalStackUnicastCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ExternalStackUnicastCall[T, Constraint]) DoAndReturn(f func(context.Context, *consensus.ConsensusMessage, string) error) *ExternalStackUnicastCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Verify mocks base method.
func (m *MockExternalStack[T, Constraint]) Verify(peerHash string, signature, msg []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Verify", peerHash, signature, msg)
	ret0, _ := ret[0].(error)
	return ret0
}

// Verify indicates an expected call of Verify.
func (mr *MockExternalStackMockRecorder[T, Constraint]) Verify(peerHash, signature, msg any) *ExternalStackVerifyCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Verify", reflect.TypeOf((*MockExternalStack[T, Constraint])(nil).Verify), peerHash, signature, msg)
	return &ExternalStackVerifyCall[T, Constraint]{Call: call}
}

// ExternalStackVerifyCall wrap *gomock.Call
type ExternalStackVerifyCall[T any, Constraint types2.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ExternalStackVerifyCall[T, Constraint]) Return(arg0 error) *ExternalStackVerifyCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ExternalStackVerifyCall[T, Constraint]) Do(f func(string, []byte, []byte) error) *ExternalStackVerifyCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ExternalStackVerifyCall[T, Constraint]) DoAndReturn(f func(string, []byte, []byte) error) *ExternalStackVerifyCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
