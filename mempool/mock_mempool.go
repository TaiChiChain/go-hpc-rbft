// Code generated by MockGen. DO NOT EDIT.
// Source: ./mempool.go
//
// Generated by this command:
//
//	mockgen -destination ./mock_mempool.go -package mempool -source ./mempool.go -typed
//
// Package mempool is a generated GoMock package.
package mempool

import (
	reflect "reflect"

	consensus "github.com/axiomesh/axiom-bft/common/consensus"
	gomock "go.uber.org/mock/gomock"
)

// MockMemPool is a mock of MemPool interface.
type MockMemPool[T any, Constraint consensus.TXConstraint[T]] struct {
	ctrl     *gomock.Controller
	recorder *MockMemPoolMockRecorder[T, Constraint]
}

// MockMemPoolMockRecorder is the mock recorder for MockMemPool.
type MockMemPoolMockRecorder[T any, Constraint consensus.TXConstraint[T]] struct {
	mock *MockMemPool[T, Constraint]
}

// NewMockMemPool creates a new mock instance.
func NewMockMemPool[T any, Constraint consensus.TXConstraint[T]](ctrl *gomock.Controller) *MockMemPool[T, Constraint] {
	mock := &MockMemPool[T, Constraint]{ctrl: ctrl}
	mock.recorder = &MockMemPoolMockRecorder[T, Constraint]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMemPool[T, Constraint]) EXPECT() *MockMemPoolMockRecorder[T, Constraint] {
	return m.recorder
}

// AddNewRequests mocks base method.
func (m *MockMemPool[T, Constraint]) AddNewRequests(txs []*T, isPrimary, local, isReplace, needGenerateBatch bool) ([]*RequestHashBatch[T, Constraint], []string) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddNewRequests", txs, isPrimary, local, isReplace, needGenerateBatch)
	ret0, _ := ret[0].([]*RequestHashBatch[T, Constraint])
	ret1, _ := ret[1].([]string)
	return ret0, ret1
}

// AddNewRequests indicates an expected call of AddNewRequests.
func (mr *MockMemPoolMockRecorder[T, Constraint]) AddNewRequests(txs, isPrimary, local, isReplace, needGenerateBatch any) *MemPoolAddNewRequestsCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddNewRequests", reflect.TypeOf((*MockMemPool[T, Constraint])(nil).AddNewRequests), txs, isPrimary, local, isReplace, needGenerateBatch)
	return &MemPoolAddNewRequestsCall[T, Constraint]{Call: call}
}

// MemPoolAddNewRequestsCall wrap *gomock.Call
type MemPoolAddNewRequestsCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MemPoolAddNewRequestsCall[T, Constraint]) Return(arg0 []*RequestHashBatch[T, Constraint], arg1 []string) *MemPoolAddNewRequestsCall[T, Constraint] {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MemPoolAddNewRequestsCall[T, Constraint]) Do(f func([]*T, bool, bool, bool, bool) ([]*RequestHashBatch[T, Constraint], []string)) *MemPoolAddNewRequestsCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MemPoolAddNewRequestsCall[T, Constraint]) DoAndReturn(f func([]*T, bool, bool, bool, bool) ([]*RequestHashBatch[T, Constraint], []string)) *MemPoolAddNewRequestsCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FilterOutOfDateRequests mocks base method.
func (m *MockMemPool[T, Constraint]) FilterOutOfDateRequests() ([]*T, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FilterOutOfDateRequests")
	ret0, _ := ret[0].([]*T)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FilterOutOfDateRequests indicates an expected call of FilterOutOfDateRequests.
func (mr *MockMemPoolMockRecorder[T, Constraint]) FilterOutOfDateRequests() *MemPoolFilterOutOfDateRequestsCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FilterOutOfDateRequests", reflect.TypeOf((*MockMemPool[T, Constraint])(nil).FilterOutOfDateRequests))
	return &MemPoolFilterOutOfDateRequestsCall[T, Constraint]{Call: call}
}

// MemPoolFilterOutOfDateRequestsCall wrap *gomock.Call
type MemPoolFilterOutOfDateRequestsCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MemPoolFilterOutOfDateRequestsCall[T, Constraint]) Return(arg0 []*T, arg1 error) *MemPoolFilterOutOfDateRequestsCall[T, Constraint] {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MemPoolFilterOutOfDateRequestsCall[T, Constraint]) Do(f func() ([]*T, error)) *MemPoolFilterOutOfDateRequestsCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MemPoolFilterOutOfDateRequestsCall[T, Constraint]) DoAndReturn(f func() ([]*T, error)) *MemPoolFilterOutOfDateRequestsCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GenerateRequestBatch mocks base method.
func (m *MockMemPool[T, Constraint]) GenerateRequestBatch() []*RequestHashBatch[T, Constraint] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GenerateRequestBatch")
	ret0, _ := ret[0].([]*RequestHashBatch[T, Constraint])
	return ret0
}

// GenerateRequestBatch indicates an expected call of GenerateRequestBatch.
func (mr *MockMemPoolMockRecorder[T, Constraint]) GenerateRequestBatch() *MemPoolGenerateRequestBatchCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenerateRequestBatch", reflect.TypeOf((*MockMemPool[T, Constraint])(nil).GenerateRequestBatch))
	return &MemPoolGenerateRequestBatchCall[T, Constraint]{Call: call}
}

// MemPoolGenerateRequestBatchCall wrap *gomock.Call
type MemPoolGenerateRequestBatchCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MemPoolGenerateRequestBatchCall[T, Constraint]) Return(arg0 []*RequestHashBatch[T, Constraint]) *MemPoolGenerateRequestBatchCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MemPoolGenerateRequestBatchCall[T, Constraint]) Do(f func() []*RequestHashBatch[T, Constraint]) *MemPoolGenerateRequestBatchCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MemPoolGenerateRequestBatchCall[T, Constraint]) DoAndReturn(f func() []*RequestHashBatch[T, Constraint]) *MemPoolGenerateRequestBatchCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetPendingNonceByAccount mocks base method.
func (m *MockMemPool[T, Constraint]) GetPendingNonceByAccount(account string) uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPendingNonceByAccount", account)
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetPendingNonceByAccount indicates an expected call of GetPendingNonceByAccount.
func (mr *MockMemPoolMockRecorder[T, Constraint]) GetPendingNonceByAccount(account any) *MemPoolGetPendingNonceByAccountCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPendingNonceByAccount", reflect.TypeOf((*MockMemPool[T, Constraint])(nil).GetPendingNonceByAccount), account)
	return &MemPoolGetPendingNonceByAccountCall[T, Constraint]{Call: call}
}

// MemPoolGetPendingNonceByAccountCall wrap *gomock.Call
type MemPoolGetPendingNonceByAccountCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MemPoolGetPendingNonceByAccountCall[T, Constraint]) Return(arg0 uint64) *MemPoolGetPendingNonceByAccountCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MemPoolGetPendingNonceByAccountCall[T, Constraint]) Do(f func(string) uint64) *MemPoolGetPendingNonceByAccountCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MemPoolGetPendingNonceByAccountCall[T, Constraint]) DoAndReturn(f func(string) uint64) *MemPoolGetPendingNonceByAccountCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetPendingTxByHash mocks base method.
func (m *MockMemPool[T, Constraint]) GetPendingTxByHash(hash string) *T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPendingTxByHash", hash)
	ret0, _ := ret[0].(*T)
	return ret0
}

// GetPendingTxByHash indicates an expected call of GetPendingTxByHash.
func (mr *MockMemPoolMockRecorder[T, Constraint]) GetPendingTxByHash(hash any) *MemPoolGetPendingTxByHashCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPendingTxByHash", reflect.TypeOf((*MockMemPool[T, Constraint])(nil).GetPendingTxByHash), hash)
	return &MemPoolGetPendingTxByHashCall[T, Constraint]{Call: call}
}

// MemPoolGetPendingTxByHashCall wrap *gomock.Call
type MemPoolGetPendingTxByHashCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MemPoolGetPendingTxByHashCall[T, Constraint]) Return(arg0 *T) *MemPoolGetPendingTxByHashCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MemPoolGetPendingTxByHashCall[T, Constraint]) Do(f func(string) *T) *MemPoolGetPendingTxByHashCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MemPoolGetPendingTxByHashCall[T, Constraint]) DoAndReturn(f func(string) *T) *MemPoolGetPendingTxByHashCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetPendingTxCount mocks base method.
func (m *MockMemPool[T, Constraint]) GetPendingTxCount() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPendingTxCount")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetPendingTxCount indicates an expected call of GetPendingTxCount.
func (mr *MockMemPoolMockRecorder[T, Constraint]) GetPendingTxCount() *MemPoolGetPendingTxCountCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPendingTxCount", reflect.TypeOf((*MockMemPool[T, Constraint])(nil).GetPendingTxCount))
	return &MemPoolGetPendingTxCountCall[T, Constraint]{Call: call}
}

// MemPoolGetPendingTxCountCall wrap *gomock.Call
type MemPoolGetPendingTxCountCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MemPoolGetPendingTxCountCall[T, Constraint]) Return(arg0 uint64) *MemPoolGetPendingTxCountCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MemPoolGetPendingTxCountCall[T, Constraint]) Do(f func() uint64) *MemPoolGetPendingTxCountCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MemPoolGetPendingTxCountCall[T, Constraint]) DoAndReturn(f func() uint64) *MemPoolGetPendingTxCountCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetRequestsByHashList mocks base method.
func (m *MockMemPool[T, Constraint]) GetRequestsByHashList(batchHash string, timestamp int64, hashList, deDuplicateTxHashes []string) ([]*T, []bool, map[uint64]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRequestsByHashList", batchHash, timestamp, hashList, deDuplicateTxHashes)
	ret0, _ := ret[0].([]*T)
	ret1, _ := ret[1].([]bool)
	ret2, _ := ret[2].(map[uint64]string)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// GetRequestsByHashList indicates an expected call of GetRequestsByHashList.
func (mr *MockMemPoolMockRecorder[T, Constraint]) GetRequestsByHashList(batchHash, timestamp, hashList, deDuplicateTxHashes any) *MemPoolGetRequestsByHashListCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRequestsByHashList", reflect.TypeOf((*MockMemPool[T, Constraint])(nil).GetRequestsByHashList), batchHash, timestamp, hashList, deDuplicateTxHashes)
	return &MemPoolGetRequestsByHashListCall[T, Constraint]{Call: call}
}

// MemPoolGetRequestsByHashListCall wrap *gomock.Call
type MemPoolGetRequestsByHashListCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MemPoolGetRequestsByHashListCall[T, Constraint]) Return(txs []*T, list []bool, missingTxsHash map[uint64]string, err error) *MemPoolGetRequestsByHashListCall[T, Constraint] {
	c.Call = c.Call.Return(txs, list, missingTxsHash, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MemPoolGetRequestsByHashListCall[T, Constraint]) Do(f func(string, int64, []string, []string) ([]*T, []bool, map[uint64]string, error)) *MemPoolGetRequestsByHashListCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MemPoolGetRequestsByHashListCall[T, Constraint]) DoAndReturn(f func(string, int64, []string, []string) ([]*T, []bool, map[uint64]string, error)) *MemPoolGetRequestsByHashListCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUncommittedTransactions mocks base method.
func (m *MockMemPool[T, Constraint]) GetUncommittedTransactions(maxsize uint64) []*T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUncommittedTransactions", maxsize)
	ret0, _ := ret[0].([]*T)
	return ret0
}

// GetUncommittedTransactions indicates an expected call of GetUncommittedTransactions.
func (mr *MockMemPoolMockRecorder[T, Constraint]) GetUncommittedTransactions(maxsize any) *MemPoolGetUncommittedTransactionsCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUncommittedTransactions", reflect.TypeOf((*MockMemPool[T, Constraint])(nil).GetUncommittedTransactions), maxsize)
	return &MemPoolGetUncommittedTransactionsCall[T, Constraint]{Call: call}
}

// MemPoolGetUncommittedTransactionsCall wrap *gomock.Call
type MemPoolGetUncommittedTransactionsCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MemPoolGetUncommittedTransactionsCall[T, Constraint]) Return(arg0 []*T) *MemPoolGetUncommittedTransactionsCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MemPoolGetUncommittedTransactionsCall[T, Constraint]) Do(f func(uint64) []*T) *MemPoolGetUncommittedTransactionsCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MemPoolGetUncommittedTransactionsCall[T, Constraint]) DoAndReturn(f func(uint64) []*T) *MemPoolGetUncommittedTransactionsCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HasPendingRequestInPool mocks base method.
func (m *MockMemPool[T, Constraint]) HasPendingRequestInPool() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasPendingRequestInPool")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasPendingRequestInPool indicates an expected call of HasPendingRequestInPool.
func (mr *MockMemPoolMockRecorder[T, Constraint]) HasPendingRequestInPool() *MemPoolHasPendingRequestInPoolCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasPendingRequestInPool", reflect.TypeOf((*MockMemPool[T, Constraint])(nil).HasPendingRequestInPool))
	return &MemPoolHasPendingRequestInPoolCall[T, Constraint]{Call: call}
}

// MemPoolHasPendingRequestInPoolCall wrap *gomock.Call
type MemPoolHasPendingRequestInPoolCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MemPoolHasPendingRequestInPoolCall[T, Constraint]) Return(arg0 bool) *MemPoolHasPendingRequestInPoolCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MemPoolHasPendingRequestInPoolCall[T, Constraint]) Do(f func() bool) *MemPoolHasPendingRequestInPoolCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MemPoolHasPendingRequestInPoolCall[T, Constraint]) DoAndReturn(f func() bool) *MemPoolHasPendingRequestInPoolCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Init mocks base method.
func (m *MockMemPool[T, Constraint]) Init(selfID uint64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Init", selfID)
	ret0, _ := ret[0].(error)
	return ret0
}

// Init indicates an expected call of Init.
func (mr *MockMemPoolMockRecorder[T, Constraint]) Init(selfID any) *MemPoolInitCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Init", reflect.TypeOf((*MockMemPool[T, Constraint])(nil).Init), selfID)
	return &MemPoolInitCall[T, Constraint]{Call: call}
}

// MemPoolInitCall wrap *gomock.Call
type MemPoolInitCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MemPoolInitCall[T, Constraint]) Return(arg0 error) *MemPoolInitCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MemPoolInitCall[T, Constraint]) Do(f func(uint64) error) *MemPoolInitCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MemPoolInitCall[T, Constraint]) DoAndReturn(f func(uint64) error) *MemPoolInitCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsPoolFull mocks base method.
func (m *MockMemPool[T, Constraint]) IsPoolFull() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsPoolFull")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsPoolFull indicates an expected call of IsPoolFull.
func (mr *MockMemPoolMockRecorder[T, Constraint]) IsPoolFull() *MemPoolIsPoolFullCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsPoolFull", reflect.TypeOf((*MockMemPool[T, Constraint])(nil).IsPoolFull))
	return &MemPoolIsPoolFullCall[T, Constraint]{Call: call}
}

// MemPoolIsPoolFullCall wrap *gomock.Call
type MemPoolIsPoolFullCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MemPoolIsPoolFullCall[T, Constraint]) Return(arg0 bool) *MemPoolIsPoolFullCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MemPoolIsPoolFullCall[T, Constraint]) Do(f func() bool) *MemPoolIsPoolFullCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MemPoolIsPoolFullCall[T, Constraint]) DoAndReturn(f func() bool) *MemPoolIsPoolFullCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReConstructBatchByOrder mocks base method.
func (m *MockMemPool[T, Constraint]) ReConstructBatchByOrder(oldBatch *RequestHashBatch[T, Constraint]) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReConstructBatchByOrder", oldBatch)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReConstructBatchByOrder indicates an expected call of ReConstructBatchByOrder.
func (mr *MockMemPoolMockRecorder[T, Constraint]) ReConstructBatchByOrder(oldBatch any) *MemPoolReConstructBatchByOrderCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReConstructBatchByOrder", reflect.TypeOf((*MockMemPool[T, Constraint])(nil).ReConstructBatchByOrder), oldBatch)
	return &MemPoolReConstructBatchByOrderCall[T, Constraint]{Call: call}
}

// MemPoolReConstructBatchByOrderCall wrap *gomock.Call
type MemPoolReConstructBatchByOrderCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MemPoolReConstructBatchByOrderCall[T, Constraint]) Return(deDuplicateTxHashes []string, err error) *MemPoolReConstructBatchByOrderCall[T, Constraint] {
	c.Call = c.Call.Return(deDuplicateTxHashes, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MemPoolReConstructBatchByOrderCall[T, Constraint]) Do(f func(*RequestHashBatch[T, Constraint]) ([]string, error)) *MemPoolReConstructBatchByOrderCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MemPoolReConstructBatchByOrderCall[T, Constraint]) DoAndReturn(f func(*RequestHashBatch[T, Constraint]) ([]string, error)) *MemPoolReConstructBatchByOrderCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReceiveMissingRequests mocks base method.
func (m *MockMemPool[T, Constraint]) ReceiveMissingRequests(batchHash string, txs map[uint64]*T) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReceiveMissingRequests", batchHash, txs)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReceiveMissingRequests indicates an expected call of ReceiveMissingRequests.
func (mr *MockMemPoolMockRecorder[T, Constraint]) ReceiveMissingRequests(batchHash, txs any) *MemPoolReceiveMissingRequestsCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReceiveMissingRequests", reflect.TypeOf((*MockMemPool[T, Constraint])(nil).ReceiveMissingRequests), batchHash, txs)
	return &MemPoolReceiveMissingRequestsCall[T, Constraint]{Call: call}
}

// MemPoolReceiveMissingRequestsCall wrap *gomock.Call
type MemPoolReceiveMissingRequestsCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MemPoolReceiveMissingRequestsCall[T, Constraint]) Return(arg0 error) *MemPoolReceiveMissingRequestsCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MemPoolReceiveMissingRequestsCall[T, Constraint]) Do(f func(string, map[uint64]*T) error) *MemPoolReceiveMissingRequestsCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MemPoolReceiveMissingRequestsCall[T, Constraint]) DoAndReturn(f func(string, map[uint64]*T) error) *MemPoolReceiveMissingRequestsCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemoveBatches mocks base method.
func (m *MockMemPool[T, Constraint]) RemoveBatches(hashList []string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RemoveBatches", hashList)
}

// RemoveBatches indicates an expected call of RemoveBatches.
func (mr *MockMemPoolMockRecorder[T, Constraint]) RemoveBatches(hashList any) *MemPoolRemoveBatchesCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveBatches", reflect.TypeOf((*MockMemPool[T, Constraint])(nil).RemoveBatches), hashList)
	return &MemPoolRemoveBatchesCall[T, Constraint]{Call: call}
}

// MemPoolRemoveBatchesCall wrap *gomock.Call
type MemPoolRemoveBatchesCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MemPoolRemoveBatchesCall[T, Constraint]) Return() *MemPoolRemoveBatchesCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MemPoolRemoveBatchesCall[T, Constraint]) Do(f func([]string)) *MemPoolRemoveBatchesCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MemPoolRemoveBatchesCall[T, Constraint]) DoAndReturn(f func([]string)) *MemPoolRemoveBatchesCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemoveTimeoutRequests mocks base method.
func (m *MockMemPool[T, Constraint]) RemoveTimeoutRequests() (uint64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveTimeoutRequests")
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RemoveTimeoutRequests indicates an expected call of RemoveTimeoutRequests.
func (mr *MockMemPoolMockRecorder[T, Constraint]) RemoveTimeoutRequests() *MemPoolRemoveTimeoutRequestsCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveTimeoutRequests", reflect.TypeOf((*MockMemPool[T, Constraint])(nil).RemoveTimeoutRequests))
	return &MemPoolRemoveTimeoutRequestsCall[T, Constraint]{Call: call}
}

// MemPoolRemoveTimeoutRequestsCall wrap *gomock.Call
type MemPoolRemoveTimeoutRequestsCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MemPoolRemoveTimeoutRequestsCall[T, Constraint]) Return(arg0 uint64, arg1 error) *MemPoolRemoveTimeoutRequestsCall[T, Constraint] {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MemPoolRemoveTimeoutRequestsCall[T, Constraint]) Do(f func() (uint64, error)) *MemPoolRemoveTimeoutRequestsCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MemPoolRemoveTimeoutRequestsCall[T, Constraint]) DoAndReturn(f func() (uint64, error)) *MemPoolRemoveTimeoutRequestsCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Reset mocks base method.
func (m *MockMemPool[T, Constraint]) Reset(saveBatches []string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Reset", saveBatches)
}

// Reset indicates an expected call of Reset.
func (mr *MockMemPoolMockRecorder[T, Constraint]) Reset(saveBatches any) *MemPoolResetCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Reset", reflect.TypeOf((*MockMemPool[T, Constraint])(nil).Reset), saveBatches)
	return &MemPoolResetCall[T, Constraint]{Call: call}
}

// MemPoolResetCall wrap *gomock.Call
type MemPoolResetCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MemPoolResetCall[T, Constraint]) Return() *MemPoolResetCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MemPoolResetCall[T, Constraint]) Do(f func([]string)) *MemPoolResetCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MemPoolResetCall[T, Constraint]) DoAndReturn(f func([]string)) *MemPoolResetCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RestoreOneBatch mocks base method.
func (m *MockMemPool[T, Constraint]) RestoreOneBatch(hash string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RestoreOneBatch", hash)
	ret0, _ := ret[0].(error)
	return ret0
}

// RestoreOneBatch indicates an expected call of RestoreOneBatch.
func (mr *MockMemPoolMockRecorder[T, Constraint]) RestoreOneBatch(hash any) *MemPoolRestoreOneBatchCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RestoreOneBatch", reflect.TypeOf((*MockMemPool[T, Constraint])(nil).RestoreOneBatch), hash)
	return &MemPoolRestoreOneBatchCall[T, Constraint]{Call: call}
}

// MemPoolRestoreOneBatchCall wrap *gomock.Call
type MemPoolRestoreOneBatchCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MemPoolRestoreOneBatchCall[T, Constraint]) Return(arg0 error) *MemPoolRestoreOneBatchCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MemPoolRestoreOneBatchCall[T, Constraint]) Do(f func(string) error) *MemPoolRestoreOneBatchCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MemPoolRestoreOneBatchCall[T, Constraint]) DoAndReturn(f func(string) error) *MemPoolRestoreOneBatchCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RestorePool mocks base method.
func (m *MockMemPool[T, Constraint]) RestorePool() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RestorePool")
}

// RestorePool indicates an expected call of RestorePool.
func (mr *MockMemPoolMockRecorder[T, Constraint]) RestorePool() *MemPoolRestorePoolCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RestorePool", reflect.TypeOf((*MockMemPool[T, Constraint])(nil).RestorePool))
	return &MemPoolRestorePoolCall[T, Constraint]{Call: call}
}

// MemPoolRestorePoolCall wrap *gomock.Call
type MemPoolRestorePoolCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MemPoolRestorePoolCall[T, Constraint]) Return() *MemPoolRestorePoolCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MemPoolRestorePoolCall[T, Constraint]) Do(f func()) *MemPoolRestorePoolCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MemPoolRestorePoolCall[T, Constraint]) DoAndReturn(f func()) *MemPoolRestorePoolCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SendMissingRequests mocks base method.
func (m *MockMemPool[T, Constraint]) SendMissingRequests(batchHash string, missingHashList map[uint64]string) (map[uint64]*T, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendMissingRequests", batchHash, missingHashList)
	ret0, _ := ret[0].(map[uint64]*T)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SendMissingRequests indicates an expected call of SendMissingRequests.
func (mr *MockMemPoolMockRecorder[T, Constraint]) SendMissingRequests(batchHash, missingHashList any) *MemPoolSendMissingRequestsCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendMissingRequests", reflect.TypeOf((*MockMemPool[T, Constraint])(nil).SendMissingRequests), batchHash, missingHashList)
	return &MemPoolSendMissingRequestsCall[T, Constraint]{Call: call}
}

// MemPoolSendMissingRequestsCall wrap *gomock.Call
type MemPoolSendMissingRequestsCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MemPoolSendMissingRequestsCall[T, Constraint]) Return(txs map[uint64]*T, err error) *MemPoolSendMissingRequestsCall[T, Constraint] {
	c.Call = c.Call.Return(txs, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MemPoolSendMissingRequestsCall[T, Constraint]) Do(f func(string, map[uint64]string) (map[uint64]*T, error)) *MemPoolSendMissingRequestsCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MemPoolSendMissingRequestsCall[T, Constraint]) DoAndReturn(f func(string, map[uint64]string) (map[uint64]*T, error)) *MemPoolSendMissingRequestsCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Start mocks base method.
func (m *MockMemPool[T, Constraint]) Start() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start")
	ret0, _ := ret[0].(error)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockMemPoolMockRecorder[T, Constraint]) Start() *MemPoolStartCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockMemPool[T, Constraint])(nil).Start))
	return &MemPoolStartCall[T, Constraint]{Call: call}
}

// MemPoolStartCall wrap *gomock.Call
type MemPoolStartCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MemPoolStartCall[T, Constraint]) Return(arg0 error) *MemPoolStartCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MemPoolStartCall[T, Constraint]) Do(f func() error) *MemPoolStartCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MemPoolStartCall[T, Constraint]) DoAndReturn(f func() error) *MemPoolStartCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Stop mocks base method.
func (m *MockMemPool[T, Constraint]) Stop() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Stop")
}

// Stop indicates an expected call of Stop.
func (mr *MockMemPoolMockRecorder[T, Constraint]) Stop() *MemPoolStopCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockMemPool[T, Constraint])(nil).Stop))
	return &MemPoolStopCall[T, Constraint]{Call: call}
}

// MemPoolStopCall wrap *gomock.Call
type MemPoolStopCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MemPoolStopCall[T, Constraint]) Return() *MemPoolStopCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MemPoolStopCall[T, Constraint]) Do(f func()) *MemPoolStopCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MemPoolStopCall[T, Constraint]) DoAndReturn(f func()) *MemPoolStopCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockExternal is a mock of External interface.
type MockExternal[T any, Constraint consensus.TXConstraint[T]] struct {
	ctrl     *gomock.Controller
	recorder *MockExternalMockRecorder[T, Constraint]
}

// MockExternalMockRecorder is the mock recorder for MockExternal.
type MockExternalMockRecorder[T any, Constraint consensus.TXConstraint[T]] struct {
	mock *MockExternal[T, Constraint]
}

// NewMockExternal creates a new mock instance.
func NewMockExternal[T any, Constraint consensus.TXConstraint[T]](ctrl *gomock.Controller) *MockExternal[T, Constraint] {
	mock := &MockExternal[T, Constraint]{ctrl: ctrl}
	mock.recorder = &MockExternalMockRecorder[T, Constraint]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExternal[T, Constraint]) EXPECT() *MockExternalMockRecorder[T, Constraint] {
	return m.recorder
}

// GetPendingNonceByAccount mocks base method.
func (m *MockExternal[T, Constraint]) GetPendingNonceByAccount(account string) uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPendingNonceByAccount", account)
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetPendingNonceByAccount indicates an expected call of GetPendingNonceByAccount.
func (mr *MockExternalMockRecorder[T, Constraint]) GetPendingNonceByAccount(account any) *ExternalGetPendingNonceByAccountCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPendingNonceByAccount", reflect.TypeOf((*MockExternal[T, Constraint])(nil).GetPendingNonceByAccount), account)
	return &ExternalGetPendingNonceByAccountCall[T, Constraint]{Call: call}
}

// ExternalGetPendingNonceByAccountCall wrap *gomock.Call
type ExternalGetPendingNonceByAccountCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ExternalGetPendingNonceByAccountCall[T, Constraint]) Return(arg0 uint64) *ExternalGetPendingNonceByAccountCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ExternalGetPendingNonceByAccountCall[T, Constraint]) Do(f func(string) uint64) *ExternalGetPendingNonceByAccountCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ExternalGetPendingNonceByAccountCall[T, Constraint]) DoAndReturn(f func(string) uint64) *ExternalGetPendingNonceByAccountCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetPendingTxByHash mocks base method.
func (m *MockExternal[T, Constraint]) GetPendingTxByHash(hash string) *T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPendingTxByHash", hash)
	ret0, _ := ret[0].(*T)
	return ret0
}

// GetPendingTxByHash indicates an expected call of GetPendingTxByHash.
func (mr *MockExternalMockRecorder[T, Constraint]) GetPendingTxByHash(hash any) *ExternalGetPendingTxByHashCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPendingTxByHash", reflect.TypeOf((*MockExternal[T, Constraint])(nil).GetPendingTxByHash), hash)
	return &ExternalGetPendingTxByHashCall[T, Constraint]{Call: call}
}

// ExternalGetPendingTxByHashCall wrap *gomock.Call
type ExternalGetPendingTxByHashCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ExternalGetPendingTxByHashCall[T, Constraint]) Return(arg0 *T) *ExternalGetPendingTxByHashCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ExternalGetPendingTxByHashCall[T, Constraint]) Do(f func(string) *T) *ExternalGetPendingTxByHashCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ExternalGetPendingTxByHashCall[T, Constraint]) DoAndReturn(f func(string) *T) *ExternalGetPendingTxByHashCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetPendingTxCount mocks base method.
func (m *MockExternal[T, Constraint]) GetPendingTxCount() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPendingTxCount")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetPendingTxCount indicates an expected call of GetPendingTxCount.
func (mr *MockExternalMockRecorder[T, Constraint]) GetPendingTxCount() *ExternalGetPendingTxCountCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPendingTxCount", reflect.TypeOf((*MockExternal[T, Constraint])(nil).GetPendingTxCount))
	return &ExternalGetPendingTxCountCall[T, Constraint]{Call: call}
}

// ExternalGetPendingTxCountCall wrap *gomock.Call
type ExternalGetPendingTxCountCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ExternalGetPendingTxCountCall[T, Constraint]) Return(arg0 uint64) *ExternalGetPendingTxCountCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ExternalGetPendingTxCountCall[T, Constraint]) Do(f func() uint64) *ExternalGetPendingTxCountCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ExternalGetPendingTxCountCall[T, Constraint]) DoAndReturn(f func() uint64) *ExternalGetPendingTxCountCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemoveTimeoutRequests mocks base method.
func (m *MockExternal[T, Constraint]) RemoveTimeoutRequests() (uint64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveTimeoutRequests")
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RemoveTimeoutRequests indicates an expected call of RemoveTimeoutRequests.
func (mr *MockExternalMockRecorder[T, Constraint]) RemoveTimeoutRequests() *ExternalRemoveTimeoutRequestsCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveTimeoutRequests", reflect.TypeOf((*MockExternal[T, Constraint])(nil).RemoveTimeoutRequests))
	return &ExternalRemoveTimeoutRequestsCall[T, Constraint]{Call: call}
}

// ExternalRemoveTimeoutRequestsCall wrap *gomock.Call
type ExternalRemoveTimeoutRequestsCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ExternalRemoveTimeoutRequestsCall[T, Constraint]) Return(arg0 uint64, arg1 error) *ExternalRemoveTimeoutRequestsCall[T, Constraint] {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ExternalRemoveTimeoutRequestsCall[T, Constraint]) Do(f func() (uint64, error)) *ExternalRemoveTimeoutRequestsCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ExternalRemoveTimeoutRequestsCall[T, Constraint]) DoAndReturn(f func() (uint64, error)) *ExternalRemoveTimeoutRequestsCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
