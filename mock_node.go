// Code generated by MockGen. DO NOT EDIT.
// Source: ./node.go
//
// Generated by this command:
//
//	mockgen -destination ./mock_node.go -package rbft -source ./node.go -typed
//
// Package rbft is a generated GoMock package.
package rbft

import (
	context "context"
	reflect "reflect"

	consensus "github.com/axiomesh/axiom-bft/common/consensus"
	types "github.com/axiomesh/axiom-bft/types"
	gomock "go.uber.org/mock/gomock"
)

// MockNode is a mock of Node interface.
type MockNode[T any, Constraint consensus.TXConstraint[T]] struct {
	ctrl     *gomock.Controller
	recorder *MockNodeMockRecorder[T, Constraint]
}

// MockNodeMockRecorder is the mock recorder for MockNode.
type MockNodeMockRecorder[T any, Constraint consensus.TXConstraint[T]] struct {
	mock *MockNode[T, Constraint]
}

// NewMockNode creates a new mock instance.
func NewMockNode[T any, Constraint consensus.TXConstraint[T]](ctrl *gomock.Controller) *MockNode[T, Constraint] {
	mock := &MockNode[T, Constraint]{ctrl: ctrl}
	mock.recorder = &MockNodeMockRecorder[T, Constraint]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNode[T, Constraint]) EXPECT() *MockNodeMockRecorder[T, Constraint] {
	return m.recorder
}

// GetPendingNonceByAccount mocks base method.
func (m *MockNode[T, Constraint]) GetPendingNonceByAccount(account string) uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPendingNonceByAccount", account)
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetPendingNonceByAccount indicates an expected call of GetPendingNonceByAccount.
func (mr *MockNodeMockRecorder[T, Constraint]) GetPendingNonceByAccount(account any) *NodeGetPendingNonceByAccountCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPendingNonceByAccount", reflect.TypeOf((*MockNode[T, Constraint])(nil).GetPendingNonceByAccount), account)
	return &NodeGetPendingNonceByAccountCall[T, Constraint]{Call: call}
}

// NodeGetPendingNonceByAccountCall wrap *gomock.Call
type NodeGetPendingNonceByAccountCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *NodeGetPendingNonceByAccountCall[T, Constraint]) Return(arg0 uint64) *NodeGetPendingNonceByAccountCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *NodeGetPendingNonceByAccountCall[T, Constraint]) Do(f func(string) uint64) *NodeGetPendingNonceByAccountCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *NodeGetPendingNonceByAccountCall[T, Constraint]) DoAndReturn(f func(string) uint64) *NodeGetPendingNonceByAccountCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetPendingTxByHash mocks base method.
func (m *MockNode[T, Constraint]) GetPendingTxByHash(hash string) *T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPendingTxByHash", hash)
	ret0, _ := ret[0].(*T)
	return ret0
}

// GetPendingTxByHash indicates an expected call of GetPendingTxByHash.
func (mr *MockNodeMockRecorder[T, Constraint]) GetPendingTxByHash(hash any) *NodeGetPendingTxByHashCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPendingTxByHash", reflect.TypeOf((*MockNode[T, Constraint])(nil).GetPendingTxByHash), hash)
	return &NodeGetPendingTxByHashCall[T, Constraint]{Call: call}
}

// NodeGetPendingTxByHashCall wrap *gomock.Call
type NodeGetPendingTxByHashCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *NodeGetPendingTxByHashCall[T, Constraint]) Return(arg0 *T) *NodeGetPendingTxByHashCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *NodeGetPendingTxByHashCall[T, Constraint]) Do(f func(string) *T) *NodeGetPendingTxByHashCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *NodeGetPendingTxByHashCall[T, Constraint]) DoAndReturn(f func(string) *T) *NodeGetPendingTxByHashCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUncommittedTransactions mocks base method.
func (m *MockNode[T, Constraint]) GetUncommittedTransactions(maxsize uint64) []*T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUncommittedTransactions", maxsize)
	ret0, _ := ret[0].([]*T)
	return ret0
}

// GetUncommittedTransactions indicates an expected call of GetUncommittedTransactions.
func (mr *MockNodeMockRecorder[T, Constraint]) GetUncommittedTransactions(maxsize any) *NodeGetUncommittedTransactionsCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUncommittedTransactions", reflect.TypeOf((*MockNode[T, Constraint])(nil).GetUncommittedTransactions), maxsize)
	return &NodeGetUncommittedTransactionsCall[T, Constraint]{Call: call}
}

// NodeGetUncommittedTransactionsCall wrap *gomock.Call
type NodeGetUncommittedTransactionsCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *NodeGetUncommittedTransactionsCall[T, Constraint]) Return(arg0 []*T) *NodeGetUncommittedTransactionsCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *NodeGetUncommittedTransactionsCall[T, Constraint]) Do(f func(uint64) []*T) *NodeGetUncommittedTransactionsCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *NodeGetUncommittedTransactionsCall[T, Constraint]) DoAndReturn(f func(uint64) []*T) *NodeGetUncommittedTransactionsCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Init mocks base method.
func (m *MockNode[T, Constraint]) Init() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Init")
	ret0, _ := ret[0].(error)
	return ret0
}

// Init indicates an expected call of Init.
func (mr *MockNodeMockRecorder[T, Constraint]) Init() *NodeInitCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Init", reflect.TypeOf((*MockNode[T, Constraint])(nil).Init))
	return &NodeInitCall[T, Constraint]{Call: call}
}

// NodeInitCall wrap *gomock.Call
type NodeInitCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *NodeInitCall[T, Constraint]) Return(arg0 error) *NodeInitCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *NodeInitCall[T, Constraint]) Do(f func() error) *NodeInitCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *NodeInitCall[T, Constraint]) DoAndReturn(f func() error) *NodeInitCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Propose mocks base method.
func (m *MockNode[T, Constraint]) Propose(requests []*T, local bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Propose", requests, local)
	ret0, _ := ret[0].(error)
	return ret0
}

// Propose indicates an expected call of Propose.
func (mr *MockNodeMockRecorder[T, Constraint]) Propose(requests, local any) *NodeProposeCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Propose", reflect.TypeOf((*MockNode[T, Constraint])(nil).Propose), requests, local)
	return &NodeProposeCall[T, Constraint]{Call: call}
}

// NodeProposeCall wrap *gomock.Call
type NodeProposeCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *NodeProposeCall[T, Constraint]) Return(arg0 error) *NodeProposeCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *NodeProposeCall[T, Constraint]) Do(f func([]*T, bool) error) *NodeProposeCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *NodeProposeCall[T, Constraint]) DoAndReturn(f func([]*T, bool) error) *NodeProposeCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReportExecuted mocks base method.
func (m *MockNode[T, Constraint]) ReportExecuted(state *types.ServiceState) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ReportExecuted", state)
}

// ReportExecuted indicates an expected call of ReportExecuted.
func (mr *MockNodeMockRecorder[T, Constraint]) ReportExecuted(state any) *NodeReportExecutedCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReportExecuted", reflect.TypeOf((*MockNode[T, Constraint])(nil).ReportExecuted), state)
	return &NodeReportExecutedCall[T, Constraint]{Call: call}
}

// NodeReportExecutedCall wrap *gomock.Call
type NodeReportExecutedCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *NodeReportExecutedCall[T, Constraint]) Return() *NodeReportExecutedCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *NodeReportExecutedCall[T, Constraint]) Do(f func(*types.ServiceState)) *NodeReportExecutedCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *NodeReportExecutedCall[T, Constraint]) DoAndReturn(f func(*types.ServiceState)) *NodeReportExecutedCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReportStateUpdated mocks base method.
func (m *MockNode[T, Constraint]) ReportStateUpdated(state *types.ServiceState) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ReportStateUpdated", state)
}

// ReportStateUpdated indicates an expected call of ReportStateUpdated.
func (mr *MockNodeMockRecorder[T, Constraint]) ReportStateUpdated(state any) *NodeReportStateUpdatedCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReportStateUpdated", reflect.TypeOf((*MockNode[T, Constraint])(nil).ReportStateUpdated), state)
	return &NodeReportStateUpdatedCall[T, Constraint]{Call: call}
}

// NodeReportStateUpdatedCall wrap *gomock.Call
type NodeReportStateUpdatedCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *NodeReportStateUpdatedCall[T, Constraint]) Return() *NodeReportStateUpdatedCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *NodeReportStateUpdatedCall[T, Constraint]) Do(f func(*types.ServiceState)) *NodeReportStateUpdatedCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *NodeReportStateUpdatedCall[T, Constraint]) DoAndReturn(f func(*types.ServiceState)) *NodeReportStateUpdatedCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Start mocks base method.
func (m *MockNode[T, Constraint]) Start() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start")
	ret0, _ := ret[0].(error)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockNodeMockRecorder[T, Constraint]) Start() *NodeStartCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockNode[T, Constraint])(nil).Start))
	return &NodeStartCall[T, Constraint]{Call: call}
}

// NodeStartCall wrap *gomock.Call
type NodeStartCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *NodeStartCall[T, Constraint]) Return(arg0 error) *NodeStartCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *NodeStartCall[T, Constraint]) Do(f func() error) *NodeStartCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *NodeStartCall[T, Constraint]) DoAndReturn(f func() error) *NodeStartCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Status mocks base method.
func (m *MockNode[T, Constraint]) Status() NodeStatus {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Status")
	ret0, _ := ret[0].(NodeStatus)
	return ret0
}

// Status indicates an expected call of Status.
func (mr *MockNodeMockRecorder[T, Constraint]) Status() *NodeStatusCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Status", reflect.TypeOf((*MockNode[T, Constraint])(nil).Status))
	return &NodeStatusCall[T, Constraint]{Call: call}
}

// NodeStatusCall wrap *gomock.Call
type NodeStatusCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *NodeStatusCall[T, Constraint]) Return(arg0 NodeStatus) *NodeStatusCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *NodeStatusCall[T, Constraint]) Do(f func() NodeStatus) *NodeStatusCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *NodeStatusCall[T, Constraint]) DoAndReturn(f func() NodeStatus) *NodeStatusCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Step mocks base method.
func (m *MockNode[T, Constraint]) Step(ctx context.Context, msg *consensus.ConsensusMessage) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Step", ctx, msg)
}

// Step indicates an expected call of Step.
func (mr *MockNodeMockRecorder[T, Constraint]) Step(ctx, msg any) *NodeStepCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Step", reflect.TypeOf((*MockNode[T, Constraint])(nil).Step), ctx, msg)
	return &NodeStepCall[T, Constraint]{Call: call}
}

// NodeStepCall wrap *gomock.Call
type NodeStepCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *NodeStepCall[T, Constraint]) Return() *NodeStepCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *NodeStepCall[T, Constraint]) Do(f func(context.Context, *consensus.ConsensusMessage)) *NodeStepCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *NodeStepCall[T, Constraint]) DoAndReturn(f func(context.Context, *consensus.ConsensusMessage)) *NodeStepCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Stop mocks base method.
func (m *MockNode[T, Constraint]) Stop() []*T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stop")
	ret0, _ := ret[0].([]*T)
	return ret0
}

// Stop indicates an expected call of Stop.
func (mr *MockNodeMockRecorder[T, Constraint]) Stop() *NodeStopCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockNode[T, Constraint])(nil).Stop))
	return &NodeStopCall[T, Constraint]{Call: call}
}

// NodeStopCall wrap *gomock.Call
type NodeStopCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *NodeStopCall[T, Constraint]) Return(arg0 []*T) *NodeStopCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *NodeStopCall[T, Constraint]) Do(f func() []*T) *NodeStopCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *NodeStopCall[T, Constraint]) DoAndReturn(f func() []*T) *NodeStopCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockExternal is a mock of External interface.
type MockExternal[T any, Constraint consensus.TXConstraint[T]] struct {
	ctrl     *gomock.Controller
	recorder *MockExternalMockRecorder[T, Constraint]
}

// MockExternalMockRecorder is the mock recorder for MockExternal.
type MockExternalMockRecorder[T any, Constraint consensus.TXConstraint[T]] struct {
	mock *MockExternal[T, Constraint]
}

// NewMockExternal creates a new mock instance.
func NewMockExternal[T any, Constraint consensus.TXConstraint[T]](ctrl *gomock.Controller) *MockExternal[T, Constraint] {
	mock := &MockExternal[T, Constraint]{ctrl: ctrl}
	mock.recorder = &MockExternalMockRecorder[T, Constraint]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExternal[T, Constraint]) EXPECT() *MockExternalMockRecorder[T, Constraint] {
	return m.recorder
}

// GetPendingNonceByAccount mocks base method.
func (m *MockExternal[T, Constraint]) GetPendingNonceByAccount(account string) uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPendingNonceByAccount", account)
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetPendingNonceByAccount indicates an expected call of GetPendingNonceByAccount.
func (mr *MockExternalMockRecorder[T, Constraint]) GetPendingNonceByAccount(account any) *ExternalGetPendingNonceByAccountCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPendingNonceByAccount", reflect.TypeOf((*MockExternal[T, Constraint])(nil).GetPendingNonceByAccount), account)
	return &ExternalGetPendingNonceByAccountCall[T, Constraint]{Call: call}
}

// ExternalGetPendingNonceByAccountCall wrap *gomock.Call
type ExternalGetPendingNonceByAccountCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ExternalGetPendingNonceByAccountCall[T, Constraint]) Return(arg0 uint64) *ExternalGetPendingNonceByAccountCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ExternalGetPendingNonceByAccountCall[T, Constraint]) Do(f func(string) uint64) *ExternalGetPendingNonceByAccountCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ExternalGetPendingNonceByAccountCall[T, Constraint]) DoAndReturn(f func(string) uint64) *ExternalGetPendingNonceByAccountCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetPendingTxByHash mocks base method.
func (m *MockExternal[T, Constraint]) GetPendingTxByHash(hash string) *T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPendingTxByHash", hash)
	ret0, _ := ret[0].(*T)
	return ret0
}

// GetPendingTxByHash indicates an expected call of GetPendingTxByHash.
func (mr *MockExternalMockRecorder[T, Constraint]) GetPendingTxByHash(hash any) *ExternalGetPendingTxByHashCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPendingTxByHash", reflect.TypeOf((*MockExternal[T, Constraint])(nil).GetPendingTxByHash), hash)
	return &ExternalGetPendingTxByHashCall[T, Constraint]{Call: call}
}

// ExternalGetPendingTxByHashCall wrap *gomock.Call
type ExternalGetPendingTxByHashCall[T any, Constraint consensus.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ExternalGetPendingTxByHashCall[T, Constraint]) Return(arg0 *T) *ExternalGetPendingTxByHashCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ExternalGetPendingTxByHashCall[T, Constraint]) Do(f func(string) *T) *ExternalGetPendingTxByHashCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ExternalGetPendingTxByHashCall[T, Constraint]) DoAndReturn(f func(string) *T) *ExternalGetPendingTxByHashCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockServiceInbound is a mock of ServiceInbound interface.
type MockServiceInbound struct {
	ctrl     *gomock.Controller
	recorder *MockServiceInboundMockRecorder
}

// MockServiceInboundMockRecorder is the mock recorder for MockServiceInbound.
type MockServiceInboundMockRecorder struct {
	mock *MockServiceInbound
}

// NewMockServiceInbound creates a new mock instance.
func NewMockServiceInbound(ctrl *gomock.Controller) *MockServiceInbound {
	mock := &MockServiceInbound{ctrl: ctrl}
	mock.recorder = &MockServiceInboundMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockServiceInbound) EXPECT() *MockServiceInboundMockRecorder {
	return m.recorder
}

// ReportExecuted mocks base method.
func (m *MockServiceInbound) ReportExecuted(state *types.ServiceState) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ReportExecuted", state)
}

// ReportExecuted indicates an expected call of ReportExecuted.
func (mr *MockServiceInboundMockRecorder) ReportExecuted(state any) *ServiceInboundReportExecutedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReportExecuted", reflect.TypeOf((*MockServiceInbound)(nil).ReportExecuted), state)
	return &ServiceInboundReportExecutedCall{Call: call}
}

// ServiceInboundReportExecutedCall wrap *gomock.Call
type ServiceInboundReportExecutedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ServiceInboundReportExecutedCall) Return() *ServiceInboundReportExecutedCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ServiceInboundReportExecutedCall) Do(f func(*types.ServiceState)) *ServiceInboundReportExecutedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ServiceInboundReportExecutedCall) DoAndReturn(f func(*types.ServiceState)) *ServiceInboundReportExecutedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReportStateUpdated mocks base method.
func (m *MockServiceInbound) ReportStateUpdated(state *types.ServiceState) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ReportStateUpdated", state)
}

// ReportStateUpdated indicates an expected call of ReportStateUpdated.
func (mr *MockServiceInboundMockRecorder) ReportStateUpdated(state any) *ServiceInboundReportStateUpdatedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReportStateUpdated", reflect.TypeOf((*MockServiceInbound)(nil).ReportStateUpdated), state)
	return &ServiceInboundReportStateUpdatedCall{Call: call}
}

// ServiceInboundReportStateUpdatedCall wrap *gomock.Call
type ServiceInboundReportStateUpdatedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ServiceInboundReportStateUpdatedCall) Return() *ServiceInboundReportStateUpdatedCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ServiceInboundReportStateUpdatedCall) Do(f func(*types.ServiceState)) *ServiceInboundReportStateUpdatedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ServiceInboundReportStateUpdatedCall) DoAndReturn(f func(*types.ServiceState)) *ServiceInboundReportStateUpdatedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
