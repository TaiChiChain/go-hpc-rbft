// Code generated by MockGen. DO NOT EDIT.
// Source: ./node.go
//
// Generated by this command:
//
//	mockgen -destination ./mock_node.go -package rbft -source ./node.go -typed
//

// Package rbft is a generated GoMock package.
package rbft

import (
	context "context"
	reflect "reflect"

	consensus "github.com/axiomesh/axiom-bft/common/consensus"
	types "github.com/axiomesh/axiom-bft/types"
	types0 "github.com/axiomesh/axiom-kit/types"
	gomock "go.uber.org/mock/gomock"
)

// MockNode is a mock of Node interface.
type MockNode[T any, Constraint types0.TXConstraint[T]] struct {
	ctrl     *gomock.Controller
	recorder *MockNodeMockRecorder[T, Constraint]
}

// MockNodeMockRecorder is the mock recorder for MockNode.
type MockNodeMockRecorder[T any, Constraint types0.TXConstraint[T]] struct {
	mock *MockNode[T, Constraint]
}

// NewMockNode creates a new mock instance.
func NewMockNode[T any, Constraint types0.TXConstraint[T]](ctrl *gomock.Controller) *MockNode[T, Constraint] {
	mock := &MockNode[T, Constraint]{ctrl: ctrl}
	mock.recorder = &MockNodeMockRecorder[T, Constraint]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNode[T, Constraint]) EXPECT() *MockNodeMockRecorder[T, Constraint] {
	return m.recorder
}

// ArchiveMode mocks base method.
func (m *MockNode[T, Constraint]) ArchiveMode() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ArchiveMode")
	ret0, _ := ret[0].(bool)
	return ret0
}

// ArchiveMode indicates an expected call of ArchiveMode.
func (mr *MockNodeMockRecorder[T, Constraint]) ArchiveMode() *MockNodeArchiveModeCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ArchiveMode", reflect.TypeOf((*MockNode[T, Constraint])(nil).ArchiveMode))
	return &MockNodeArchiveModeCall[T, Constraint]{Call: call}
}

// MockNodeArchiveModeCall wrap *gomock.Call
type MockNodeArchiveModeCall[T any, Constraint types0.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNodeArchiveModeCall[T, Constraint]) Return(arg0 bool) *MockNodeArchiveModeCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNodeArchiveModeCall[T, Constraint]) Do(f func() bool) *MockNodeArchiveModeCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNodeArchiveModeCall[T, Constraint]) DoAndReturn(f func() bool) *MockNodeArchiveModeCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetLowWatermark mocks base method.
func (m *MockNode[T, Constraint]) GetLowWatermark() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLowWatermark")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetLowWatermark indicates an expected call of GetLowWatermark.
func (mr *MockNodeMockRecorder[T, Constraint]) GetLowWatermark() *MockNodeGetLowWatermarkCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLowWatermark", reflect.TypeOf((*MockNode[T, Constraint])(nil).GetLowWatermark))
	return &MockNodeGetLowWatermarkCall[T, Constraint]{Call: call}
}

// MockNodeGetLowWatermarkCall wrap *gomock.Call
type MockNodeGetLowWatermarkCall[T any, Constraint types0.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNodeGetLowWatermarkCall[T, Constraint]) Return(arg0 uint64) *MockNodeGetLowWatermarkCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNodeGetLowWatermarkCall[T, Constraint]) Do(f func() uint64) *MockNodeGetLowWatermarkCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNodeGetLowWatermarkCall[T, Constraint]) DoAndReturn(f func() uint64) *MockNodeGetLowWatermarkCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetUncommittedTransactions mocks base method.
func (m *MockNode[T, Constraint]) GetUncommittedTransactions(maxsize uint64) []*T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUncommittedTransactions", maxsize)
	ret0, _ := ret[0].([]*T)
	return ret0
}

// GetUncommittedTransactions indicates an expected call of GetUncommittedTransactions.
func (mr *MockNodeMockRecorder[T, Constraint]) GetUncommittedTransactions(maxsize any) *MockNodeGetUncommittedTransactionsCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUncommittedTransactions", reflect.TypeOf((*MockNode[T, Constraint])(nil).GetUncommittedTransactions), maxsize)
	return &MockNodeGetUncommittedTransactionsCall[T, Constraint]{Call: call}
}

// MockNodeGetUncommittedTransactionsCall wrap *gomock.Call
type MockNodeGetUncommittedTransactionsCall[T any, Constraint types0.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNodeGetUncommittedTransactionsCall[T, Constraint]) Return(arg0 []*T) *MockNodeGetUncommittedTransactionsCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNodeGetUncommittedTransactionsCall[T, Constraint]) Do(f func(uint64) []*T) *MockNodeGetUncommittedTransactionsCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNodeGetUncommittedTransactionsCall[T, Constraint]) DoAndReturn(f func(uint64) []*T) *MockNodeGetUncommittedTransactionsCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Init mocks base method.
func (m *MockNode[T, Constraint]) Init() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Init")
	ret0, _ := ret[0].(error)
	return ret0
}

// Init indicates an expected call of Init.
func (mr *MockNodeMockRecorder[T, Constraint]) Init() *MockNodeInitCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Init", reflect.TypeOf((*MockNode[T, Constraint])(nil).Init))
	return &MockNodeInitCall[T, Constraint]{Call: call}
}

// MockNodeInitCall wrap *gomock.Call
type MockNodeInitCall[T any, Constraint types0.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNodeInitCall[T, Constraint]) Return(arg0 error) *MockNodeInitCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNodeInitCall[T, Constraint]) Do(f func() error) *MockNodeInitCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNodeInitCall[T, Constraint]) DoAndReturn(f func() error) *MockNodeInitCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReportExecuted mocks base method.
func (m *MockNode[T, Constraint]) ReportExecuted(state *types.ServiceState) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ReportExecuted", state)
}

// ReportExecuted indicates an expected call of ReportExecuted.
func (mr *MockNodeMockRecorder[T, Constraint]) ReportExecuted(state any) *MockNodeReportExecutedCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReportExecuted", reflect.TypeOf((*MockNode[T, Constraint])(nil).ReportExecuted), state)
	return &MockNodeReportExecutedCall[T, Constraint]{Call: call}
}

// MockNodeReportExecutedCall wrap *gomock.Call
type MockNodeReportExecutedCall[T any, Constraint types0.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNodeReportExecutedCall[T, Constraint]) Return() *MockNodeReportExecutedCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNodeReportExecutedCall[T, Constraint]) Do(f func(*types.ServiceState)) *MockNodeReportExecutedCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNodeReportExecutedCall[T, Constraint]) DoAndReturn(f func(*types.ServiceState)) *MockNodeReportExecutedCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReportStateUpdated mocks base method.
func (m *MockNode[T, Constraint]) ReportStateUpdated(state *types.ServiceSyncState) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ReportStateUpdated", state)
}

// ReportStateUpdated indicates an expected call of ReportStateUpdated.
func (mr *MockNodeMockRecorder[T, Constraint]) ReportStateUpdated(state any) *MockNodeReportStateUpdatedCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReportStateUpdated", reflect.TypeOf((*MockNode[T, Constraint])(nil).ReportStateUpdated), state)
	return &MockNodeReportStateUpdatedCall[T, Constraint]{Call: call}
}

// MockNodeReportStateUpdatedCall wrap *gomock.Call
type MockNodeReportStateUpdatedCall[T any, Constraint types0.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNodeReportStateUpdatedCall[T, Constraint]) Return() *MockNodeReportStateUpdatedCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNodeReportStateUpdatedCall[T, Constraint]) Do(f func(*types.ServiceSyncState)) *MockNodeReportStateUpdatedCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNodeReportStateUpdatedCall[T, Constraint]) DoAndReturn(f func(*types.ServiceSyncState)) *MockNodeReportStateUpdatedCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Start mocks base method.
func (m *MockNode[T, Constraint]) Start() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start")
	ret0, _ := ret[0].(error)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockNodeMockRecorder[T, Constraint]) Start() *MockNodeStartCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockNode[T, Constraint])(nil).Start))
	return &MockNodeStartCall[T, Constraint]{Call: call}
}

// MockNodeStartCall wrap *gomock.Call
type MockNodeStartCall[T any, Constraint types0.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNodeStartCall[T, Constraint]) Return(arg0 error) *MockNodeStartCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNodeStartCall[T, Constraint]) Do(f func() error) *MockNodeStartCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNodeStartCall[T, Constraint]) DoAndReturn(f func() error) *MockNodeStartCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Status mocks base method.
func (m *MockNode[T, Constraint]) Status() NodeStatus {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Status")
	ret0, _ := ret[0].(NodeStatus)
	return ret0
}

// Status indicates an expected call of Status.
func (mr *MockNodeMockRecorder[T, Constraint]) Status() *MockNodeStatusCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Status", reflect.TypeOf((*MockNode[T, Constraint])(nil).Status))
	return &MockNodeStatusCall[T, Constraint]{Call: call}
}

// MockNodeStatusCall wrap *gomock.Call
type MockNodeStatusCall[T any, Constraint types0.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNodeStatusCall[T, Constraint]) Return(arg0 NodeStatus) *MockNodeStatusCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNodeStatusCall[T, Constraint]) Do(f func() NodeStatus) *MockNodeStatusCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNodeStatusCall[T, Constraint]) DoAndReturn(f func() NodeStatus) *MockNodeStatusCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Step mocks base method.
func (m *MockNode[T, Constraint]) Step(ctx context.Context, msg *consensus.ConsensusMessage) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Step", ctx, msg)
}

// Step indicates an expected call of Step.
func (mr *MockNodeMockRecorder[T, Constraint]) Step(ctx, msg any) *MockNodeStepCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Step", reflect.TypeOf((*MockNode[T, Constraint])(nil).Step), ctx, msg)
	return &MockNodeStepCall[T, Constraint]{Call: call}
}

// MockNodeStepCall wrap *gomock.Call
type MockNodeStepCall[T any, Constraint types0.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNodeStepCall[T, Constraint]) Return() *MockNodeStepCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNodeStepCall[T, Constraint]) Do(f func(context.Context, *consensus.ConsensusMessage)) *MockNodeStepCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNodeStepCall[T, Constraint]) DoAndReturn(f func(context.Context, *consensus.ConsensusMessage)) *MockNodeStepCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Stop mocks base method.
func (m *MockNode[T, Constraint]) Stop() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Stop")
}

// Stop indicates an expected call of Stop.
func (mr *MockNodeMockRecorder[T, Constraint]) Stop() *MockNodeStopCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockNode[T, Constraint])(nil).Stop))
	return &MockNodeStopCall[T, Constraint]{Call: call}
}

// MockNodeStopCall wrap *gomock.Call
type MockNodeStopCall[T any, Constraint types0.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockNodeStopCall[T, Constraint]) Return() *MockNodeStopCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockNodeStopCall[T, Constraint]) Do(f func()) *MockNodeStopCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockNodeStopCall[T, Constraint]) DoAndReturn(f func()) *MockNodeStopCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockServiceInbound is a mock of ServiceInbound interface.
type MockServiceInbound struct {
	ctrl     *gomock.Controller
	recorder *MockServiceInboundMockRecorder
}

// MockServiceInboundMockRecorder is the mock recorder for MockServiceInbound.
type MockServiceInboundMockRecorder struct {
	mock *MockServiceInbound
}

// NewMockServiceInbound creates a new mock instance.
func NewMockServiceInbound(ctrl *gomock.Controller) *MockServiceInbound {
	mock := &MockServiceInbound{ctrl: ctrl}
	mock.recorder = &MockServiceInboundMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockServiceInbound) EXPECT() *MockServiceInboundMockRecorder {
	return m.recorder
}

// ReportExecuted mocks base method.
func (m *MockServiceInbound) ReportExecuted(state *types.ServiceState) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ReportExecuted", state)
}

// ReportExecuted indicates an expected call of ReportExecuted.
func (mr *MockServiceInboundMockRecorder) ReportExecuted(state any) *MockServiceInboundReportExecutedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReportExecuted", reflect.TypeOf((*MockServiceInbound)(nil).ReportExecuted), state)
	return &MockServiceInboundReportExecutedCall{Call: call}
}

// MockServiceInboundReportExecutedCall wrap *gomock.Call
type MockServiceInboundReportExecutedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServiceInboundReportExecutedCall) Return() *MockServiceInboundReportExecutedCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServiceInboundReportExecutedCall) Do(f func(*types.ServiceState)) *MockServiceInboundReportExecutedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServiceInboundReportExecutedCall) DoAndReturn(f func(*types.ServiceState)) *MockServiceInboundReportExecutedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReportStateUpdated mocks base method.
func (m *MockServiceInbound) ReportStateUpdated(state *types.ServiceSyncState) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ReportStateUpdated", state)
}

// ReportStateUpdated indicates an expected call of ReportStateUpdated.
func (mr *MockServiceInboundMockRecorder) ReportStateUpdated(state any) *MockServiceInboundReportStateUpdatedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReportStateUpdated", reflect.TypeOf((*MockServiceInbound)(nil).ReportStateUpdated), state)
	return &MockServiceInboundReportStateUpdatedCall{Call: call}
}

// MockServiceInboundReportStateUpdatedCall wrap *gomock.Call
type MockServiceInboundReportStateUpdatedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockServiceInboundReportStateUpdatedCall) Return() *MockServiceInboundReportStateUpdatedCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockServiceInboundReportStateUpdatedCall) Do(f func(*types.ServiceSyncState)) *MockServiceInboundReportStateUpdatedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockServiceInboundReportStateUpdatedCall) DoAndReturn(f func(*types.ServiceSyncState)) *MockServiceInboundReportStateUpdatedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockInboundNode is a mock of InboundNode interface.
type MockInboundNode struct {
	ctrl     *gomock.Controller
	recorder *MockInboundNodeMockRecorder
}

// MockInboundNodeMockRecorder is the mock recorder for MockInboundNode.
type MockInboundNodeMockRecorder struct {
	mock *MockInboundNode
}

// NewMockInboundNode creates a new mock instance.
func NewMockInboundNode(ctrl *gomock.Controller) *MockInboundNode {
	mock := &MockInboundNode{ctrl: ctrl}
	mock.recorder = &MockInboundNodeMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInboundNode) EXPECT() *MockInboundNodeMockRecorder {
	return m.recorder
}

// ArchiveMode mocks base method.
func (m *MockInboundNode) ArchiveMode() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ArchiveMode")
	ret0, _ := ret[0].(bool)
	return ret0
}

// ArchiveMode indicates an expected call of ArchiveMode.
func (mr *MockInboundNodeMockRecorder) ArchiveMode() *MockInboundNodeArchiveModeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ArchiveMode", reflect.TypeOf((*MockInboundNode)(nil).ArchiveMode))
	return &MockInboundNodeArchiveModeCall{Call: call}
}

// MockInboundNodeArchiveModeCall wrap *gomock.Call
type MockInboundNodeArchiveModeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockInboundNodeArchiveModeCall) Return(arg0 bool) *MockInboundNodeArchiveModeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockInboundNodeArchiveModeCall) Do(f func() bool) *MockInboundNodeArchiveModeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockInboundNodeArchiveModeCall) DoAndReturn(f func() bool) *MockInboundNodeArchiveModeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetLowWatermark mocks base method.
func (m *MockInboundNode) GetLowWatermark() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLowWatermark")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetLowWatermark indicates an expected call of GetLowWatermark.
func (mr *MockInboundNodeMockRecorder) GetLowWatermark() *MockInboundNodeGetLowWatermarkCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLowWatermark", reflect.TypeOf((*MockInboundNode)(nil).GetLowWatermark))
	return &MockInboundNodeGetLowWatermarkCall{Call: call}
}

// MockInboundNodeGetLowWatermarkCall wrap *gomock.Call
type MockInboundNodeGetLowWatermarkCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockInboundNodeGetLowWatermarkCall) Return(arg0 uint64) *MockInboundNodeGetLowWatermarkCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockInboundNodeGetLowWatermarkCall) Do(f func() uint64) *MockInboundNodeGetLowWatermarkCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockInboundNodeGetLowWatermarkCall) DoAndReturn(f func() uint64) *MockInboundNodeGetLowWatermarkCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Init mocks base method.
func (m *MockInboundNode) Init() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Init")
	ret0, _ := ret[0].(error)
	return ret0
}

// Init indicates an expected call of Init.
func (mr *MockInboundNodeMockRecorder) Init() *MockInboundNodeInitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Init", reflect.TypeOf((*MockInboundNode)(nil).Init))
	return &MockInboundNodeInitCall{Call: call}
}

// MockInboundNodeInitCall wrap *gomock.Call
type MockInboundNodeInitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockInboundNodeInitCall) Return(arg0 error) *MockInboundNodeInitCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockInboundNodeInitCall) Do(f func() error) *MockInboundNodeInitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockInboundNodeInitCall) DoAndReturn(f func() error) *MockInboundNodeInitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReportExecuted mocks base method.
func (m *MockInboundNode) ReportExecuted(state *types.ServiceState) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ReportExecuted", state)
}

// ReportExecuted indicates an expected call of ReportExecuted.
func (mr *MockInboundNodeMockRecorder) ReportExecuted(state any) *MockInboundNodeReportExecutedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReportExecuted", reflect.TypeOf((*MockInboundNode)(nil).ReportExecuted), state)
	return &MockInboundNodeReportExecutedCall{Call: call}
}

// MockInboundNodeReportExecutedCall wrap *gomock.Call
type MockInboundNodeReportExecutedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockInboundNodeReportExecutedCall) Return() *MockInboundNodeReportExecutedCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockInboundNodeReportExecutedCall) Do(f func(*types.ServiceState)) *MockInboundNodeReportExecutedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockInboundNodeReportExecutedCall) DoAndReturn(f func(*types.ServiceState)) *MockInboundNodeReportExecutedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReportStateUpdated mocks base method.
func (m *MockInboundNode) ReportStateUpdated(state *types.ServiceSyncState) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ReportStateUpdated", state)
}

// ReportStateUpdated indicates an expected call of ReportStateUpdated.
func (mr *MockInboundNodeMockRecorder) ReportStateUpdated(state any) *MockInboundNodeReportStateUpdatedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReportStateUpdated", reflect.TypeOf((*MockInboundNode)(nil).ReportStateUpdated), state)
	return &MockInboundNodeReportStateUpdatedCall{Call: call}
}

// MockInboundNodeReportStateUpdatedCall wrap *gomock.Call
type MockInboundNodeReportStateUpdatedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockInboundNodeReportStateUpdatedCall) Return() *MockInboundNodeReportStateUpdatedCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockInboundNodeReportStateUpdatedCall) Do(f func(*types.ServiceSyncState)) *MockInboundNodeReportStateUpdatedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockInboundNodeReportStateUpdatedCall) DoAndReturn(f func(*types.ServiceSyncState)) *MockInboundNodeReportStateUpdatedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Start mocks base method.
func (m *MockInboundNode) Start() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start")
	ret0, _ := ret[0].(error)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockInboundNodeMockRecorder) Start() *MockInboundNodeStartCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockInboundNode)(nil).Start))
	return &MockInboundNodeStartCall{Call: call}
}

// MockInboundNodeStartCall wrap *gomock.Call
type MockInboundNodeStartCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockInboundNodeStartCall) Return(arg0 error) *MockInboundNodeStartCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockInboundNodeStartCall) Do(f func() error) *MockInboundNodeStartCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockInboundNodeStartCall) DoAndReturn(f func() error) *MockInboundNodeStartCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Status mocks base method.
func (m *MockInboundNode) Status() NodeStatus {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Status")
	ret0, _ := ret[0].(NodeStatus)
	return ret0
}

// Status indicates an expected call of Status.
func (mr *MockInboundNodeMockRecorder) Status() *MockInboundNodeStatusCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Status", reflect.TypeOf((*MockInboundNode)(nil).Status))
	return &MockInboundNodeStatusCall{Call: call}
}

// MockInboundNodeStatusCall wrap *gomock.Call
type MockInboundNodeStatusCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockInboundNodeStatusCall) Return(arg0 NodeStatus) *MockInboundNodeStatusCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockInboundNodeStatusCall) Do(f func() NodeStatus) *MockInboundNodeStatusCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockInboundNodeStatusCall) DoAndReturn(f func() NodeStatus) *MockInboundNodeStatusCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Step mocks base method.
func (m *MockInboundNode) Step(ctx context.Context, msg *consensus.ConsensusMessage) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Step", ctx, msg)
}

// Step indicates an expected call of Step.
func (mr *MockInboundNodeMockRecorder) Step(ctx, msg any) *MockInboundNodeStepCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Step", reflect.TypeOf((*MockInboundNode)(nil).Step), ctx, msg)
	return &MockInboundNodeStepCall{Call: call}
}

// MockInboundNodeStepCall wrap *gomock.Call
type MockInboundNodeStepCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockInboundNodeStepCall) Return() *MockInboundNodeStepCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockInboundNodeStepCall) Do(f func(context.Context, *consensus.ConsensusMessage)) *MockInboundNodeStepCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockInboundNodeStepCall) DoAndReturn(f func(context.Context, *consensus.ConsensusMessage)) *MockInboundNodeStepCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Stop mocks base method.
func (m *MockInboundNode) Stop() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Stop")
}

// Stop indicates an expected call of Stop.
func (mr *MockInboundNodeMockRecorder) Stop() *MockInboundNodeStopCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockInboundNode)(nil).Stop))
	return &MockInboundNodeStopCall{Call: call}
}

// MockInboundNodeStopCall wrap *gomock.Call
type MockInboundNodeStopCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockInboundNodeStopCall) Return() *MockInboundNodeStopCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockInboundNodeStopCall) Do(f func()) *MockInboundNodeStopCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockInboundNodeStopCall) DoAndReturn(f func()) *MockInboundNodeStopCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
