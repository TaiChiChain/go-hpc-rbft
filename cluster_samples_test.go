package rbft

import (
	"testing"
	"time"

	"github.com/ultramesh/flato-event/inner/protos"
	pb "github.com/ultramesh/flato-rbft/rbftpb"

	"github.com/golang/mock/gomock"
	"github.com/magiconair/properties/assert"
)

func TestFunction_ViewChange(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	// init cluster
	tf := newTestFramework(4, false)

	// start cluster
	tf.frameworkStart()
	preView := tf.TestNode[0].n.rbft.view

	// send incorrect pre-prepare
	reqBatch := &pb.RequestBatch{
		RequestHashList: []string{"str1", "str2"},
	}
	tf.TestNode[int(preView)%4].n.rbft.sendPrePrepare(uint64(2), "", reqBatch)
	time.Sleep(2 * time.Second)

	var finishView uint64
	for _, node := range tf.TestNode {
		if !node.n.rbft.atomicIn(InViewChange) {
			finishView = node.n.rbft.view
			flag := finishView == preView
			assert.Equal(t, flag, false, "error: "+string(node.ID))
			break
		}
	}
	for _, node := range tf.TestNode {
		if !node.n.rbft.atomicIn(InViewChange) {
			flag := node.n.rbft.view == finishView
			assert.Equal(t, flag, true, "error: "+string(node.ID))
		}
	}
	tf.frameworkStop()
}

func TestFunction_FetchRequestBatch(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	// init cluster
	tf := newTestFramework(4, false)

	// start cluster
	tf.frameworkStart()
	// send tx
	tf.sendTx(1, uint64(0))
	time.Sleep(1 * time.Second)

	preView := tf.TestNode[0].n.rbft.view
	selectIndext := (int(preView) + 1) % 4
	var batchToDelete *pb.RequestBatch
	for key, val := range tf.TestNode[selectIndext].n.rbft.storeMgr.batchStore {
		batchToDelete = val
		delete(tf.TestNode[selectIndext].n.rbft.storeMgr.batchStore, key)
	}
	tf.TestNode[int(preView)%4].n.rbft.sendViewChange()
	time.Sleep(1 * time.Second)

	if batchToDelete != nil {
		batchAfterFetch := tf.TestNode[selectIndext].n.rbft.storeMgr.batchStore[batchToDelete.BatchHash]
		assert.Equal(t, batchToDelete.BatchHash, batchAfterFetch.BatchHash)
		assert.Equal(t, batchToDelete.RequestList, batchAfterFetch.RequestList)
		assert.Equal(t, batchToDelete.Timestamp, batchAfterFetch.Timestamp)
	}
	tf.frameworkStop()
}

func TestFunction_FetchMissingTxs(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	// init cluster
	tf := newTestFramework(4, false)

	// start cluster
	tf.frameworkStart()
	tx1 := &protos.Transaction{Value: []byte("tx1")}
	tx2 := &protos.Transaction{Value: []byte("tx2")}
	tx3 := &protos.Transaction{Value: []byte("tx3")}
	tx4 := &protos.Transaction{Value: []byte("tx4")}
	tx5 := &protos.Transaction{Value: []byte("tx5")}
	tx6 := &protos.Transaction{Value: []byte("tx6")}
	tx7 := &protos.Transaction{Value: []byte("tx7")}
	tx8 := &protos.Transaction{Value: []byte("tx7")}
	txSet := []*protos.Transaction{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8}

	// only add 8 txs into primary node, and the tx-pool of replica is empty.
	// if consensus cluster is processing the batch generated by such 8 txs, replicas will fetch missing txs
	for _, node := range tf.TestNode {
		if node.n.rbft.isPrimary(node.n.rbft.peerPool.ID) {
			node.n.rbft.stopBatchTimer()
			for _, tx := range txSet {
				_ = node.n.rbft.batchMgr.requestPool.AddNewRequest(tx, false, true)
			}
			tf.sendTx(9, uint64(0))
		}
	}
	time.Sleep(1 * time.Second)

	// after missing txs fetched by replicas, transactions will be applied normally
	tf.frameworkStop()
}

func TestFunction_UpdateNode(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	// init cluster
	tf := newTestFramework(4, false)

	// start cluster
	tf.frameworkStart()
	time.Sleep(1 * time.Second)

	// add node 5
	tf.frameworkAddNode("node5", false)
	time.Sleep(1 * time.Second)
	tf.TestNode[4].n.rbft.atomicOff(InEpochSync)
	tf.TestNode[4].n.rbft.off(InSyncState)
	tf.TestNode[4].n.rbft.tryEpochSync()
	time.Sleep(2 * time.Second)

	for i := 4; i < 13; i++ {
		tf.sendTx(i, uint64(1))
	}
	for _, node := range tf.TestNode {
		if !node.n.rbft.atomicIn(InConfChange) {
			assert.Equal(t, node.n.rbft.N, 5)
		}
	}
	tf.frameworkStop()
}
