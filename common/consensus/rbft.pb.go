// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rbft.proto

package consensus

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Type int32

const (
	Type_NULL_REQUEST           Type = 0
	Type_PRE_PREPARE            Type = 1
	Type_PREPARE                Type = 2
	Type_COMMIT                 Type = 3
	Type_REQUEST_SET            Type = 4
	Type_SIGNED_CHECKPOINT      Type = 5
	Type_FETCH_CHECKPOINT       Type = 6
	Type_VIEW_CHANGE            Type = 7
	Type_QUORUM_VIEW_CHANGE     Type = 8
	Type_NEW_VIEW               Type = 9
	Type_FETCH_VIEW             Type = 10
	Type_RECOVERY_RESPONSE      Type = 11
	Type_FETCH_BATCH_REQUEST    Type = 12
	Type_FETCH_BATCH_RESPONSE   Type = 13
	Type_FETCH_PQC_REQUEST      Type = 14
	Type_FETCH_PQC_RESPONSE     Type = 15
	Type_FETCH_MISSING_REQUEST  Type = 16
	Type_FETCH_MISSING_RESPONSE Type = 17
	Type_SYNC_STATE             Type = 18
	Type_SYNC_STATE_RESPONSE    Type = 19
	Type_EPOCH_CHANGE_REQUEST   Type = 20
	Type_EPOCH_CHANGE_PROOF     Type = 21
)

var Type_name = map[int32]string{
	0:  "NULL_REQUEST",
	1:  "PRE_PREPARE",
	2:  "PREPARE",
	3:  "COMMIT",
	4:  "REQUEST_SET",
	5:  "SIGNED_CHECKPOINT",
	6:  "FETCH_CHECKPOINT",
	7:  "VIEW_CHANGE",
	8:  "QUORUM_VIEW_CHANGE",
	9:  "NEW_VIEW",
	10: "FETCH_VIEW",
	11: "RECOVERY_RESPONSE",
	12: "FETCH_BATCH_REQUEST",
	13: "FETCH_BATCH_RESPONSE",
	14: "FETCH_PQC_REQUEST",
	15: "FETCH_PQC_RESPONSE",
	16: "FETCH_MISSING_REQUEST",
	17: "FETCH_MISSING_RESPONSE",
	18: "SYNC_STATE",
	19: "SYNC_STATE_RESPONSE",
	20: "EPOCH_CHANGE_REQUEST",
	21: "EPOCH_CHANGE_PROOF",
}

var Type_value = map[string]int32{
	"NULL_REQUEST":           0,
	"PRE_PREPARE":            1,
	"PREPARE":                2,
	"COMMIT":                 3,
	"REQUEST_SET":            4,
	"SIGNED_CHECKPOINT":      5,
	"FETCH_CHECKPOINT":       6,
	"VIEW_CHANGE":            7,
	"QUORUM_VIEW_CHANGE":     8,
	"NEW_VIEW":               9,
	"FETCH_VIEW":             10,
	"RECOVERY_RESPONSE":      11,
	"FETCH_BATCH_REQUEST":    12,
	"FETCH_BATCH_RESPONSE":   13,
	"FETCH_PQC_REQUEST":      14,
	"FETCH_PQC_RESPONSE":     15,
	"FETCH_MISSING_REQUEST":  16,
	"FETCH_MISSING_RESPONSE": 17,
	"SYNC_STATE":             18,
	"SYNC_STATE_RESPONSE":    19,
	"EPOCH_CHANGE_REQUEST":   20,
	"EPOCH_CHANGE_PROOF":     21,
}

func (x Type) String() string {
	return proto.EnumName(Type_name, int32(x))
}

func (Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{0}
}

type ConsensusMessage struct {
	Type    Type   `protobuf:"varint,1,opt,name=type,proto3,enum=consensus.Type" json:"type,omitempty"`
	From    uint64 `protobuf:"varint,2,opt,name=from,proto3" json:"from,omitempty"`
	To      uint64 `protobuf:"varint,3,opt,name=to,proto3" json:"to,omitempty"`
	Epoch   uint64 `protobuf:"varint,4,opt,name=epoch,proto3" json:"epoch,omitempty"`
	View    uint64 `protobuf:"varint,5,opt,name=view,proto3" json:"view,omitempty"`
	Payload []byte `protobuf:"bytes,6,opt,name=payload,proto3" json:"payload,omitempty"`
	Nonce   int64  `protobuf:"varint,7,opt,name=nonce,proto3" json:"nonce,omitempty"`
}

func (m *ConsensusMessage) Reset()         { *m = ConsensusMessage{} }
func (m *ConsensusMessage) String() string { return proto.CompactTextString(m) }
func (*ConsensusMessage) ProtoMessage()    {}
func (*ConsensusMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{0}
}
func (m *ConsensusMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusMessage.Merge(m, src)
}
func (m *ConsensusMessage) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusMessage proto.InternalMessageInfo

func (m *ConsensusMessage) GetType() Type {
	if m != nil {
		return m.Type
	}
	return Type_NULL_REQUEST
}

func (m *ConsensusMessage) GetFrom() uint64 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *ConsensusMessage) GetTo() uint64 {
	if m != nil {
		return m.To
	}
	return 0
}

func (m *ConsensusMessage) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *ConsensusMessage) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *ConsensusMessage) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *ConsensusMessage) GetNonce() int64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

type NullRequest struct {
	ReplicaId uint64 `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
}

func (m *NullRequest) Reset()         { *m = NullRequest{} }
func (m *NullRequest) String() string { return proto.CompactTextString(m) }
func (*NullRequest) ProtoMessage()    {}
func (*NullRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{1}
}
func (m *NullRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NullRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NullRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NullRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NullRequest.Merge(m, src)
}
func (m *NullRequest) XXX_Size() int {
	return m.Size()
}
func (m *NullRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NullRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NullRequest proto.InternalMessageInfo

func (m *NullRequest) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

type PrePrepare struct {
	ReplicaId      uint64     `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	View           uint64     `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
	SequenceNumber uint64     `protobuf:"varint,3,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	BatchDigest    string     `protobuf:"bytes,4,opt,name=batch_digest,json=batchDigest,proto3" json:"batch_digest,omitempty"`
	HashBatch      *HashBatch `protobuf:"bytes,5,opt,name=hash_batch,json=hashBatch,proto3" json:"hash_batch,omitempty"`
}

func (m *PrePrepare) Reset()         { *m = PrePrepare{} }
func (m *PrePrepare) String() string { return proto.CompactTextString(m) }
func (*PrePrepare) ProtoMessage()    {}
func (*PrePrepare) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{2}
}
func (m *PrePrepare) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrePrepare) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrePrepare.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrePrepare) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrePrepare.Merge(m, src)
}
func (m *PrePrepare) XXX_Size() int {
	return m.Size()
}
func (m *PrePrepare) XXX_DiscardUnknown() {
	xxx_messageInfo_PrePrepare.DiscardUnknown(m)
}

var xxx_messageInfo_PrePrepare proto.InternalMessageInfo

func (m *PrePrepare) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *PrePrepare) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *PrePrepare) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *PrePrepare) GetBatchDigest() string {
	if m != nil {
		return m.BatchDigest
	}
	return ""
}

func (m *PrePrepare) GetHashBatch() *HashBatch {
	if m != nil {
		return m.HashBatch
	}
	return nil
}

type Prepare struct {
	ReplicaId      uint64 `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	View           uint64 `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
	SequenceNumber uint64 `protobuf:"varint,3,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	BatchDigest    string `protobuf:"bytes,4,opt,name=batch_digest,json=batchDigest,proto3" json:"batch_digest,omitempty"`
}

func (m *Prepare) Reset()         { *m = Prepare{} }
func (m *Prepare) String() string { return proto.CompactTextString(m) }
func (*Prepare) ProtoMessage()    {}
func (*Prepare) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{3}
}
func (m *Prepare) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Prepare) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Prepare.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Prepare) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Prepare.Merge(m, src)
}
func (m *Prepare) XXX_Size() int {
	return m.Size()
}
func (m *Prepare) XXX_DiscardUnknown() {
	xxx_messageInfo_Prepare.DiscardUnknown(m)
}

var xxx_messageInfo_Prepare proto.InternalMessageInfo

func (m *Prepare) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *Prepare) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *Prepare) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *Prepare) GetBatchDigest() string {
	if m != nil {
		return m.BatchDigest
	}
	return ""
}

type Commit struct {
	ReplicaId      uint64 `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	View           uint64 `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
	SequenceNumber uint64 `protobuf:"varint,3,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	BatchDigest    string `protobuf:"bytes,4,opt,name=batch_digest,json=batchDigest,proto3" json:"batch_digest,omitempty"`
}

func (m *Commit) Reset()         { *m = Commit{} }
func (m *Commit) String() string { return proto.CompactTextString(m) }
func (*Commit) ProtoMessage()    {}
func (*Commit) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{4}
}
func (m *Commit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Commit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Commit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Commit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Commit.Merge(m, src)
}
func (m *Commit) XXX_Size() int {
	return m.Size()
}
func (m *Commit) XXX_DiscardUnknown() {
	xxx_messageInfo_Commit.DiscardUnknown(m)
}

var xxx_messageInfo_Commit proto.InternalMessageInfo

func (m *Commit) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *Commit) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *Commit) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *Commit) GetBatchDigest() string {
	if m != nil {
		return m.BatchDigest
	}
	return ""
}

type RequestSet struct {
	Requests [][]byte `protobuf:"bytes,1,rep,name=requests,proto3" json:"requests,omitempty"`
	Local    bool     `protobuf:"varint,2,opt,name=local,proto3" json:"local,omitempty"`
}

func (m *RequestSet) Reset()         { *m = RequestSet{} }
func (m *RequestSet) String() string { return proto.CompactTextString(m) }
func (*RequestSet) ProtoMessage()    {}
func (*RequestSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{5}
}
func (m *RequestSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestSet.Merge(m, src)
}
func (m *RequestSet) XXX_Size() int {
	return m.Size()
}
func (m *RequestSet) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestSet.DiscardUnknown(m)
}

var xxx_messageInfo_RequestSet proto.InternalMessageInfo

func (m *RequestSet) GetRequests() [][]byte {
	if m != nil {
		return m.Requests
	}
	return nil
}

func (m *RequestSet) GetLocal() bool {
	if m != nil {
		return m.Local
	}
	return false
}

type HashBatch struct {
	RequestHashList            []string `protobuf:"bytes,1,rep,name=request_hash_list,json=requestHashList,proto3" json:"request_hash_list,omitempty"`
	DeDuplicateRequestHashList []string `protobuf:"bytes,2,rep,name=de_duplicate_request_hash_list,json=deDuplicateRequestHashList,proto3" json:"de_duplicate_request_hash_list,omitempty"`
	Timestamp                  int64    `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Proposer                   uint64   `protobuf:"varint,4,opt,name=proposer,proto3" json:"proposer,omitempty"`
}

func (m *HashBatch) Reset()         { *m = HashBatch{} }
func (m *HashBatch) String() string { return proto.CompactTextString(m) }
func (*HashBatch) ProtoMessage()    {}
func (*HashBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{6}
}
func (m *HashBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HashBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HashBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HashBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HashBatch.Merge(m, src)
}
func (m *HashBatch) XXX_Size() int {
	return m.Size()
}
func (m *HashBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_HashBatch.DiscardUnknown(m)
}

var xxx_messageInfo_HashBatch proto.InternalMessageInfo

func (m *HashBatch) GetRequestHashList() []string {
	if m != nil {
		return m.RequestHashList
	}
	return nil
}

func (m *HashBatch) GetDeDuplicateRequestHashList() []string {
	if m != nil {
		return m.DeDuplicateRequestHashList
	}
	return nil
}

func (m *HashBatch) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *HashBatch) GetProposer() uint64 {
	if m != nil {
		return m.Proposer
	}
	return 0
}

type FetchCheckpoint struct {
	ReplicaId      uint64 `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	SequenceNumber uint64 `protobuf:"varint,2,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
}

func (m *FetchCheckpoint) Reset()         { *m = FetchCheckpoint{} }
func (m *FetchCheckpoint) String() string { return proto.CompactTextString(m) }
func (*FetchCheckpoint) ProtoMessage()    {}
func (*FetchCheckpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{7}
}
func (m *FetchCheckpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchCheckpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchCheckpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchCheckpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchCheckpoint.Merge(m, src)
}
func (m *FetchCheckpoint) XXX_Size() int {
	return m.Size()
}
func (m *FetchCheckpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchCheckpoint.DiscardUnknown(m)
}

var xxx_messageInfo_FetchCheckpoint proto.InternalMessageInfo

func (m *FetchCheckpoint) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *FetchCheckpoint) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

type ViewChange struct {
	Basis     []byte `protobuf:"bytes,1,opt,name=basis,proto3" json:"basis,omitempty"`
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	Timestamp int64  `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Recovery  bool   `protobuf:"varint,4,opt,name=recovery,proto3" json:"recovery,omitempty"`
}

func (m *ViewChange) Reset()         { *m = ViewChange{} }
func (m *ViewChange) String() string { return proto.CompactTextString(m) }
func (*ViewChange) ProtoMessage()    {}
func (*ViewChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{8}
}
func (m *ViewChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViewChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewChange.Merge(m, src)
}
func (m *ViewChange) XXX_Size() int {
	return m.Size()
}
func (m *ViewChange) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewChange.DiscardUnknown(m)
}

var xxx_messageInfo_ViewChange proto.InternalMessageInfo

func (m *ViewChange) GetBasis() []byte {
	if m != nil {
		return m.Basis
	}
	return nil
}

func (m *ViewChange) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *ViewChange) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ViewChange) GetRecovery() bool {
	if m != nil {
		return m.Recovery
	}
	return false
}

type VcBasis struct {
	ReplicaId uint64              `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	View      uint64              `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
	H         uint64              `protobuf:"varint,3,opt,name=h,proto3" json:"h,omitempty"`
	Pset      []*Vc_PQ            `protobuf:"bytes,4,rep,name=pset,proto3" json:"pset,omitempty"`
	Qset      []*Vc_PQ            `protobuf:"bytes,5,rep,name=qset,proto3" json:"qset,omitempty"`
	Cset      []*SignedCheckpoint `protobuf:"bytes,6,rep,name=cset,proto3" json:"cset,omitempty"`
}

func (m *VcBasis) Reset()         { *m = VcBasis{} }
func (m *VcBasis) String() string { return proto.CompactTextString(m) }
func (*VcBasis) ProtoMessage()    {}
func (*VcBasis) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{9}
}
func (m *VcBasis) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VcBasis) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VcBasis.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VcBasis) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VcBasis.Merge(m, src)
}
func (m *VcBasis) XXX_Size() int {
	return m.Size()
}
func (m *VcBasis) XXX_DiscardUnknown() {
	xxx_messageInfo_VcBasis.DiscardUnknown(m)
}

var xxx_messageInfo_VcBasis proto.InternalMessageInfo

func (m *VcBasis) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *VcBasis) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *VcBasis) GetH() uint64 {
	if m != nil {
		return m.H
	}
	return 0
}

func (m *VcBasis) GetPset() []*Vc_PQ {
	if m != nil {
		return m.Pset
	}
	return nil
}

func (m *VcBasis) GetQset() []*Vc_PQ {
	if m != nil {
		return m.Qset
	}
	return nil
}

func (m *VcBasis) GetCset() []*SignedCheckpoint {
	if m != nil {
		return m.Cset
	}
	return nil
}

type Vc_PQ struct {
	SequenceNumber uint64 `protobuf:"varint,1,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	BatchDigest    string `protobuf:"bytes,2,opt,name=batch_digest,json=batchDigest,proto3" json:"batch_digest,omitempty"`
	View           uint64 `protobuf:"varint,3,opt,name=view,proto3" json:"view,omitempty"`
}

func (m *Vc_PQ) Reset()         { *m = Vc_PQ{} }
func (m *Vc_PQ) String() string { return proto.CompactTextString(m) }
func (*Vc_PQ) ProtoMessage()    {}
func (*Vc_PQ) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{10}
}
func (m *Vc_PQ) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vc_PQ) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vc_PQ.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vc_PQ) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vc_PQ.Merge(m, src)
}
func (m *Vc_PQ) XXX_Size() int {
	return m.Size()
}
func (m *Vc_PQ) XXX_DiscardUnknown() {
	xxx_messageInfo_Vc_PQ.DiscardUnknown(m)
}

var xxx_messageInfo_Vc_PQ proto.InternalMessageInfo

func (m *Vc_PQ) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *Vc_PQ) GetBatchDigest() string {
	if m != nil {
		return m.BatchDigest
	}
	return ""
}

func (m *Vc_PQ) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

type QuorumViewChange struct {
	ReplicaId   uint64        `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	ViewChanges []*ViewChange `protobuf:"bytes,2,rep,name=view_changes,json=viewChanges,proto3" json:"view_changes,omitempty"`
}

func (m *QuorumViewChange) Reset()         { *m = QuorumViewChange{} }
func (m *QuorumViewChange) String() string { return proto.CompactTextString(m) }
func (*QuorumViewChange) ProtoMessage()    {}
func (*QuorumViewChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{11}
}
func (m *QuorumViewChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuorumViewChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuorumViewChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuorumViewChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuorumViewChange.Merge(m, src)
}
func (m *QuorumViewChange) XXX_Size() int {
	return m.Size()
}
func (m *QuorumViewChange) XXX_DiscardUnknown() {
	xxx_messageInfo_QuorumViewChange.DiscardUnknown(m)
}

var xxx_messageInfo_QuorumViewChange proto.InternalMessageInfo

func (m *QuorumViewChange) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *QuorumViewChange) GetViewChanges() []*ViewChange {
	if m != nil {
		return m.ViewChanges
	}
	return nil
}

type NewView struct {
	ReplicaId        uint64            `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	View             uint64            `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
	Xset             []*Vc_PQ          `protobuf:"bytes,3,rep,name=xset,proto3" json:"xset,omitempty"`
	ViewChangeSet    *QuorumViewChange `protobuf:"bytes,4,opt,name=view_change_set,json=viewChangeSet,proto3" json:"view_change_set,omitempty"`
	QuorumCheckpoint *QuorumCheckpoint `protobuf:"bytes,5,opt,name=quorum_checkpoint,json=quorumCheckpoint,proto3" json:"quorum_checkpoint,omitempty"`
	Signature        []byte            `protobuf:"bytes,6,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *NewView) Reset()         { *m = NewView{} }
func (m *NewView) String() string { return proto.CompactTextString(m) }
func (*NewView) ProtoMessage()    {}
func (*NewView) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{12}
}
func (m *NewView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewView.Merge(m, src)
}
func (m *NewView) XXX_Size() int {
	return m.Size()
}
func (m *NewView) XXX_DiscardUnknown() {
	xxx_messageInfo_NewView.DiscardUnknown(m)
}

var xxx_messageInfo_NewView proto.InternalMessageInfo

func (m *NewView) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *NewView) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *NewView) GetXset() []*Vc_PQ {
	if m != nil {
		return m.Xset
	}
	return nil
}

func (m *NewView) GetViewChangeSet() *QuorumViewChange {
	if m != nil {
		return m.ViewChangeSet
	}
	return nil
}

func (m *NewView) GetQuorumCheckpoint() *QuorumCheckpoint {
	if m != nil {
		return m.QuorumCheckpoint
	}
	return nil
}

func (m *NewView) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type FetchView struct {
	ReplicaId uint64 `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	View      uint64 `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
}

func (m *FetchView) Reset()         { *m = FetchView{} }
func (m *FetchView) String() string { return proto.CompactTextString(m) }
func (*FetchView) ProtoMessage()    {}
func (*FetchView) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{13}
}
func (m *FetchView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchView.Merge(m, src)
}
func (m *FetchView) XXX_Size() int {
	return m.Size()
}
func (m *FetchView) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchView.DiscardUnknown(m)
}

var xxx_messageInfo_FetchView proto.InternalMessageInfo

func (m *FetchView) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *FetchView) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

type RecoveryResponse struct {
	NewView           *NewView          `protobuf:"bytes,1,opt,name=new_view,json=newView,proto3" json:"new_view,omitempty"`
	InitialCheckpoint *SignedCheckpoint `protobuf:"bytes,2,opt,name=initial_checkpoint,json=initialCheckpoint,proto3" json:"initial_checkpoint,omitempty"`
	// Help remote check genesis block digest
	GenesisBlockDigest string `protobuf:"bytes,3,opt,name=genesis_block_digest,json=genesisBlockDigest,proto3" json:"genesis_block_digest,omitempty"`
}

func (m *RecoveryResponse) Reset()         { *m = RecoveryResponse{} }
func (m *RecoveryResponse) String() string { return proto.CompactTextString(m) }
func (*RecoveryResponse) ProtoMessage()    {}
func (*RecoveryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{14}
}
func (m *RecoveryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecoveryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecoveryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryResponse.Merge(m, src)
}
func (m *RecoveryResponse) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryResponse proto.InternalMessageInfo

func (m *RecoveryResponse) GetNewView() *NewView {
	if m != nil {
		return m.NewView
	}
	return nil
}

func (m *RecoveryResponse) GetInitialCheckpoint() *SignedCheckpoint {
	if m != nil {
		return m.InitialCheckpoint
	}
	return nil
}

func (m *RecoveryResponse) GetGenesisBlockDigest() string {
	if m != nil {
		return m.GenesisBlockDigest
	}
	return ""
}

type FetchBatchRequest struct {
	ReplicaId   uint64 `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	BatchDigest string `protobuf:"bytes,2,opt,name=batch_digest,json=batchDigest,proto3" json:"batch_digest,omitempty"`
}

func (m *FetchBatchRequest) Reset()         { *m = FetchBatchRequest{} }
func (m *FetchBatchRequest) String() string { return proto.CompactTextString(m) }
func (*FetchBatchRequest) ProtoMessage()    {}
func (*FetchBatchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{15}
}
func (m *FetchBatchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchBatchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchBatchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchBatchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchBatchRequest.Merge(m, src)
}
func (m *FetchBatchRequest) XXX_Size() int {
	return m.Size()
}
func (m *FetchBatchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchBatchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FetchBatchRequest proto.InternalMessageInfo

func (m *FetchBatchRequest) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *FetchBatchRequest) GetBatchDigest() string {
	if m != nil {
		return m.BatchDigest
	}
	return ""
}

type FetchBatchResponse struct {
	ReplicaId   uint64        `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	Batch       *RequestBatch `protobuf:"bytes,2,opt,name=batch,proto3" json:"batch,omitempty"`
	BatchDigest string        `protobuf:"bytes,3,opt,name=batch_digest,json=batchDigest,proto3" json:"batch_digest,omitempty"`
}

func (m *FetchBatchResponse) Reset()         { *m = FetchBatchResponse{} }
func (m *FetchBatchResponse) String() string { return proto.CompactTextString(m) }
func (*FetchBatchResponse) ProtoMessage()    {}
func (*FetchBatchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{16}
}
func (m *FetchBatchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchBatchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchBatchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchBatchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchBatchResponse.Merge(m, src)
}
func (m *FetchBatchResponse) XXX_Size() int {
	return m.Size()
}
func (m *FetchBatchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchBatchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FetchBatchResponse proto.InternalMessageInfo

func (m *FetchBatchResponse) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *FetchBatchResponse) GetBatch() *RequestBatch {
	if m != nil {
		return m.Batch
	}
	return nil
}

func (m *FetchBatchResponse) GetBatchDigest() string {
	if m != nil {
		return m.BatchDigest
	}
	return ""
}

type RequestBatch struct {
	RequestHashList []string `protobuf:"bytes,1,rep,name=request_hash_list,json=requestHashList,proto3" json:"request_hash_list,omitempty"`
	RequestList     [][]byte `protobuf:"bytes,2,rep,name=request_list,json=requestList,proto3" json:"request_list,omitempty"`
	Timestamp       int64    `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	SeqNo           uint64   `protobuf:"varint,4,opt,name=seq_no,json=seqNo,proto3" json:"seq_no,omitempty"`
	LocalList       []bool   `protobuf:"varint,5,rep,packed,name=local_list,json=localList,proto3" json:"local_list,omitempty"`
	BatchHash       string   `protobuf:"bytes,6,opt,name=batch_hash,json=batchHash,proto3" json:"batch_hash,omitempty"`
	Proposer        uint64   `protobuf:"varint,7,opt,name=proposer,proto3" json:"proposer,omitempty"`
}

func (m *RequestBatch) Reset()         { *m = RequestBatch{} }
func (m *RequestBatch) String() string { return proto.CompactTextString(m) }
func (*RequestBatch) ProtoMessage()    {}
func (*RequestBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{17}
}
func (m *RequestBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestBatch.Merge(m, src)
}
func (m *RequestBatch) XXX_Size() int {
	return m.Size()
}
func (m *RequestBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestBatch.DiscardUnknown(m)
}

var xxx_messageInfo_RequestBatch proto.InternalMessageInfo

func (m *RequestBatch) GetRequestHashList() []string {
	if m != nil {
		return m.RequestHashList
	}
	return nil
}

func (m *RequestBatch) GetRequestList() [][]byte {
	if m != nil {
		return m.RequestList
	}
	return nil
}

func (m *RequestBatch) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *RequestBatch) GetSeqNo() uint64 {
	if m != nil {
		return m.SeqNo
	}
	return 0
}

func (m *RequestBatch) GetLocalList() []bool {
	if m != nil {
		return m.LocalList
	}
	return nil
}

func (m *RequestBatch) GetBatchHash() string {
	if m != nil {
		return m.BatchHash
	}
	return ""
}

func (m *RequestBatch) GetProposer() uint64 {
	if m != nil {
		return m.Proposer
	}
	return 0
}

type FetchMissingRequest struct {
	ReplicaId            uint64            `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	View                 uint64            `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
	SequenceNumber       uint64            `protobuf:"varint,3,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	BatchDigest          string            `protobuf:"bytes,4,opt,name=batch_digest,json=batchDigest,proto3" json:"batch_digest,omitempty"`
	MissingRequestHashes map[uint64]string `protobuf:"bytes,5,rep,name=missing_request_hashes,json=missingRequestHashes,proto3" json:"missing_request_hashes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *FetchMissingRequest) Reset()         { *m = FetchMissingRequest{} }
func (m *FetchMissingRequest) String() string { return proto.CompactTextString(m) }
func (*FetchMissingRequest) ProtoMessage()    {}
func (*FetchMissingRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{18}
}
func (m *FetchMissingRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchMissingRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchMissingRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchMissingRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchMissingRequest.Merge(m, src)
}
func (m *FetchMissingRequest) XXX_Size() int {
	return m.Size()
}
func (m *FetchMissingRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchMissingRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FetchMissingRequest proto.InternalMessageInfo

func (m *FetchMissingRequest) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *FetchMissingRequest) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *FetchMissingRequest) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *FetchMissingRequest) GetBatchDigest() string {
	if m != nil {
		return m.BatchDigest
	}
	return ""
}

func (m *FetchMissingRequest) GetMissingRequestHashes() map[uint64]string {
	if m != nil {
		return m.MissingRequestHashes
	}
	return nil
}

type FetchMissingResponse struct {
	ReplicaId            uint64            `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	View                 uint64            `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
	SequenceNumber       uint64            `protobuf:"varint,3,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	BatchDigest          string            `protobuf:"bytes,4,opt,name=batch_digest,json=batchDigest,proto3" json:"batch_digest,omitempty"`
	MissingRequestHashes map[uint64]string `protobuf:"bytes,5,rep,name=missing_request_hashes,json=missingRequestHashes,proto3" json:"missing_request_hashes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	MissingRequests      map[uint64][]byte `protobuf:"bytes,6,rep,name=missing_requests,json=missingRequests,proto3" json:"missing_requests,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *FetchMissingResponse) Reset()         { *m = FetchMissingResponse{} }
func (m *FetchMissingResponse) String() string { return proto.CompactTextString(m) }
func (*FetchMissingResponse) ProtoMessage()    {}
func (*FetchMissingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{19}
}
func (m *FetchMissingResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchMissingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchMissingResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchMissingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchMissingResponse.Merge(m, src)
}
func (m *FetchMissingResponse) XXX_Size() int {
	return m.Size()
}
func (m *FetchMissingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchMissingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FetchMissingResponse proto.InternalMessageInfo

func (m *FetchMissingResponse) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *FetchMissingResponse) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *FetchMissingResponse) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *FetchMissingResponse) GetBatchDigest() string {
	if m != nil {
		return m.BatchDigest
	}
	return ""
}

func (m *FetchMissingResponse) GetMissingRequestHashes() map[uint64]string {
	if m != nil {
		return m.MissingRequestHashes
	}
	return nil
}

func (m *FetchMissingResponse) GetMissingRequests() map[uint64][]byte {
	if m != nil {
		return m.MissingRequests
	}
	return nil
}

type FetchPQCRequest struct {
	ReplicaId uint64 `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	H         uint64 `protobuf:"varint,2,opt,name=h,proto3" json:"h,omitempty"`
}

func (m *FetchPQCRequest) Reset()         { *m = FetchPQCRequest{} }
func (m *FetchPQCRequest) String() string { return proto.CompactTextString(m) }
func (*FetchPQCRequest) ProtoMessage()    {}
func (*FetchPQCRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{20}
}
func (m *FetchPQCRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchPQCRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchPQCRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchPQCRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchPQCRequest.Merge(m, src)
}
func (m *FetchPQCRequest) XXX_Size() int {
	return m.Size()
}
func (m *FetchPQCRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchPQCRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FetchPQCRequest proto.InternalMessageInfo

func (m *FetchPQCRequest) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *FetchPQCRequest) GetH() uint64 {
	if m != nil {
		return m.H
	}
	return 0
}

type FetchPQCResponse struct {
	ReplicaId uint64        `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	PrepreSet []*PrePrepare `protobuf:"bytes,2,rep,name=prepre_set,json=prepreSet,proto3" json:"prepre_set,omitempty"`
	PreSet    []*Prepare    `protobuf:"bytes,3,rep,name=pre_set,json=preSet,proto3" json:"pre_set,omitempty"`
	CmtSet    []*Commit     `protobuf:"bytes,4,rep,name=cmt_set,json=cmtSet,proto3" json:"cmt_set,omitempty"`
}

func (m *FetchPQCResponse) Reset()         { *m = FetchPQCResponse{} }
func (m *FetchPQCResponse) String() string { return proto.CompactTextString(m) }
func (*FetchPQCResponse) ProtoMessage()    {}
func (*FetchPQCResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{21}
}
func (m *FetchPQCResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchPQCResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchPQCResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchPQCResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchPQCResponse.Merge(m, src)
}
func (m *FetchPQCResponse) XXX_Size() int {
	return m.Size()
}
func (m *FetchPQCResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchPQCResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FetchPQCResponse proto.InternalMessageInfo

func (m *FetchPQCResponse) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *FetchPQCResponse) GetPrepreSet() []*PrePrepare {
	if m != nil {
		return m.PrepreSet
	}
	return nil
}

func (m *FetchPQCResponse) GetPreSet() []*Prepare {
	if m != nil {
		return m.PreSet
	}
	return nil
}

func (m *FetchPQCResponse) GetCmtSet() []*Commit {
	if m != nil {
		return m.CmtSet
	}
	return nil
}

type SyncState struct {
	ReplicaId uint64 `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
}

func (m *SyncState) Reset()         { *m = SyncState{} }
func (m *SyncState) String() string { return proto.CompactTextString(m) }
func (*SyncState) ProtoMessage()    {}
func (*SyncState) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{22}
}
func (m *SyncState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncState.Merge(m, src)
}
func (m *SyncState) XXX_Size() int {
	return m.Size()
}
func (m *SyncState) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncState.DiscardUnknown(m)
}

var xxx_messageInfo_SyncState proto.InternalMessageInfo

func (m *SyncState) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

type SyncStateResponse struct {
	ReplicaId        uint64            `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	View             uint64            `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
	SignedCheckpoint *SignedCheckpoint `protobuf:"bytes,3,opt,name=signed_checkpoint,json=signedCheckpoint,proto3" json:"signed_checkpoint,omitempty"`
}

func (m *SyncStateResponse) Reset()         { *m = SyncStateResponse{} }
func (m *SyncStateResponse) String() string { return proto.CompactTextString(m) }
func (*SyncStateResponse) ProtoMessage()    {}
func (*SyncStateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{23}
}
func (m *SyncStateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncStateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncStateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncStateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncStateResponse.Merge(m, src)
}
func (m *SyncStateResponse) XXX_Size() int {
	return m.Size()
}
func (m *SyncStateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncStateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SyncStateResponse proto.InternalMessageInfo

func (m *SyncStateResponse) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *SyncStateResponse) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *SyncStateResponse) GetSignedCheckpoint() *SignedCheckpoint {
	if m != nil {
		return m.SignedCheckpoint
	}
	return nil
}

// EpochChangeRequest is used to get a EpochChangeProof from start_epoch to target_epoch.
type EpochChangeRequest struct {
	// Author of the request.
	Author uint64 `protobuf:"varint,1,opt,name=author,proto3" json:"author,omitempty"`
	// The start epoch for the request.
	StartEpoch uint64 `protobuf:"varint,2,opt,name=start_epoch,json=startEpoch,proto3" json:"start_epoch,omitempty"`
	// The target epoch for the request
	TargetEpoch uint64 `protobuf:"varint,3,opt,name=target_epoch,json=targetEpoch,proto3" json:"target_epoch,omitempty"`
}

func (m *EpochChangeRequest) Reset()         { *m = EpochChangeRequest{} }
func (m *EpochChangeRequest) String() string { return proto.CompactTextString(m) }
func (*EpochChangeRequest) ProtoMessage()    {}
func (*EpochChangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{24}
}
func (m *EpochChangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EpochChangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EpochChangeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EpochChangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EpochChangeRequest.Merge(m, src)
}
func (m *EpochChangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *EpochChangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EpochChangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EpochChangeRequest proto.InternalMessageInfo

func (m *EpochChangeRequest) GetAuthor() uint64 {
	if m != nil {
		return m.Author
	}
	return 0
}

func (m *EpochChangeRequest) GetStartEpoch() uint64 {
	if m != nil {
		return m.StartEpoch
	}
	return 0
}

func (m *EpochChangeRequest) GetTargetEpoch() uint64 {
	if m != nil {
		return m.TargetEpoch
	}
	return 0
}

type Pset struct {
	Set []*Prepare `protobuf:"bytes,1,rep,name=set,proto3" json:"set,omitempty"`
}

func (m *Pset) Reset()         { *m = Pset{} }
func (m *Pset) String() string { return proto.CompactTextString(m) }
func (*Pset) ProtoMessage()    {}
func (*Pset) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{25}
}
func (m *Pset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pset.Merge(m, src)
}
func (m *Pset) XXX_Size() int {
	return m.Size()
}
func (m *Pset) XXX_DiscardUnknown() {
	xxx_messageInfo_Pset.DiscardUnknown(m)
}

var xxx_messageInfo_Pset proto.InternalMessageInfo

func (m *Pset) GetSet() []*Prepare {
	if m != nil {
		return m.Set
	}
	return nil
}

type Cset struct {
	Set []*Commit `protobuf:"bytes,1,rep,name=set,proto3" json:"set,omitempty"`
}

func (m *Cset) Reset()         { *m = Cset{} }
func (m *Cset) String() string { return proto.CompactTextString(m) }
func (*Cset) ProtoMessage()    {}
func (*Cset) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{26}
}
func (m *Cset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cset.Merge(m, src)
}
func (m *Cset) XXX_Size() int {
	return m.Size()
}
func (m *Cset) XXX_DiscardUnknown() {
	xxx_messageInfo_Cset.DiscardUnknown(m)
}

var xxx_messageInfo_Cset proto.InternalMessageInfo

func (m *Cset) GetSet() []*Commit {
	if m != nil {
		return m.Set
	}
	return nil
}

func init() {
	proto.RegisterEnum("consensus.Type", Type_name, Type_value)
	proto.RegisterType((*ConsensusMessage)(nil), "consensus.consensus_message")
	proto.RegisterType((*NullRequest)(nil), "consensus.null_request")
	proto.RegisterType((*PrePrepare)(nil), "consensus.pre_prepare")
	proto.RegisterType((*Prepare)(nil), "consensus.prepare")
	proto.RegisterType((*Commit)(nil), "consensus.commit")
	proto.RegisterType((*RequestSet)(nil), "consensus.request_set")
	proto.RegisterType((*HashBatch)(nil), "consensus.hash_batch")
	proto.RegisterType((*FetchCheckpoint)(nil), "consensus.fetch_checkpoint")
	proto.RegisterType((*ViewChange)(nil), "consensus.view_change")
	proto.RegisterType((*VcBasis)(nil), "consensus.vc_basis")
	proto.RegisterType((*Vc_PQ)(nil), "consensus.vc_PQ")
	proto.RegisterType((*QuorumViewChange)(nil), "consensus.quorum_view_change")
	proto.RegisterType((*NewView)(nil), "consensus.new_view")
	proto.RegisterType((*FetchView)(nil), "consensus.fetch_view")
	proto.RegisterType((*RecoveryResponse)(nil), "consensus.recovery_response")
	proto.RegisterType((*FetchBatchRequest)(nil), "consensus.fetch_batch_request")
	proto.RegisterType((*FetchBatchResponse)(nil), "consensus.fetch_batch_response")
	proto.RegisterType((*RequestBatch)(nil), "consensus.request_batch")
	proto.RegisterType((*FetchMissingRequest)(nil), "consensus.fetch_missing_request")
	proto.RegisterMapType((map[uint64]string)(nil), "consensus.fetch_missing_request.MissingRequestHashesEntry")
	proto.RegisterType((*FetchMissingResponse)(nil), "consensus.fetch_missing_response")
	proto.RegisterMapType((map[uint64]string)(nil), "consensus.fetch_missing_response.MissingRequestHashesEntry")
	proto.RegisterMapType((map[uint64][]byte)(nil), "consensus.fetch_missing_response.MissingRequestsEntry")
	proto.RegisterType((*FetchPQCRequest)(nil), "consensus.fetchPQC_request")
	proto.RegisterType((*FetchPQCResponse)(nil), "consensus.fetchPQC_response")
	proto.RegisterType((*SyncState)(nil), "consensus.sync_state")
	proto.RegisterType((*SyncStateResponse)(nil), "consensus.sync_state_response")
	proto.RegisterType((*EpochChangeRequest)(nil), "consensus.EpochChangeRequest")
	proto.RegisterType((*Pset)(nil), "consensus.Pset")
	proto.RegisterType((*Cset)(nil), "consensus.Cset")
}

func init() { proto.RegisterFile("rbft.proto", fileDescriptor_4294ee733f83ad1d) }

var fileDescriptor_4294ee733f83ad1d = []byte{
	// 1540 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcf, 0x73, 0xdb, 0xc4,
	0x17, 0x8f, 0x2c, 0xc7, 0x3f, 0x9e, 0xdd, 0x44, 0xde, 0x38, 0xf9, 0xba, 0xf9, 0xd2, 0x90, 0xaa,
	0x9d, 0x21, 0xd3, 0x42, 0x60, 0xc2, 0x8f, 0x81, 0x72, 0xe8, 0x24, 0xae, 0x9a, 0x04, 0x1a, 0xdb,
	0x59, 0x3b, 0xed, 0x94, 0xcb, 0x8e, 0x22, 0x6f, 0x6d, 0x4d, 0x6d, 0x49, 0xd1, 0xca, 0x29, 0x19,
	0xfe, 0x00, 0x38, 0x32, 0xfd, 0x63, 0xb8, 0xc3, 0xa9, 0xc7, 0xc2, 0x89, 0x23, 0xd3, 0x9e, 0xf9,
	0x07, 0x38, 0x31, 0xbb, 0x2b, 0x59, 0xb2, 0x9d, 0x60, 0xb7, 0xd0, 0x81, 0x8b, 0x47, 0xef, 0xbd,
	0xcf, 0x7b, 0xfb, 0x7e, 0xed, 0xbe, 0x5d, 0x03, 0xf8, 0xc7, 0x8f, 0x82, 0x4d, 0xcf, 0x77, 0x03,
	0x17, 0xe5, 0x2d, 0xd7, 0x61, 0xd4, 0x61, 0x03, 0xb6, 0xaa, 0x59, 0x5d, 0x6a, 0x3d, 0xf6, 0x5c,
	0xdb, 0x09, 0x85, 0xfa, 0x0f, 0x0a, 0x94, 0x86, 0x72, 0xd2, 0xa7, 0x8c, 0x99, 0x1d, 0x8a, 0xae,
	0x41, 0x3a, 0x38, 0xf3, 0x68, 0x45, 0x59, 0x57, 0x36, 0x16, 0xb6, 0x16, 0x37, 0x87, 0x88, 0xcd,
	0xd6, 0x99, 0x47, 0xb1, 0x10, 0x22, 0x04, 0xe9, 0x47, 0xbe, 0xdb, 0xaf, 0xa4, 0xd6, 0x95, 0x8d,
	0x34, 0x16, 0xdf, 0x68, 0x01, 0x52, 0x81, 0x5b, 0x51, 0x05, 0x27, 0x15, 0xb8, 0xa8, 0x0c, 0xf3,
	0xd4, 0x73, 0xad, 0x6e, 0x25, 0x2d, 0x58, 0x92, 0xe0, 0x9a, 0xa7, 0x36, 0x7d, 0x52, 0x99, 0x97,
	0x9a, 0xfc, 0x1b, 0x55, 0x20, 0xeb, 0x99, 0x67, 0x3d, 0xd7, 0x6c, 0x57, 0x32, 0xeb, 0xca, 0x46,
	0x11, 0x47, 0x24, 0xb7, 0xe1, 0xb8, 0x8e, 0x45, 0x2b, 0xd9, 0x75, 0x65, 0x43, 0xc5, 0x92, 0xd0,
	0xdf, 0x83, 0xa2, 0x33, 0xe8, 0xf5, 0x88, 0x4f, 0x4f, 0x06, 0x94, 0x05, 0xe8, 0x0a, 0x80, 0x4f,
	0xbd, 0x9e, 0x6d, 0x99, 0xc4, 0x6e, 0x0b, 0xc7, 0xd3, 0x38, 0x1f, 0x72, 0xf6, 0xdb, 0xfa, 0x4f,
	0x0a, 0x14, 0x3c, 0x9f, 0x12, 0xcf, 0xa7, 0x9e, 0xe9, 0xd3, 0x29, 0xf0, 0xa1, 0x87, 0xa9, 0x84,
	0x87, 0xef, 0xc0, 0x22, 0xe3, 0x8b, 0x39, 0x16, 0x25, 0xce, 0xa0, 0x7f, 0x4c, 0xfd, 0x30, 0xd0,
	0x85, 0x88, 0x5d, 0x13, 0x5c, 0x74, 0x15, 0x8a, 0xc7, 0x66, 0x60, 0x75, 0x49, 0xdb, 0xee, 0x50,
	0x16, 0x88, 0xd8, 0xf3, 0xb8, 0x20, 0x78, 0x77, 0x04, 0x0b, 0x7d, 0x04, 0xd0, 0x35, 0x59, 0x97,
	0x08, 0x9e, 0xc8, 0x43, 0x61, 0x6b, 0x39, 0x91, 0xe6, 0x58, 0x88, 0xf3, 0xfc, 0x7b, 0x87, 0x7f,
	0xea, 0xdf, 0x29, 0x90, 0xfd, 0x6f, 0x04, 0xa0, 0x7f, 0xab, 0x40, 0xc6, 0x72, 0xfb, 0x7d, 0x3b,
	0xf8, 0xb7, 0x3d, 0xb9, 0x0d, 0x85, 0xb0, 0x07, 0x08, 0xa3, 0x01, 0x5a, 0x85, 0x5c, 0x48, 0xb2,
	0x8a, 0xb2, 0xae, 0x6e, 0x14, 0xf1, 0x90, 0xe6, 0x9d, 0xd4, 0x73, 0x2d, 0xb3, 0x27, 0x7c, 0xc9,
	0x61, 0x49, 0xf0, 0x2d, 0x90, 0x28, 0x06, 0xba, 0x01, 0xa5, 0xc8, 0x9e, 0xe0, 0xf6, 0x6c, 0x16,
	0x08, 0x4b, 0x79, 0xbc, 0x18, 0x0a, 0xf6, 0x4c, 0xd6, 0xbd, 0x67, 0xb3, 0x00, 0xed, 0xc0, 0x5a,
	0x9b, 0x92, 0xf6, 0x40, 0xc4, 0x1a, 0x50, 0x32, 0xa9, 0x98, 0x12, 0x8a, 0xab, 0x6d, 0x7a, 0x27,
	0x02, 0xe1, 0x31, 0x1b, 0x6f, 0x41, 0x3e, 0xb0, 0xfb, 0x94, 0x05, 0x66, 0xdf, 0x13, 0x59, 0x50,
	0x71, 0xcc, 0xe0, 0xe1, 0x78, 0xbe, 0xeb, 0xb9, 0x8c, 0xfa, 0xe1, 0x1e, 0x1a, 0xd2, 0xfa, 0x57,
	0xa0, 0x3d, 0xa2, 0x3c, 0x39, 0xf1, 0xae, 0x9e, 0x56, 0x8c, 0x73, 0x12, 0x9f, 0x3a, 0x2f, 0xf1,
	0xfa, 0x37, 0x50, 0xe0, 0x95, 0x22, 0x56, 0xd7, 0x74, 0x3a, 0x94, 0x67, 0xee, 0xd8, 0x64, 0x36,
	0x13, 0x16, 0x8b, 0x58, 0x12, 0xdc, 0x75, 0x66, 0x77, 0x1c, 0x33, 0x18, 0xf8, 0x54, 0xd8, 0x29,
	0xe2, 0x98, 0x31, 0x3d, 0x30, 0x9f, 0x5a, 0xee, 0x29, 0xf5, 0xcf, 0x44, 0x60, 0x39, 0x3c, 0xa4,
	0xf5, 0x67, 0x0a, 0xe4, 0x4e, 0x2d, 0x22, 0x17, 0x79, 0x8d, 0xf6, 0x2a, 0x82, 0xd2, 0x0d, 0x1b,
	0x4a, 0xe9, 0xa2, 0xeb, 0x90, 0xf6, 0x18, 0xe5, 0xbd, 0xa3, 0x6e, 0x14, 0xb6, 0xb4, 0xc4, 0x2e,
	0x3b, 0xb5, 0x48, 0xe3, 0x10, 0x0b, 0x29, 0x47, 0x9d, 0x70, 0xd4, 0xfc, 0x45, 0x28, 0x2e, 0x45,
	0xef, 0x43, 0xda, 0xe2, 0xa8, 0x8c, 0x40, 0xfd, 0x3f, 0x81, 0x6a, 0xda, 0x1d, 0x87, 0xb6, 0xab,
	0xc3, 0x4a, 0x60, 0x01, 0xd4, 0x3b, 0x30, 0x2f, 0xf4, 0xcf, 0xcb, 0xbc, 0x32, 0x53, 0xcb, 0xa7,
	0x26, 0x4f, 0x8f, 0x28, 0x66, 0x35, 0x8e, 0x59, 0x77, 0x00, 0x9d, 0x0c, 0x5c, 0x7f, 0xd0, 0x27,
	0xc9, 0xba, 0x4d, 0x49, 0xde, 0x67, 0x50, 0x4c, 0xa0, 0x99, 0xe8, 0xd6, 0xc2, 0xd6, 0x4a, 0x32,
	0xf8, 0x58, 0x8c, 0x45, 0x47, 0x54, 0x25, 0x54, 0x7f, 0x9a, 0x82, 0x9c, 0x43, 0x9f, 0x88, 0xd5,
	0x5e, 0xa7, 0x46, 0xd7, 0x21, 0xfd, 0x35, 0xcf, 0xa4, 0x7a, 0x51, 0xbe, 0xb9, 0x14, 0x19, 0xb0,
	0x98, 0xf0, 0x80, 0xc8, 0x32, 0xf2, 0xc3, 0xf2, 0x4a, 0x42, 0x61, 0x32, 0x6e, 0x7c, 0x29, 0x76,
	0xb5, 0x49, 0x03, 0xb4, 0x07, 0xa5, 0x10, 0x14, 0x6f, 0x95, 0xf0, 0xd4, 0x4d, 0xd6, 0xf0, 0x50,
	0x60, 0x12, 0x35, 0xd4, 0x4e, 0xc6, 0x38, 0xa3, 0x2d, 0x9f, 0x19, 0x6b, 0x79, 0xfd, 0x36, 0x80,
	0xdc, 0x91, 0xaf, 0x99, 0x15, 0xfd, 0x47, 0x85, 0x9f, 0x3e, 0x72, 0x1b, 0x10, 0x9f, 0x32, 0x8f,
	0xfb, 0x86, 0x36, 0xe3, 0x54, 0x0b, 0x33, 0x85, 0xad, 0xa5, 0x84, 0xd7, 0x91, 0x08, 0x67, 0x1d,
	0xfa, 0xe4, 0x3e, 0x5f, 0xf8, 0x0b, 0x40, 0xb6, 0x63, 0x07, 0xb6, 0xd9, 0x4b, 0xc6, 0x9b, 0x9a,
	0x88, 0x77, 0xa2, 0x67, 0x4b, 0xa1, 0x5a, 0x22, 0xe0, 0x0f, 0xa0, 0xdc, 0xa1, 0x0e, 0x65, 0x36,
	0x23, 0xc7, 0x3d, 0xd7, 0x7a, 0x1c, 0xb5, 0xa5, 0x2a, 0xda, 0x12, 0x85, 0xb2, 0x1d, 0x2e, 0x0a,
	0x0f, 0xe4, 0x07, 0xb0, 0x24, 0x93, 0x20, 0xdb, 0x78, 0xb6, 0x01, 0x3d, 0x43, 0xdb, 0xf3, 0xf1,
	0x57, 0x1e, 0xb5, 0x1c, 0xe6, 0x67, 0x8a, 0xe9, 0x4d, 0x7e, 0x78, 0xf1, 0x39, 0x2b, 0x33, 0x50,
	0x49, 0x64, 0x20, 0x3a, 0xb0, 0xe5, 0xa8, 0x95, 0xb0, 0x09, 0x57, 0xd4, 0x49, 0x57, 0x7e, 0x57,
	0xe0, 0xd2, 0x88, 0xee, 0x2b, 0x8d, 0x8d, 0xab, 0x50, 0x8c, 0xb0, 0xc3, 0x21, 0x51, 0xc4, 0xd1,
	0x18, 0x9b, 0x61, 0x2a, 0x2c, 0x43, 0x86, 0xd1, 0x13, 0xe2, 0xb8, 0xd1, 0xbd, 0x8a, 0xd1, 0x93,
	0x9a, 0xcb, 0xf3, 0x20, 0x46, 0x9a, 0xb4, 0xca, 0x4f, 0xb2, 0x1c, 0xce, 0x0b, 0x8e, 0xb0, 0x79,
	0x05, 0x40, 0xc6, 0xc5, 0x1d, 0x14, 0xcd, 0x9b, 0xc7, 0x79, 0xc1, 0xe1, 0x9e, 0x8d, 0x8c, 0x9a,
	0xec, 0xd8, 0xa8, 0xf9, 0x39, 0x05, 0xcb, 0x32, 0xf5, 0x7d, 0x9b, 0x31, 0xdb, 0xe9, 0xcc, 0x5a,
	0xd6, 0x37, 0x7d, 0x91, 0xf2, 0x60, 0x65, 0xcc, 0x23, 0x11, 0x1d, 0x65, 0xe1, 0x41, 0x7e, 0x2b,
	0x51, 0xec, 0x73, 0x03, 0xd8, 0x3c, 0x90, 0x74, 0x62, 0x2c, 0x53, 0x66, 0x38, 0x81, 0x7f, 0x86,
	0xcb, 0xfd, 0x73, 0x44, 0xab, 0xbb, 0x70, 0xf9, 0x42, 0x15, 0xa4, 0x81, 0xfa, 0x98, 0x9e, 0x85,
	0x69, 0xe0, 0x9f, 0x7c, 0x72, 0x9e, 0x9a, 0xbd, 0x01, 0x0d, 0x1b, 0x5a, 0x12, 0xb7, 0x52, 0x9f,
	0x2a, 0xfa, 0x1f, 0x2a, 0xac, 0x8c, 0xbb, 0x34, 0x5b, 0x43, 0xbf, 0xe9, 0xa4, 0x9e, 0x4c, 0x49,
	0xea, 0xe7, 0x7f, 0x91, 0x54, 0x19, 0xc1, 0xab, 0x66, 0x15, 0x99, 0xa0, 0x8d, 0x2d, 0xc9, 0xc2,
	0x21, 0xfb, 0xc9, 0xab, 0x2e, 0x16, 0xae, 0xb3, 0x38, 0xba, 0xce, 0x3f, 0x57, 0xb8, 0xd5, 0x1d,
	0x28, 0x9f, 0xb7, 0xe2, 0x34, 0x1b, 0xc5, 0x64, 0xf1, 0x6f, 0x87, 0x77, 0xb7, 0xc6, 0x61, 0x75,
	0xd6, 0xad, 0x24, 0x6e, 0x35, 0xa9, 0xf0, 0x56, 0xc3, 0x1f, 0x34, 0xa5, 0x84, 0x85, 0xd9, 0x1a,
	0xe7, 0x63, 0x00, 0xfe, 0x7e, 0xf0, 0xe5, 0x24, 0x9d, 0x9c, 0xf6, 0x89, 0x17, 0x12, 0xce, 0x4b,
	0x24, 0x1f, 0x9f, 0x37, 0xc5, 0xb3, 0x83, 0xc4, 0xe3, 0x1a, 0x8d, 0xea, 0x08, 0x7c, 0x26, 0x04,
	0xdf, 0x80, 0xac, 0xd5, 0x0f, 0x48, 0x7c, 0xe3, 0x2a, 0x25, 0xc0, 0xf2, 0xc9, 0x80, 0x33, 0x56,
	0x3f, 0x68, 0xd2, 0x40, 0xbf, 0x09, 0xc0, 0xce, 0x1c, 0x8b, 0xb0, 0xc0, 0x0c, 0xa6, 0x39, 0xaf,
	0x3f, 0x55, 0x60, 0x29, 0x46, 0xff, 0xad, 0xcd, 0xb2, 0x07, 0x25, 0x26, 0x66, 0x5f, 0x72, 0x3e,
	0xaa, 0xd3, 0xe7, 0xa3, 0xc6, 0xc6, 0x38, 0xba, 0x07, 0xc8, 0xe0, 0x6f, 0x5a, 0x79, 0xd7, 0x08,
	0xfb, 0x01, 0xad, 0x40, 0xc6, 0x1c, 0x04, 0x5d, 0x37, 0xba, 0xe3, 0x85, 0x14, 0x7a, 0x1b, 0x0a,
	0x2c, 0x30, 0xfd, 0x80, 0xc8, 0x47, 0xb1, 0x74, 0x09, 0x04, 0x4b, 0x58, 0xe1, 0x9b, 0x33, 0x30,
	0xfd, 0x0e, 0x8d, 0x10, 0x72, 0x0b, 0x17, 0x24, 0x4f, 0x40, 0xf4, 0x77, 0x21, 0xdd, 0x90, 0x17,
	0x56, 0x95, 0xe7, 0x58, 0xb9, 0xb0, 0x20, 0x5c, 0xac, 0xdf, 0x84, 0x74, 0x95, 0xa3, 0xaf, 0x25,
	0xd1, 0xe7, 0x54, 0x84, 0x4b, 0x6f, 0xfc, 0xa2, 0x42, 0x9a, 0x3f, 0xf0, 0x91, 0x06, 0xc5, 0xda,
	0xd1, 0xbd, 0x7b, 0x04, 0x1b, 0x87, 0x47, 0x46, 0xb3, 0xa5, 0xcd, 0xa1, 0x45, 0x28, 0x34, 0xb0,
	0x41, 0x1a, 0xd8, 0x68, 0x6c, 0x63, 0x43, 0x53, 0x50, 0x01, 0xb2, 0x11, 0x91, 0x42, 0x00, 0x99,
	0x6a, 0xfd, 0xe0, 0x60, 0xbf, 0xa5, 0xa9, 0x1c, 0x19, 0xaa, 0x91, 0xa6, 0xd1, 0xd2, 0xd2, 0x68,
	0x19, 0x4a, 0xcd, 0xfd, 0xdd, 0x9a, 0x71, 0x87, 0x54, 0xf7, 0x8c, 0xea, 0x97, 0x8d, 0xfa, 0x7e,
	0xad, 0xa5, 0xcd, 0xa3, 0x32, 0x68, 0x77, 0x8d, 0x56, 0x75, 0x2f, 0xc9, 0xcd, 0x70, 0xed, 0xfb,
	0xfb, 0xc6, 0x03, 0x52, 0xdd, 0xdb, 0xae, 0xed, 0x1a, 0x5a, 0x16, 0xad, 0x00, 0x3a, 0x3c, 0xaa,
	0xe3, 0xa3, 0x03, 0x92, 0xe4, 0xe7, 0x50, 0x11, 0x72, 0x35, 0xe3, 0x81, 0x60, 0x6a, 0x79, 0xb4,
	0x00, 0x20, 0x8d, 0x09, 0x1a, 0xf8, 0x9a, 0xd8, 0xa8, 0xd6, 0xef, 0x1b, 0xf8, 0x21, 0xc1, 0x46,
	0xb3, 0x51, 0xaf, 0x35, 0x0d, 0xad, 0x80, 0xfe, 0x07, 0x4b, 0x12, 0xb6, 0xb3, 0xcd, 0x7f, 0xa3,
	0xf0, 0x8a, 0xa8, 0x02, 0xe5, 0x51, 0x41, 0xa8, 0x72, 0x89, 0x5b, 0x92, 0x12, 0xbe, 0xcf, 0x22,
	0x85, 0x05, 0xee, 0x56, 0x92, 0x1d, 0xc2, 0x17, 0xd1, 0x65, 0x58, 0x96, 0xfc, 0x83, 0xfd, 0x66,
	0x73, 0xbf, 0xb6, 0x3b, 0x54, 0xd1, 0xd0, 0x2a, 0xac, 0x8c, 0x8b, 0x42, 0xb5, 0x12, 0xf7, 0xbf,
	0xf9, 0xb0, 0x56, 0x25, 0xcd, 0xd6, 0x76, 0xcb, 0xd0, 0x10, 0x77, 0x34, 0xa6, 0x63, 0xe0, 0x12,
	0x77, 0xd4, 0x68, 0xd4, 0x45, 0xd6, 0x78, 0x22, 0x86, 0xe6, 0xcb, 0xdc, 0xa3, 0x11, 0x49, 0x03,
	0xd7, 0xeb, 0x77, 0xb5, 0xe5, 0x9d, 0xca, 0xb3, 0x17, 0x6b, 0xca, 0xf3, 0x17, 0x6b, 0xca, 0x6f,
	0x2f, 0xd6, 0x94, 0xef, 0x5f, 0xae, 0xcd, 0x3d, 0x7f, 0xb9, 0x36, 0xf7, 0xeb, 0xcb, 0xb5, 0xb9,
	0xe3, 0x8c, 0xf8, 0x0b, 0xe8, 0xc3, 0x3f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x2a, 0xb5, 0x16, 0x90,
	0x2d, 0x12, 0x00, 0x00,
}

func (m *ConsensusMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nonce != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintRbft(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x32
	}
	if m.View != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x28
	}
	if m.Epoch != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x20
	}
	if m.To != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.To))
		i--
		dAtA[i] = 0x18
	}
	if m.From != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.From))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NullRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NullRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NullRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PrePrepare) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrePrepare) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrePrepare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HashBatch != nil {
		{
			size, err := m.HashBatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BatchDigest) > 0 {
		i -= len(m.BatchDigest)
		copy(dAtA[i:], m.BatchDigest)
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchDigest)))
		i--
		dAtA[i] = 0x22
	}
	if m.SequenceNumber != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.SequenceNumber))
		i--
		dAtA[i] = 0x18
	}
	if m.View != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x10
	}
	if m.ReplicaId != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Prepare) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Prepare) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Prepare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BatchDigest) > 0 {
		i -= len(m.BatchDigest)
		copy(dAtA[i:], m.BatchDigest)
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchDigest)))
		i--
		dAtA[i] = 0x22
	}
	if m.SequenceNumber != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.SequenceNumber))
		i--
		dAtA[i] = 0x18
	}
	if m.View != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x10
	}
	if m.ReplicaId != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Commit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Commit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Commit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BatchDigest) > 0 {
		i -= len(m.BatchDigest)
		copy(dAtA[i:], m.BatchDigest)
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchDigest)))
		i--
		dAtA[i] = 0x22
	}
	if m.SequenceNumber != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.SequenceNumber))
		i--
		dAtA[i] = 0x18
	}
	if m.View != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x10
	}
	if m.ReplicaId != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RequestSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Local {
		i--
		if m.Local {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Requests) > 0 {
		for iNdEx := len(m.Requests) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Requests[iNdEx])
			copy(dAtA[i:], m.Requests[iNdEx])
			i = encodeVarintRbft(dAtA, i, uint64(len(m.Requests[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *HashBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HashBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HashBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Proposer != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.Proposer))
		i--
		dAtA[i] = 0x20
	}
	if m.Timestamp != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x18
	}
	if len(m.DeDuplicateRequestHashList) > 0 {
		for iNdEx := len(m.DeDuplicateRequestHashList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DeDuplicateRequestHashList[iNdEx])
			copy(dAtA[i:], m.DeDuplicateRequestHashList[iNdEx])
			i = encodeVarintRbft(dAtA, i, uint64(len(m.DeDuplicateRequestHashList[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.RequestHashList) > 0 {
		for iNdEx := len(m.RequestHashList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RequestHashList[iNdEx])
			copy(dAtA[i:], m.RequestHashList[iNdEx])
			i = encodeVarintRbft(dAtA, i, uint64(len(m.RequestHashList[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FetchCheckpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchCheckpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchCheckpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SequenceNumber != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.SequenceNumber))
		i--
		dAtA[i] = 0x10
	}
	if m.ReplicaId != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ViewChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ViewChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Recovery {
		i--
		if m.Recovery {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Timestamp != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintRbft(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Basis) > 0 {
		i -= len(m.Basis)
		copy(dAtA[i:], m.Basis)
		i = encodeVarintRbft(dAtA, i, uint64(len(m.Basis)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VcBasis) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VcBasis) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VcBasis) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cset) > 0 {
		for iNdEx := len(m.Cset) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cset[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRbft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Qset) > 0 {
		for iNdEx := len(m.Qset) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Qset[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRbft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Pset) > 0 {
		for iNdEx := len(m.Pset) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pset[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRbft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.H != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.H))
		i--
		dAtA[i] = 0x18
	}
	if m.View != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x10
	}
	if m.ReplicaId != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Vc_PQ) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vc_PQ) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vc_PQ) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.View != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BatchDigest) > 0 {
		i -= len(m.BatchDigest)
		copy(dAtA[i:], m.BatchDigest)
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchDigest)))
		i--
		dAtA[i] = 0x12
	}
	if m.SequenceNumber != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.SequenceNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QuorumViewChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuorumViewChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuorumViewChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ViewChanges) > 0 {
		for iNdEx := len(m.ViewChanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ViewChanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRbft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ReplicaId != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NewView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NewView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintRbft(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x32
	}
	if m.QuorumCheckpoint != nil {
		{
			size, err := m.QuorumCheckpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ViewChangeSet != nil {
		{
			size, err := m.ViewChangeSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Xset) > 0 {
		for iNdEx := len(m.Xset) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Xset[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRbft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.View != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x10
	}
	if m.ReplicaId != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FetchView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.View != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x10
	}
	if m.ReplicaId != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecoveryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GenesisBlockDigest) > 0 {
		i -= len(m.GenesisBlockDigest)
		copy(dAtA[i:], m.GenesisBlockDigest)
		i = encodeVarintRbft(dAtA, i, uint64(len(m.GenesisBlockDigest)))
		i--
		dAtA[i] = 0x1a
	}
	if m.InitialCheckpoint != nil {
		{
			size, err := m.InitialCheckpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NewView != nil {
		{
			size, err := m.NewView.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FetchBatchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchBatchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchBatchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BatchDigest) > 0 {
		i -= len(m.BatchDigest)
		copy(dAtA[i:], m.BatchDigest)
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchDigest)))
		i--
		dAtA[i] = 0x12
	}
	if m.ReplicaId != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FetchBatchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchBatchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchBatchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BatchDigest) > 0 {
		i -= len(m.BatchDigest)
		copy(dAtA[i:], m.BatchDigest)
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchDigest)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Batch != nil {
		{
			size, err := m.Batch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ReplicaId != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RequestBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Proposer != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.Proposer))
		i--
		dAtA[i] = 0x38
	}
	if len(m.BatchHash) > 0 {
		i -= len(m.BatchHash)
		copy(dAtA[i:], m.BatchHash)
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.LocalList) > 0 {
		for iNdEx := len(m.LocalList) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.LocalList[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintRbft(dAtA, i, uint64(len(m.LocalList)))
		i--
		dAtA[i] = 0x2a
	}
	if m.SeqNo != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.SeqNo))
		i--
		dAtA[i] = 0x20
	}
	if m.Timestamp != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RequestList) > 0 {
		for iNdEx := len(m.RequestList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RequestList[iNdEx])
			copy(dAtA[i:], m.RequestList[iNdEx])
			i = encodeVarintRbft(dAtA, i, uint64(len(m.RequestList[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.RequestHashList) > 0 {
		for iNdEx := len(m.RequestHashList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RequestHashList[iNdEx])
			copy(dAtA[i:], m.RequestHashList[iNdEx])
			i = encodeVarintRbft(dAtA, i, uint64(len(m.RequestHashList[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FetchMissingRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchMissingRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchMissingRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MissingRequestHashes) > 0 {
		for k := range m.MissingRequestHashes {
			v := m.MissingRequestHashes[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintRbft(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintRbft(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintRbft(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.BatchDigest) > 0 {
		i -= len(m.BatchDigest)
		copy(dAtA[i:], m.BatchDigest)
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchDigest)))
		i--
		dAtA[i] = 0x22
	}
	if m.SequenceNumber != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.SequenceNumber))
		i--
		dAtA[i] = 0x18
	}
	if m.View != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x10
	}
	if m.ReplicaId != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FetchMissingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchMissingResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchMissingResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MissingRequests) > 0 {
		for k := range m.MissingRequests {
			v := m.MissingRequests[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintRbft(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintRbft(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintRbft(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.MissingRequestHashes) > 0 {
		for k := range m.MissingRequestHashes {
			v := m.MissingRequestHashes[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintRbft(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintRbft(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintRbft(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.BatchDigest) > 0 {
		i -= len(m.BatchDigest)
		copy(dAtA[i:], m.BatchDigest)
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchDigest)))
		i--
		dAtA[i] = 0x22
	}
	if m.SequenceNumber != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.SequenceNumber))
		i--
		dAtA[i] = 0x18
	}
	if m.View != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x10
	}
	if m.ReplicaId != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FetchPQCRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchPQCRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchPQCRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.H != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.H))
		i--
		dAtA[i] = 0x10
	}
	if m.ReplicaId != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FetchPQCResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchPQCResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchPQCResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CmtSet) > 0 {
		for iNdEx := len(m.CmtSet) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CmtSet[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRbft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PreSet) > 0 {
		for iNdEx := len(m.PreSet) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PreSet[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRbft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.PrepreSet) > 0 {
		for iNdEx := len(m.PrepreSet) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PrepreSet[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRbft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ReplicaId != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncStateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncStateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncStateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SignedCheckpoint != nil {
		{
			size, err := m.SignedCheckpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.View != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x10
	}
	if m.ReplicaId != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EpochChangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpochChangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EpochChangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TargetEpoch != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.TargetEpoch))
		i--
		dAtA[i] = 0x18
	}
	if m.StartEpoch != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.StartEpoch))
		i--
		dAtA[i] = 0x10
	}
	if m.Author != 0 {
		i = encodeVarintRbft(dAtA, i, uint64(m.Author))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Pset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Set) > 0 {
		for iNdEx := len(m.Set) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Set[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRbft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Cset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Set) > 0 {
		for iNdEx := len(m.Set) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Set[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRbft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintRbft(dAtA []byte, offset int, v uint64) int {
	offset -= sovRbft(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ConsensusMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovRbft(uint64(m.Type))
	}
	if m.From != 0 {
		n += 1 + sovRbft(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovRbft(uint64(m.To))
	}
	if m.Epoch != 0 {
		n += 1 + sovRbft(uint64(m.Epoch))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.Nonce != 0 {
		n += 1 + sovRbft(uint64(m.Nonce))
	}
	return n
}

func (m *NullRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	return n
}

func (m *PrePrepare) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovRbft(uint64(m.SequenceNumber))
	}
	l = len(m.BatchDigest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.HashBatch != nil {
		l = m.HashBatch.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *Prepare) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovRbft(uint64(m.SequenceNumber))
	}
	l = len(m.BatchDigest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *Commit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovRbft(uint64(m.SequenceNumber))
	}
	l = len(m.BatchDigest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *RequestSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, b := range m.Requests {
			l = len(b)
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if m.Local {
		n += 2
	}
	return n
}

func (m *HashBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RequestHashList) > 0 {
		for _, s := range m.RequestHashList {
			l = len(s)
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if len(m.DeDuplicateRequestHashList) > 0 {
		for _, s := range m.DeDuplicateRequestHashList {
			l = len(s)
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if m.Timestamp != 0 {
		n += 1 + sovRbft(uint64(m.Timestamp))
	}
	if m.Proposer != 0 {
		n += 1 + sovRbft(uint64(m.Proposer))
	}
	return n
}

func (m *FetchCheckpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovRbft(uint64(m.SequenceNumber))
	}
	return n
}

func (m *ViewChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Basis)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovRbft(uint64(m.Timestamp))
	}
	if m.Recovery {
		n += 2
	}
	return n
}

func (m *VcBasis) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	if m.H != 0 {
		n += 1 + sovRbft(uint64(m.H))
	}
	if len(m.Pset) > 0 {
		for _, e := range m.Pset {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if len(m.Qset) > 0 {
		for _, e := range m.Qset {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if len(m.Cset) > 0 {
		for _, e := range m.Cset {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	return n
}

func (m *Vc_PQ) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SequenceNumber != 0 {
		n += 1 + sovRbft(uint64(m.SequenceNumber))
	}
	l = len(m.BatchDigest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	return n
}

func (m *QuorumViewChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if len(m.ViewChanges) > 0 {
		for _, e := range m.ViewChanges {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	return n
}

func (m *NewView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	if len(m.Xset) > 0 {
		for _, e := range m.Xset {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if m.ViewChangeSet != nil {
		l = m.ViewChangeSet.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.QuorumCheckpoint != nil {
		l = m.QuorumCheckpoint.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *FetchView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	return n
}

func (m *RecoveryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewView != nil {
		l = m.NewView.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.InitialCheckpoint != nil {
		l = m.InitialCheckpoint.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	l = len(m.GenesisBlockDigest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *FetchBatchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	l = len(m.BatchDigest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *FetchBatchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.Batch != nil {
		l = m.Batch.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	l = len(m.BatchDigest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *RequestBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RequestHashList) > 0 {
		for _, s := range m.RequestHashList {
			l = len(s)
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if len(m.RequestList) > 0 {
		for _, b := range m.RequestList {
			l = len(b)
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if m.Timestamp != 0 {
		n += 1 + sovRbft(uint64(m.Timestamp))
	}
	if m.SeqNo != 0 {
		n += 1 + sovRbft(uint64(m.SeqNo))
	}
	if len(m.LocalList) > 0 {
		n += 1 + sovRbft(uint64(len(m.LocalList))) + len(m.LocalList)*1
	}
	l = len(m.BatchHash)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.Proposer != 0 {
		n += 1 + sovRbft(uint64(m.Proposer))
	}
	return n
}

func (m *FetchMissingRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovRbft(uint64(m.SequenceNumber))
	}
	l = len(m.BatchDigest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	if len(m.MissingRequestHashes) > 0 {
		for k, v := range m.MissingRequestHashes {
			_ = k
			_ = v
			mapEntrySize := 1 + sovRbft(uint64(k)) + 1 + len(v) + sovRbft(uint64(len(v)))
			n += mapEntrySize + 1 + sovRbft(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FetchMissingResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovRbft(uint64(m.SequenceNumber))
	}
	l = len(m.BatchDigest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	if len(m.MissingRequestHashes) > 0 {
		for k, v := range m.MissingRequestHashes {
			_ = k
			_ = v
			mapEntrySize := 1 + sovRbft(uint64(k)) + 1 + len(v) + sovRbft(uint64(len(v)))
			n += mapEntrySize + 1 + sovRbft(uint64(mapEntrySize))
		}
	}
	if len(m.MissingRequests) > 0 {
		for k, v := range m.MissingRequests {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovRbft(uint64(len(v)))
			}
			mapEntrySize := 1 + sovRbft(uint64(k)) + l
			n += mapEntrySize + 1 + sovRbft(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FetchPQCRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.H != 0 {
		n += 1 + sovRbft(uint64(m.H))
	}
	return n
}

func (m *FetchPQCResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if len(m.PrepreSet) > 0 {
		for _, e := range m.PrepreSet {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if len(m.PreSet) > 0 {
		for _, e := range m.PreSet {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if len(m.CmtSet) > 0 {
		for _, e := range m.CmtSet {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	return n
}

func (m *SyncState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	return n
}

func (m *SyncStateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	if m.SignedCheckpoint != nil {
		l = m.SignedCheckpoint.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *EpochChangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Author != 0 {
		n += 1 + sovRbft(uint64(m.Author))
	}
	if m.StartEpoch != 0 {
		n += 1 + sovRbft(uint64(m.StartEpoch))
	}
	if m.TargetEpoch != 0 {
		n += 1 + sovRbft(uint64(m.TargetEpoch))
	}
	return n
}

func (m *Pset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Set) > 0 {
		for _, e := range m.Set {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	return n
}

func (m *Cset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Set) > 0 {
		for _, e := range m.Set {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	return n
}

func sovRbft(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRbft(x uint64) (n int) {
	return sovRbft(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ConsensusMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: consensus_message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: consensus_message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NullRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: null_request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: null_request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrePrepare) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: pre_prepare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: pre_prepare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashBatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HashBatch == nil {
				m.HashBatch = &HashBatch{}
			}
			if err := m.HashBatch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Prepare) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: prepare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: prepare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Commit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: commit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: commit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: request_set: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: request_set: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, make([]byte, postIndex-iNdEx))
			copy(m.Requests[len(m.Requests)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Local", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Local = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HashBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: hash_batch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: hash_batch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHashList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHashList = append(m.RequestHashList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeDuplicateRequestHashList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeDuplicateRequestHashList = append(m.DeDuplicateRequestHashList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			m.Proposer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proposer |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchCheckpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: fetch_checkpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: fetch_checkpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: view_change: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: view_change: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Basis", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Basis = append(m.Basis[:0], dAtA[iNdEx:postIndex]...)
			if m.Basis == nil {
				m.Basis = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recovery", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Recovery = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VcBasis) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: vc_basis: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: vc_basis: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field H", wireType)
			}
			m.H = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.H |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pset = append(m.Pset, &Vc_PQ{})
			if err := m.Pset[len(m.Pset)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Qset = append(m.Qset, &Vc_PQ{})
			if err := m.Qset[len(m.Qset)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cset = append(m.Cset, &SignedCheckpoint{})
			if err := m.Cset[len(m.Cset)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vc_PQ) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: vc_PQ: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: vc_PQ: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuorumViewChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: quorum_view_change: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: quorum_view_change: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewChanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ViewChanges = append(m.ViewChanges, &ViewChange{})
			if err := m.ViewChanges[len(m.ViewChanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: new_view: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: new_view: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Xset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Xset = append(m.Xset, &Vc_PQ{})
			if err := m.Xset[len(m.Xset)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewChangeSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ViewChangeSet == nil {
				m.ViewChangeSet = &QuorumViewChange{}
			}
			if err := m.ViewChangeSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuorumCheckpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QuorumCheckpoint == nil {
				m.QuorumCheckpoint = &QuorumCheckpoint{}
			}
			if err := m.QuorumCheckpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: fetch_view: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: fetch_view: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: recovery_response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: recovery_response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewView", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewView == nil {
				m.NewView = &NewView{}
			}
			if err := m.NewView.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialCheckpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitialCheckpoint == nil {
				m.InitialCheckpoint = &SignedCheckpoint{}
			}
			if err := m.InitialCheckpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisBlockDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GenesisBlockDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchBatchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: fetch_batch_request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: fetch_batch_request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchBatchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: fetch_batch_response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: fetch_batch_response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Batch == nil {
				m.Batch = &RequestBatch{}
			}
			if err := m.Batch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: request_batch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: request_batch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHashList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHashList = append(m.RequestHashList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestList", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestList = append(m.RequestList, make([]byte, postIndex-iNdEx))
			copy(m.RequestList[len(m.RequestList)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNo", wireType)
			}
			m.SeqNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LocalList = append(m.LocalList, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRbft
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRbft
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.LocalList) == 0 {
					m.LocalList = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LocalList = append(m.LocalList, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalList", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			m.Proposer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Proposer |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchMissingRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: fetch_missing_request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: fetch_missing_request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissingRequestHashes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MissingRequestHashes == nil {
				m.MissingRequestHashes = make(map[uint64]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthRbft
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthRbft
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRbft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthRbft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MissingRequestHashes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchMissingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: fetch_missing_response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: fetch_missing_response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissingRequestHashes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MissingRequestHashes == nil {
				m.MissingRequestHashes = make(map[uint64]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthRbft
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthRbft
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRbft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthRbft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MissingRequestHashes[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissingRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MissingRequests == nil {
				m.MissingRequests = make(map[uint64][]byte)
			}
			var mapkey uint64
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthRbft
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthRbft
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRbft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthRbft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MissingRequests[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchPQCRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: fetchPQC_request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: fetchPQC_request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field H", wireType)
			}
			m.H = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.H |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchPQCResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: fetchPQC_response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: fetchPQC_response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepreSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrepreSet = append(m.PrepreSet, &PrePrepare{})
			if err := m.PrepreSet[len(m.PrepreSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreSet = append(m.PreSet, &Prepare{})
			if err := m.PreSet[len(m.PreSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmtSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CmtSet = append(m.CmtSet, &Commit{})
			if err := m.CmtSet[len(m.CmtSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sync_state: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sync_state: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncStateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sync_state_response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sync_state_response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedCheckpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignedCheckpoint == nil {
				m.SignedCheckpoint = &SignedCheckpoint{}
			}
			if err := m.SignedCheckpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpochChangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpochChangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpochChangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			m.Author = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Author |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartEpoch", wireType)
			}
			m.StartEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetEpoch", wireType)
			}
			m.TargetEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Set = append(m.Set, &Prepare{})
			if err := m.Set[len(m.Set)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Set = append(m.Set, &Commit{})
			if err := m.Set[len(m.Set)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRbft(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRbft
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRbft
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRbft
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRbft        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRbft          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRbft = fmt.Errorf("proto: unexpected end of group")
)
