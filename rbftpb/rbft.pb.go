// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rbft.proto

package rbftpb

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	protos "github.com/ultramesh/flato-common/types/protos"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Type int32

const (
	Type_NULL_REQUEST           Type = 0
	Type_PRE_PREPARE            Type = 1
	Type_PREPARE                Type = 2
	Type_COMMIT                 Type = 3
	Type_SIGNED_CHECKPOINT      Type = 4
	Type_FETCH_CHECKPOINT       Type = 5
	Type_VIEW_CHANGE            Type = 6
	Type_NEW_VIEW               Type = 7
	Type_FETCH_REQUEST_BATCH    Type = 8
	Type_SEND_REQUEST_BATCH     Type = 9
	Type_RECOVERY_FETCH_QPC     Type = 10
	Type_RECOVERY_RETURN_QPC    Type = 11
	Type_FETCH_MISSING_REQUESTS Type = 12
	Type_SEND_MISSING_REQUESTS  Type = 13
	Type_SYNC_STATE             Type = 14
	Type_SYNC_STATE_RESPONSE    Type = 15
	Type_NOTIFICATION           Type = 16
	Type_NOTIFICATION_RESPONSE  Type = 17
	Type_REQUEST_SET            Type = 18
)

var Type_name = map[int32]string{
	0:  "NULL_REQUEST",
	1:  "PRE_PREPARE",
	2:  "PREPARE",
	3:  "COMMIT",
	4:  "SIGNED_CHECKPOINT",
	5:  "FETCH_CHECKPOINT",
	6:  "VIEW_CHANGE",
	7:  "NEW_VIEW",
	8:  "FETCH_REQUEST_BATCH",
	9:  "SEND_REQUEST_BATCH",
	10: "RECOVERY_FETCH_QPC",
	11: "RECOVERY_RETURN_QPC",
	12: "FETCH_MISSING_REQUESTS",
	13: "SEND_MISSING_REQUESTS",
	14: "SYNC_STATE",
	15: "SYNC_STATE_RESPONSE",
	16: "NOTIFICATION",
	17: "NOTIFICATION_RESPONSE",
	18: "REQUEST_SET",
}

var Type_value = map[string]int32{
	"NULL_REQUEST":           0,
	"PRE_PREPARE":            1,
	"PREPARE":                2,
	"COMMIT":                 3,
	"SIGNED_CHECKPOINT":      4,
	"FETCH_CHECKPOINT":       5,
	"VIEW_CHANGE":            6,
	"NEW_VIEW":               7,
	"FETCH_REQUEST_BATCH":    8,
	"SEND_REQUEST_BATCH":     9,
	"RECOVERY_FETCH_QPC":     10,
	"RECOVERY_RETURN_QPC":    11,
	"FETCH_MISSING_REQUESTS": 12,
	"SEND_MISSING_REQUESTS":  13,
	"SYNC_STATE":             14,
	"SYNC_STATE_RESPONSE":    15,
	"NOTIFICATION":           16,
	"NOTIFICATION_RESPONSE":  17,
	"REQUEST_SET":            18,
}

func (x Type) String() string {
	return proto.EnumName(Type_name, int32(x))
}

func (Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{0}
}

type ConsensusMessage struct {
	Type    Type   `protobuf:"varint,1,opt,name=type,proto3,enum=rbftpb.Type" json:"type,omitempty"`
	From    uint64 `protobuf:"varint,2,opt,name=from,proto3" json:"from,omitempty"`
	To      uint64 `protobuf:"varint,3,opt,name=to,proto3" json:"to,omitempty"`
	Epoch   uint64 `protobuf:"varint,4,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Payload []byte `protobuf:"bytes,5,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *ConsensusMessage) Reset()         { *m = ConsensusMessage{} }
func (m *ConsensusMessage) String() string { return proto.CompactTextString(m) }
func (*ConsensusMessage) ProtoMessage()    {}
func (*ConsensusMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{0}
}
func (m *ConsensusMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusMessage.Merge(m, src)
}
func (m *ConsensusMessage) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusMessage proto.InternalMessageInfo

func (m *ConsensusMessage) GetType() Type {
	if m != nil {
		return m.Type
	}
	return Type_NULL_REQUEST
}

func (m *ConsensusMessage) GetFrom() uint64 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *ConsensusMessage) GetTo() uint64 {
	if m != nil {
		return m.To
	}
	return 0
}

func (m *ConsensusMessage) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *ConsensusMessage) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type RequestBatch struct {
	RequestHashList []string              `protobuf:"bytes,1,rep,name=request_hash_list,json=requestHashList,proto3" json:"request_hash_list,omitempty"`
	RequestList     []*protos.Transaction `protobuf:"bytes,2,rep,name=request_list,json=requestList,proto3" json:"request_list,omitempty"`
	Timestamp       int64                 `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	SeqNo           uint64                `protobuf:"varint,4,opt,name=seq_no,json=seqNo,proto3" json:"seq_no,omitempty"`
	LocalList       []bool                `protobuf:"varint,5,rep,packed,name=local_list,json=localList,proto3" json:"local_list,omitempty"`
	BatchHash       string                `protobuf:"bytes,6,opt,name=batch_hash,json=batchHash,proto3" json:"batch_hash,omitempty"`
}

func (m *RequestBatch) Reset()         { *m = RequestBatch{} }
func (m *RequestBatch) String() string { return proto.CompactTextString(m) }
func (*RequestBatch) ProtoMessage()    {}
func (*RequestBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{1}
}
func (m *RequestBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestBatch.Merge(m, src)
}
func (m *RequestBatch) XXX_Size() int {
	return m.Size()
}
func (m *RequestBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestBatch.DiscardUnknown(m)
}

var xxx_messageInfo_RequestBatch proto.InternalMessageInfo

func (m *RequestBatch) GetRequestHashList() []string {
	if m != nil {
		return m.RequestHashList
	}
	return nil
}

func (m *RequestBatch) GetRequestList() []*protos.Transaction {
	if m != nil {
		return m.RequestList
	}
	return nil
}

func (m *RequestBatch) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *RequestBatch) GetSeqNo() uint64 {
	if m != nil {
		return m.SeqNo
	}
	return 0
}

func (m *RequestBatch) GetLocalList() []bool {
	if m != nil {
		return m.LocalList
	}
	return nil
}

func (m *RequestBatch) GetBatchHash() string {
	if m != nil {
		return m.BatchHash
	}
	return ""
}

type HashBatch struct {
	RequestHashList            []string `protobuf:"bytes,1,rep,name=request_hash_list,json=requestHashList,proto3" json:"request_hash_list,omitempty"`
	DeDuplicateRequestHashList []string `protobuf:"bytes,2,rep,name=de_duplicate_request_hash_list,json=deDuplicateRequestHashList,proto3" json:"de_duplicate_request_hash_list,omitempty"`
	Timestamp                  int64    `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *HashBatch) Reset()         { *m = HashBatch{} }
func (m *HashBatch) String() string { return proto.CompactTextString(m) }
func (*HashBatch) ProtoMessage()    {}
func (*HashBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{2}
}
func (m *HashBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HashBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HashBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HashBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HashBatch.Merge(m, src)
}
func (m *HashBatch) XXX_Size() int {
	return m.Size()
}
func (m *HashBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_HashBatch.DiscardUnknown(m)
}

var xxx_messageInfo_HashBatch proto.InternalMessageInfo

func (m *HashBatch) GetRequestHashList() []string {
	if m != nil {
		return m.RequestHashList
	}
	return nil
}

func (m *HashBatch) GetDeDuplicateRequestHashList() []string {
	if m != nil {
		return m.DeDuplicateRequestHashList
	}
	return nil
}

func (m *HashBatch) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

type SendRequestBatch struct {
	ReplicaId   uint64        `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	Batch       *RequestBatch `protobuf:"bytes,2,opt,name=batch,proto3" json:"batch,omitempty"`
	BatchDigest string        `protobuf:"bytes,3,opt,name=batch_digest,json=batchDigest,proto3" json:"batch_digest,omitempty"`
}

func (m *SendRequestBatch) Reset()         { *m = SendRequestBatch{} }
func (m *SendRequestBatch) String() string { return proto.CompactTextString(m) }
func (*SendRequestBatch) ProtoMessage()    {}
func (*SendRequestBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{3}
}
func (m *SendRequestBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendRequestBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendRequestBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendRequestBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendRequestBatch.Merge(m, src)
}
func (m *SendRequestBatch) XXX_Size() int {
	return m.Size()
}
func (m *SendRequestBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_SendRequestBatch.DiscardUnknown(m)
}

var xxx_messageInfo_SendRequestBatch proto.InternalMessageInfo

func (m *SendRequestBatch) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *SendRequestBatch) GetBatch() *RequestBatch {
	if m != nil {
		return m.Batch
	}
	return nil
}

func (m *SendRequestBatch) GetBatchDigest() string {
	if m != nil {
		return m.BatchDigest
	}
	return ""
}

type FetchMissingRequests struct {
	ReplicaId            uint64            `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	View                 uint64            `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
	SequenceNumber       uint64            `protobuf:"varint,3,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	BatchDigest          string            `protobuf:"bytes,4,opt,name=batch_digest,json=batchDigest,proto3" json:"batch_digest,omitempty"`
	MissingRequestHashes map[uint64]string `protobuf:"bytes,5,rep,name=missing_request_hashes,json=missingRequestHashes,proto3" json:"missing_request_hashes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *FetchMissingRequests) Reset()         { *m = FetchMissingRequests{} }
func (m *FetchMissingRequests) String() string { return proto.CompactTextString(m) }
func (*FetchMissingRequests) ProtoMessage()    {}
func (*FetchMissingRequests) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{4}
}
func (m *FetchMissingRequests) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchMissingRequests) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchMissingRequests.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchMissingRequests) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchMissingRequests.Merge(m, src)
}
func (m *FetchMissingRequests) XXX_Size() int {
	return m.Size()
}
func (m *FetchMissingRequests) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchMissingRequests.DiscardUnknown(m)
}

var xxx_messageInfo_FetchMissingRequests proto.InternalMessageInfo

func (m *FetchMissingRequests) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *FetchMissingRequests) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *FetchMissingRequests) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *FetchMissingRequests) GetBatchDigest() string {
	if m != nil {
		return m.BatchDigest
	}
	return ""
}

func (m *FetchMissingRequests) GetMissingRequestHashes() map[uint64]string {
	if m != nil {
		return m.MissingRequestHashes
	}
	return nil
}

type SendMissingRequests struct {
	ReplicaId            uint64                         `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	View                 uint64                         `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
	SequenceNumber       uint64                         `protobuf:"varint,3,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	BatchDigest          string                         `protobuf:"bytes,4,opt,name=batch_digest,json=batchDigest,proto3" json:"batch_digest,omitempty"`
	MissingRequestHashes map[uint64]string              `protobuf:"bytes,5,rep,name=missing_request_hashes,json=missingRequestHashes,proto3" json:"missing_request_hashes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	MissingRequests      map[uint64]*protos.Transaction `protobuf:"bytes,6,rep,name=missing_requests,json=missingRequests,proto3" json:"missing_requests,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SendMissingRequests) Reset()         { *m = SendMissingRequests{} }
func (m *SendMissingRequests) String() string { return proto.CompactTextString(m) }
func (*SendMissingRequests) ProtoMessage()    {}
func (*SendMissingRequests) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{5}
}
func (m *SendMissingRequests) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendMissingRequests) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendMissingRequests.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendMissingRequests) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendMissingRequests.Merge(m, src)
}
func (m *SendMissingRequests) XXX_Size() int {
	return m.Size()
}
func (m *SendMissingRequests) XXX_DiscardUnknown() {
	xxx_messageInfo_SendMissingRequests.DiscardUnknown(m)
}

var xxx_messageInfo_SendMissingRequests proto.InternalMessageInfo

func (m *SendMissingRequests) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *SendMissingRequests) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *SendMissingRequests) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *SendMissingRequests) GetBatchDigest() string {
	if m != nil {
		return m.BatchDigest
	}
	return ""
}

func (m *SendMissingRequests) GetMissingRequestHashes() map[uint64]string {
	if m != nil {
		return m.MissingRequestHashes
	}
	return nil
}

func (m *SendMissingRequests) GetMissingRequests() map[uint64]*protos.Transaction {
	if m != nil {
		return m.MissingRequests
	}
	return nil
}

type RequestSet struct {
	Requests []*protos.Transaction `protobuf:"bytes,1,rep,name=requests,proto3" json:"requests,omitempty"`
	Local    bool                  `protobuf:"varint,2,opt,name=local,proto3" json:"local,omitempty"`
}

func (m *RequestSet) Reset()         { *m = RequestSet{} }
func (m *RequestSet) String() string { return proto.CompactTextString(m) }
func (*RequestSet) ProtoMessage()    {}
func (*RequestSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{6}
}
func (m *RequestSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestSet.Merge(m, src)
}
func (m *RequestSet) XXX_Size() int {
	return m.Size()
}
func (m *RequestSet) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestSet.DiscardUnknown(m)
}

var xxx_messageInfo_RequestSet proto.InternalMessageInfo

func (m *RequestSet) GetRequests() []*protos.Transaction {
	if m != nil {
		return m.Requests
	}
	return nil
}

func (m *RequestSet) GetLocal() bool {
	if m != nil {
		return m.Local
	}
	return false
}

type NullRequest struct {
	ReplicaId uint64 `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
}

func (m *NullRequest) Reset()         { *m = NullRequest{} }
func (m *NullRequest) String() string { return proto.CompactTextString(m) }
func (*NullRequest) ProtoMessage()    {}
func (*NullRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{7}
}
func (m *NullRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NullRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NullRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NullRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NullRequest.Merge(m, src)
}
func (m *NullRequest) XXX_Size() int {
	return m.Size()
}
func (m *NullRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NullRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NullRequest proto.InternalMessageInfo

func (m *NullRequest) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

type PrePrepare struct {
	ReplicaId      uint64     `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	View           uint64     `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
	SequenceNumber uint64     `protobuf:"varint,3,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	BatchDigest    string     `protobuf:"bytes,4,opt,name=batch_digest,json=batchDigest,proto3" json:"batch_digest,omitempty"`
	HashBatch      *HashBatch `protobuf:"bytes,5,opt,name=hash_batch,json=hashBatch,proto3" json:"hash_batch,omitempty"`
}

func (m *PrePrepare) Reset()         { *m = PrePrepare{} }
func (m *PrePrepare) String() string { return proto.CompactTextString(m) }
func (*PrePrepare) ProtoMessage()    {}
func (*PrePrepare) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{8}
}
func (m *PrePrepare) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrePrepare) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrePrepare.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrePrepare) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrePrepare.Merge(m, src)
}
func (m *PrePrepare) XXX_Size() int {
	return m.Size()
}
func (m *PrePrepare) XXX_DiscardUnknown() {
	xxx_messageInfo_PrePrepare.DiscardUnknown(m)
}

var xxx_messageInfo_PrePrepare proto.InternalMessageInfo

func (m *PrePrepare) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *PrePrepare) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *PrePrepare) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *PrePrepare) GetBatchDigest() string {
	if m != nil {
		return m.BatchDigest
	}
	return ""
}

func (m *PrePrepare) GetHashBatch() *HashBatch {
	if m != nil {
		return m.HashBatch
	}
	return nil
}

type Prepare struct {
	ReplicaId      uint64 `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	View           uint64 `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
	SequenceNumber uint64 `protobuf:"varint,3,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	BatchDigest    string `protobuf:"bytes,4,opt,name=batch_digest,json=batchDigest,proto3" json:"batch_digest,omitempty"`
}

func (m *Prepare) Reset()         { *m = Prepare{} }
func (m *Prepare) String() string { return proto.CompactTextString(m) }
func (*Prepare) ProtoMessage()    {}
func (*Prepare) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{9}
}
func (m *Prepare) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Prepare) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Prepare.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Prepare) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Prepare.Merge(m, src)
}
func (m *Prepare) XXX_Size() int {
	return m.Size()
}
func (m *Prepare) XXX_DiscardUnknown() {
	xxx_messageInfo_Prepare.DiscardUnknown(m)
}

var xxx_messageInfo_Prepare proto.InternalMessageInfo

func (m *Prepare) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *Prepare) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *Prepare) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *Prepare) GetBatchDigest() string {
	if m != nil {
		return m.BatchDigest
	}
	return ""
}

type Commit struct {
	ReplicaId      uint64 `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	View           uint64 `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
	SequenceNumber uint64 `protobuf:"varint,3,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	BatchDigest    string `protobuf:"bytes,4,opt,name=batch_digest,json=batchDigest,proto3" json:"batch_digest,omitempty"`
}

func (m *Commit) Reset()         { *m = Commit{} }
func (m *Commit) String() string { return proto.CompactTextString(m) }
func (*Commit) ProtoMessage()    {}
func (*Commit) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{10}
}
func (m *Commit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Commit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Commit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Commit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Commit.Merge(m, src)
}
func (m *Commit) XXX_Size() int {
	return m.Size()
}
func (m *Commit) XXX_DiscardUnknown() {
	xxx_messageInfo_Commit.DiscardUnknown(m)
}

var xxx_messageInfo_Commit proto.InternalMessageInfo

func (m *Commit) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *Commit) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *Commit) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *Commit) GetBatchDigest() string {
	if m != nil {
		return m.BatchDigest
	}
	return ""
}

type SignedCheckpoint struct {
	NodeInfo   *NodeInfo          `protobuf:"bytes,1,opt,name=node_info,json=nodeInfo,proto3" json:"node_info,omitempty"`
	Checkpoint *protos.Checkpoint `protobuf:"bytes,2,opt,name=checkpoint,proto3" json:"checkpoint,omitempty"`
	Signature  []byte             `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *SignedCheckpoint) Reset()         { *m = SignedCheckpoint{} }
func (m *SignedCheckpoint) String() string { return proto.CompactTextString(m) }
func (*SignedCheckpoint) ProtoMessage()    {}
func (*SignedCheckpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{11}
}
func (m *SignedCheckpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignedCheckpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignedCheckpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignedCheckpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedCheckpoint.Merge(m, src)
}
func (m *SignedCheckpoint) XXX_Size() int {
	return m.Size()
}
func (m *SignedCheckpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedCheckpoint.DiscardUnknown(m)
}

var xxx_messageInfo_SignedCheckpoint proto.InternalMessageInfo

func (m *SignedCheckpoint) GetNodeInfo() *NodeInfo {
	if m != nil {
		return m.NodeInfo
	}
	return nil
}

func (m *SignedCheckpoint) GetCheckpoint() *protos.Checkpoint {
	if m != nil {
		return m.Checkpoint
	}
	return nil
}

func (m *SignedCheckpoint) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type FetchCheckpoint struct {
	ReplicaHash    string `protobuf:"bytes,1,opt,name=replica_hash,json=replicaHash,proto3" json:"replica_hash,omitempty"`
	SequenceNumber uint64 `protobuf:"varint,2,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
}

func (m *FetchCheckpoint) Reset()         { *m = FetchCheckpoint{} }
func (m *FetchCheckpoint) String() string { return proto.CompactTextString(m) }
func (*FetchCheckpoint) ProtoMessage()    {}
func (*FetchCheckpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{12}
}
func (m *FetchCheckpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchCheckpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchCheckpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchCheckpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchCheckpoint.Merge(m, src)
}
func (m *FetchCheckpoint) XXX_Size() int {
	return m.Size()
}
func (m *FetchCheckpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchCheckpoint.DiscardUnknown(m)
}

var xxx_messageInfo_FetchCheckpoint proto.InternalMessageInfo

func (m *FetchCheckpoint) GetReplicaHash() string {
	if m != nil {
		return m.ReplicaHash
	}
	return ""
}

func (m *FetchCheckpoint) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

type Vc_C struct {
	SequenceNumber uint64 `protobuf:"varint,1,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	Digest         string `protobuf:"bytes,2,opt,name=digest,proto3" json:"digest,omitempty"`
}

func (m *Vc_C) Reset()         { *m = Vc_C{} }
func (m *Vc_C) String() string { return proto.CompactTextString(m) }
func (*Vc_C) ProtoMessage()    {}
func (*Vc_C) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{13}
}
func (m *Vc_C) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vc_C) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vc_C.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vc_C) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vc_C.Merge(m, src)
}
func (m *Vc_C) XXX_Size() int {
	return m.Size()
}
func (m *Vc_C) XXX_DiscardUnknown() {
	xxx_messageInfo_Vc_C.DiscardUnknown(m)
}

var xxx_messageInfo_Vc_C proto.InternalMessageInfo

func (m *Vc_C) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *Vc_C) GetDigest() string {
	if m != nil {
		return m.Digest
	}
	return ""
}

type Vc_PQ struct {
	SequenceNumber uint64 `protobuf:"varint,1,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	BatchDigest    string `protobuf:"bytes,2,opt,name=batch_digest,json=batchDigest,proto3" json:"batch_digest,omitempty"`
	View           uint64 `protobuf:"varint,3,opt,name=view,proto3" json:"view,omitempty"`
}

func (m *Vc_PQ) Reset()         { *m = Vc_PQ{} }
func (m *Vc_PQ) String() string { return proto.CompactTextString(m) }
func (*Vc_PQ) ProtoMessage()    {}
func (*Vc_PQ) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{14}
}
func (m *Vc_PQ) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vc_PQ) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vc_PQ.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vc_PQ) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vc_PQ.Merge(m, src)
}
func (m *Vc_PQ) XXX_Size() int {
	return m.Size()
}
func (m *Vc_PQ) XXX_DiscardUnknown() {
	xxx_messageInfo_Vc_PQ.DiscardUnknown(m)
}

var xxx_messageInfo_Vc_PQ proto.InternalMessageInfo

func (m *Vc_PQ) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *Vc_PQ) GetBatchDigest() string {
	if m != nil {
		return m.BatchDigest
	}
	return ""
}

func (m *Vc_PQ) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

type VcBasis struct {
	ReplicaId         uint64              `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	View              uint64              `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
	H                 uint64              `protobuf:"varint,3,opt,name=h,proto3" json:"h,omitempty"`
	Cset              []*Vc_C             `protobuf:"bytes,4,rep,name=cset,proto3" json:"cset,omitempty"`
	Pset              []*Vc_PQ            `protobuf:"bytes,5,rep,name=pset,proto3" json:"pset,omitempty"`
	Qset              []*Vc_PQ            `protobuf:"bytes,6,rep,name=qset,proto3" json:"qset,omitempty"`
	SignedCheckpoints []*SignedCheckpoint `protobuf:"bytes,7,rep,name=signed_checkpoints,json=signedCheckpoints,proto3" json:"signed_checkpoints,omitempty"`
}

func (m *VcBasis) Reset()         { *m = VcBasis{} }
func (m *VcBasis) String() string { return proto.CompactTextString(m) }
func (*VcBasis) ProtoMessage()    {}
func (*VcBasis) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{15}
}
func (m *VcBasis) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VcBasis) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VcBasis.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VcBasis) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VcBasis.Merge(m, src)
}
func (m *VcBasis) XXX_Size() int {
	return m.Size()
}
func (m *VcBasis) XXX_DiscardUnknown() {
	xxx_messageInfo_VcBasis.DiscardUnknown(m)
}

var xxx_messageInfo_VcBasis proto.InternalMessageInfo

func (m *VcBasis) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *VcBasis) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *VcBasis) GetH() uint64 {
	if m != nil {
		return m.H
	}
	return 0
}

func (m *VcBasis) GetCset() []*Vc_C {
	if m != nil {
		return m.Cset
	}
	return nil
}

func (m *VcBasis) GetPset() []*Vc_PQ {
	if m != nil {
		return m.Pset
	}
	return nil
}

func (m *VcBasis) GetQset() []*Vc_PQ {
	if m != nil {
		return m.Qset
	}
	return nil
}

func (m *VcBasis) GetSignedCheckpoints() []*SignedCheckpoint {
	if m != nil {
		return m.SignedCheckpoints
	}
	return nil
}

type ViewChange struct {
	Basis     *VcBasis `protobuf:"bytes,1,opt,name=basis,proto3" json:"basis,omitempty"`
	Signature []byte   `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	Timestamp int64    `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *ViewChange) Reset()         { *m = ViewChange{} }
func (m *ViewChange) String() string { return proto.CompactTextString(m) }
func (*ViewChange) ProtoMessage()    {}
func (*ViewChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{16}
}
func (m *ViewChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViewChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewChange.Merge(m, src)
}
func (m *ViewChange) XXX_Size() int {
	return m.Size()
}
func (m *ViewChange) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewChange.DiscardUnknown(m)
}

var xxx_messageInfo_ViewChange proto.InternalMessageInfo

func (m *ViewChange) GetBasis() *VcBasis {
	if m != nil {
		return m.Basis
	}
	return nil
}

func (m *ViewChange) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *ViewChange) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

type NewView struct {
	ReplicaId uint64            `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	View      uint64            `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
	Xset      map[uint64]string `protobuf:"bytes,3,rep,name=xset,proto3" json:"xset,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Bset      []*VcBasis        `protobuf:"bytes,4,rep,name=bset,proto3" json:"bset,omitempty"`
}

func (m *NewView) Reset()         { *m = NewView{} }
func (m *NewView) String() string { return proto.CompactTextString(m) }
func (*NewView) ProtoMessage()    {}
func (*NewView) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{17}
}
func (m *NewView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewView.Merge(m, src)
}
func (m *NewView) XXX_Size() int {
	return m.Size()
}
func (m *NewView) XXX_DiscardUnknown() {
	xxx_messageInfo_NewView.DiscardUnknown(m)
}

var xxx_messageInfo_NewView proto.InternalMessageInfo

func (m *NewView) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *NewView) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *NewView) GetXset() map[uint64]string {
	if m != nil {
		return m.Xset
	}
	return nil
}

func (m *NewView) GetBset() []*VcBasis {
	if m != nil {
		return m.Bset
	}
	return nil
}

type FetchRequestBatch struct {
	ReplicaId   uint64 `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	BatchDigest string `protobuf:"bytes,2,opt,name=batch_digest,json=batchDigest,proto3" json:"batch_digest,omitempty"`
}

func (m *FetchRequestBatch) Reset()         { *m = FetchRequestBatch{} }
func (m *FetchRequestBatch) String() string { return proto.CompactTextString(m) }
func (*FetchRequestBatch) ProtoMessage()    {}
func (*FetchRequestBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{18}
}
func (m *FetchRequestBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchRequestBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchRequestBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchRequestBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchRequestBatch.Merge(m, src)
}
func (m *FetchRequestBatch) XXX_Size() int {
	return m.Size()
}
func (m *FetchRequestBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchRequestBatch.DiscardUnknown(m)
}

var xxx_messageInfo_FetchRequestBatch proto.InternalMessageInfo

func (m *FetchRequestBatch) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *FetchRequestBatch) GetBatchDigest() string {
	if m != nil {
		return m.BatchDigest
	}
	return ""
}

type RecoveryFetchPQC struct {
	ReplicaId uint64 `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	H         uint64 `protobuf:"varint,2,opt,name=h,proto3" json:"h,omitempty"`
}

func (m *RecoveryFetchPQC) Reset()         { *m = RecoveryFetchPQC{} }
func (m *RecoveryFetchPQC) String() string { return proto.CompactTextString(m) }
func (*RecoveryFetchPQC) ProtoMessage()    {}
func (*RecoveryFetchPQC) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{19}
}
func (m *RecoveryFetchPQC) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryFetchPQC) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecoveryFetchPQC.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecoveryFetchPQC) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryFetchPQC.Merge(m, src)
}
func (m *RecoveryFetchPQC) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryFetchPQC) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryFetchPQC.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryFetchPQC proto.InternalMessageInfo

func (m *RecoveryFetchPQC) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *RecoveryFetchPQC) GetH() uint64 {
	if m != nil {
		return m.H
	}
	return 0
}

type RecoveryReturnPQC struct {
	ReplicaId uint64        `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	PrepreSet []*PrePrepare `protobuf:"bytes,2,rep,name=prepre_set,json=prepreSet,proto3" json:"prepre_set,omitempty"`
	PreSet    []*Prepare    `protobuf:"bytes,3,rep,name=pre_set,json=preSet,proto3" json:"pre_set,omitempty"`
	CmtSet    []*Commit     `protobuf:"bytes,4,rep,name=cmt_set,json=cmtSet,proto3" json:"cmt_set,omitempty"`
}

func (m *RecoveryReturnPQC) Reset()         { *m = RecoveryReturnPQC{} }
func (m *RecoveryReturnPQC) String() string { return proto.CompactTextString(m) }
func (*RecoveryReturnPQC) ProtoMessage()    {}
func (*RecoveryReturnPQC) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{20}
}
func (m *RecoveryReturnPQC) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryReturnPQC) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecoveryReturnPQC.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecoveryReturnPQC) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryReturnPQC.Merge(m, src)
}
func (m *RecoveryReturnPQC) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryReturnPQC) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryReturnPQC.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryReturnPQC proto.InternalMessageInfo

func (m *RecoveryReturnPQC) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *RecoveryReturnPQC) GetPrepreSet() []*PrePrepare {
	if m != nil {
		return m.PrepreSet
	}
	return nil
}

func (m *RecoveryReturnPQC) GetPreSet() []*Prepare {
	if m != nil {
		return m.PreSet
	}
	return nil
}

func (m *RecoveryReturnPQC) GetCmtSet() []*Commit {
	if m != nil {
		return m.CmtSet
	}
	return nil
}

type Pset struct {
	Set []*Prepare `protobuf:"bytes,1,rep,name=set,proto3" json:"set,omitempty"`
}

func (m *Pset) Reset()         { *m = Pset{} }
func (m *Pset) String() string { return proto.CompactTextString(m) }
func (*Pset) ProtoMessage()    {}
func (*Pset) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{21}
}
func (m *Pset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pset.Merge(m, src)
}
func (m *Pset) XXX_Size() int {
	return m.Size()
}
func (m *Pset) XXX_DiscardUnknown() {
	xxx_messageInfo_Pset.DiscardUnknown(m)
}

var xxx_messageInfo_Pset proto.InternalMessageInfo

func (m *Pset) GetSet() []*Prepare {
	if m != nil {
		return m.Set
	}
	return nil
}

type Cset struct {
	Set []*Commit `protobuf:"bytes,1,rep,name=set,proto3" json:"set,omitempty"`
}

func (m *Cset) Reset()         { *m = Cset{} }
func (m *Cset) String() string { return proto.CompactTextString(m) }
func (*Cset) ProtoMessage()    {}
func (*Cset) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{22}
}
func (m *Cset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cset.Merge(m, src)
}
func (m *Cset) XXX_Size() int {
	return m.Size()
}
func (m *Cset) XXX_DiscardUnknown() {
	xxx_messageInfo_Cset.DiscardUnknown(m)
}

var xxx_messageInfo_Cset proto.InternalMessageInfo

func (m *Cset) GetSet() []*Commit {
	if m != nil {
		return m.Set
	}
	return nil
}

type NodeInfo struct {
	ReplicaId   uint64 `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	ReplicaHash string `protobuf:"bytes,2,opt,name=replica_hash,json=replicaHash,proto3" json:"replica_hash,omitempty"`
}

func (m *NodeInfo) Reset()         { *m = NodeInfo{} }
func (m *NodeInfo) String() string { return proto.CompactTextString(m) }
func (*NodeInfo) ProtoMessage()    {}
func (*NodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{23}
}
func (m *NodeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInfo.Merge(m, src)
}
func (m *NodeInfo) XXX_Size() int {
	return m.Size()
}
func (m *NodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInfo proto.InternalMessageInfo

func (m *NodeInfo) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *NodeInfo) GetReplicaHash() string {
	if m != nil {
		return m.ReplicaHash
	}
	return ""
}

type SyncState struct {
	NodeInfo *NodeInfo `protobuf:"bytes,1,opt,name=node_info,json=nodeInfo,proto3" json:"node_info,omitempty"`
	Epoch    uint64    `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
}

func (m *SyncState) Reset()         { *m = SyncState{} }
func (m *SyncState) String() string { return proto.CompactTextString(m) }
func (*SyncState) ProtoMessage()    {}
func (*SyncState) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{24}
}
func (m *SyncState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncState.Merge(m, src)
}
func (m *SyncState) XXX_Size() int {
	return m.Size()
}
func (m *SyncState) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncState.DiscardUnknown(m)
}

var xxx_messageInfo_SyncState proto.InternalMessageInfo

func (m *SyncState) GetNodeInfo() *NodeInfo {
	if m != nil {
		return m.NodeInfo
	}
	return nil
}

func (m *SyncState) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

type SyncStateResponse struct {
	View             uint64            `protobuf:"varint,1,opt,name=view,proto3" json:"view,omitempty"`
	SignedCheckpoint *SignedCheckpoint `protobuf:"bytes,2,opt,name=signed_checkpoint,json=signedCheckpoint,proto3" json:"signed_checkpoint,omitempty"`
}

func (m *SyncStateResponse) Reset()         { *m = SyncStateResponse{} }
func (m *SyncStateResponse) String() string { return proto.CompactTextString(m) }
func (*SyncStateResponse) ProtoMessage()    {}
func (*SyncStateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{25}
}
func (m *SyncStateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncStateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncStateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncStateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncStateResponse.Merge(m, src)
}
func (m *SyncStateResponse) XXX_Size() int {
	return m.Size()
}
func (m *SyncStateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncStateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SyncStateResponse proto.InternalMessageInfo

func (m *SyncStateResponse) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *SyncStateResponse) GetSignedCheckpoint() *SignedCheckpoint {
	if m != nil {
		return m.SignedCheckpoint
	}
	return nil
}

type Notification struct {
	Basis     *VcBasis  `protobuf:"bytes,1,opt,name=basis,proto3" json:"basis,omitempty"`
	Epoch     uint64    `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Signature []byte    `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
	Timestamp int64     `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	NodeInfo  *NodeInfo `protobuf:"bytes,5,opt,name=node_info,json=nodeInfo,proto3" json:"node_info,omitempty"`
}

func (m *Notification) Reset()         { *m = Notification{} }
func (m *Notification) String() string { return proto.CompactTextString(m) }
func (*Notification) ProtoMessage()    {}
func (*Notification) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{26}
}
func (m *Notification) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Notification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Notification.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Notification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Notification.Merge(m, src)
}
func (m *Notification) XXX_Size() int {
	return m.Size()
}
func (m *Notification) XXX_DiscardUnknown() {
	xxx_messageInfo_Notification.DiscardUnknown(m)
}

var xxx_messageInfo_Notification proto.InternalMessageInfo

func (m *Notification) GetBasis() *VcBasis {
	if m != nil {
		return m.Basis
	}
	return nil
}

func (m *Notification) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *Notification) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *Notification) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Notification) GetNodeInfo() *NodeInfo {
	if m != nil {
		return m.NodeInfo
	}
	return nil
}

type NotificationResponse struct {
	Basis    *VcBasis  `protobuf:"bytes,1,opt,name=basis,proto3" json:"basis,omitempty"`
	Epoch    uint64    `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
	NodeInfo *NodeInfo `protobuf:"bytes,3,opt,name=node_info,json=nodeInfo,proto3" json:"node_info,omitempty"`
}

func (m *NotificationResponse) Reset()         { *m = NotificationResponse{} }
func (m *NotificationResponse) String() string { return proto.CompactTextString(m) }
func (*NotificationResponse) ProtoMessage()    {}
func (*NotificationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{27}
}
func (m *NotificationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotificationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NotificationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NotificationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotificationResponse.Merge(m, src)
}
func (m *NotificationResponse) XXX_Size() int {
	return m.Size()
}
func (m *NotificationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NotificationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NotificationResponse proto.InternalMessageInfo

func (m *NotificationResponse) GetBasis() *VcBasis {
	if m != nil {
		return m.Basis
	}
	return nil
}

func (m *NotificationResponse) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *NotificationResponse) GetNodeInfo() *NodeInfo {
	if m != nil {
		return m.NodeInfo
	}
	return nil
}

func init() {
	proto.RegisterEnum("rbftpb.Type", Type_name, Type_value)
	proto.RegisterType((*ConsensusMessage)(nil), "rbftpb.consensus_message")
	proto.RegisterType((*RequestBatch)(nil), "rbftpb.request_batch")
	proto.RegisterType((*HashBatch)(nil), "rbftpb.hash_batch")
	proto.RegisterType((*SendRequestBatch)(nil), "rbftpb.send_request_batch")
	proto.RegisterType((*FetchMissingRequests)(nil), "rbftpb.fetch_missing_requests")
	proto.RegisterMapType((map[uint64]string)(nil), "rbftpb.fetch_missing_requests.MissingRequestHashesEntry")
	proto.RegisterType((*SendMissingRequests)(nil), "rbftpb.send_missing_requests")
	proto.RegisterMapType((map[uint64]string)(nil), "rbftpb.send_missing_requests.MissingRequestHashesEntry")
	proto.RegisterMapType((map[uint64]*protos.Transaction)(nil), "rbftpb.send_missing_requests.MissingRequestsEntry")
	proto.RegisterType((*RequestSet)(nil), "rbftpb.request_set")
	proto.RegisterType((*NullRequest)(nil), "rbftpb.null_request")
	proto.RegisterType((*PrePrepare)(nil), "rbftpb.pre_prepare")
	proto.RegisterType((*Prepare)(nil), "rbftpb.prepare")
	proto.RegisterType((*Commit)(nil), "rbftpb.commit")
	proto.RegisterType((*SignedCheckpoint)(nil), "rbftpb.signed_checkpoint")
	proto.RegisterType((*FetchCheckpoint)(nil), "rbftpb.fetch_checkpoint")
	proto.RegisterType((*Vc_C)(nil), "rbftpb.vc_C")
	proto.RegisterType((*Vc_PQ)(nil), "rbftpb.vc_PQ")
	proto.RegisterType((*VcBasis)(nil), "rbftpb.vc_basis")
	proto.RegisterType((*ViewChange)(nil), "rbftpb.view_change")
	proto.RegisterType((*NewView)(nil), "rbftpb.new_view")
	proto.RegisterMapType((map[uint64]string)(nil), "rbftpb.new_view.XsetEntry")
	proto.RegisterType((*FetchRequestBatch)(nil), "rbftpb.fetch_request_batch")
	proto.RegisterType((*RecoveryFetchPQC)(nil), "rbftpb.recovery_fetchPQC")
	proto.RegisterType((*RecoveryReturnPQC)(nil), "rbftpb.recovery_returnPQC")
	proto.RegisterType((*Pset)(nil), "rbftpb.Pset")
	proto.RegisterType((*Cset)(nil), "rbftpb.Cset")
	proto.RegisterType((*NodeInfo)(nil), "rbftpb.node_info")
	proto.RegisterType((*SyncState)(nil), "rbftpb.sync_state")
	proto.RegisterType((*SyncStateResponse)(nil), "rbftpb.sync_state_response")
	proto.RegisterType((*Notification)(nil), "rbftpb.notification")
	proto.RegisterType((*NotificationResponse)(nil), "rbftpb.notification_response")
}

func init() { proto.RegisterFile("rbft.proto", fileDescriptor_4294ee733f83ad1d) }

var fileDescriptor_4294ee733f83ad1d = []byte{
	// 1563 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0xcd, 0x6f, 0xdb, 0x46,
	0x16, 0xf7, 0x48, 0xb4, 0x2c, 0x3d, 0x29, 0x36, 0x3d, 0xfe, 0x58, 0x45, 0xd8, 0x18, 0x0a, 0xb1,
	0xd8, 0x28, 0x59, 0x44, 0xc6, 0x6a, 0x81, 0x4d, 0xb0, 0x97, 0x8d, 0x2d, 0x33, 0xb6, 0xd0, 0x58,
	0x96, 0x47, 0x4a, 0xdc, 0x1c, 0xda, 0x01, 0x45, 0x8d, 0x2d, 0x22, 0x12, 0x29, 0x73, 0x28, 0xa7,
	0x3a, 0x17, 0xfd, 0xba, 0x14, 0xbd, 0xf4, 0xd2, 0xbf, 0xa4, 0xe8, 0xa5, 0xd7, 0x1e, 0x7a, 0xc8,
	0xb1, 0xc7, 0x22, 0x01, 0xfa, 0x5f, 0x14, 0x28, 0x66, 0x48, 0x4a, 0xd4, 0x47, 0x22, 0x3b, 0x2d,
	0x90, 0xdc, 0x38, 0xef, 0xfd, 0xde, 0x9b, 0xf7, 0x7e, 0xf3, 0xe6, 0xbd, 0x21, 0x80, 0xdb, 0x3c,
	0xf5, 0x8a, 0x3d, 0xd7, 0xf1, 0x1c, 0x9c, 0x10, 0xdf, 0xbd, 0x66, 0xee, 0xc1, 0x99, 0xe5, 0xb5,
	0xfb, 0xcd, 0xa2, 0xe9, 0x74, 0xb7, 0xfb, 0x1d, 0xcf, 0x35, 0xba, 0x8c, 0xb7, 0xb7, 0x4f, 0x3b,
	0x86, 0xe7, 0xdc, 0x35, 0x9d, 0x6e, 0xd7, 0xb1, 0xb7, 0xbd, 0x41, 0x8f, 0xf1, 0x6d, 0x69, 0xc6,
	0xb7, 0x3d, 0xd7, 0xb0, 0xb9, 0x61, 0x7a, 0x96, 0x63, 0xfb, 0x9e, 0x72, 0xff, 0xbf, 0xa2, 0x07,
	0xb3, 0xcd, 0xcc, 0x67, 0x3d, 0xc7, 0xb2, 0x83, 0x50, 0xb4, 0xaf, 0x10, 0xac, 0x9a, 0x8e, 0xcd,
	0x99, 0xcd, 0xfb, 0x9c, 0x76, 0x19, 0xe7, 0xc6, 0x19, 0xc3, 0x79, 0x50, 0x84, 0x59, 0x16, 0xe5,
	0x51, 0x61, 0xb9, 0x94, 0x29, 0xfa, 0xf1, 0x16, 0x1b, 0x83, 0x1e, 0x23, 0x52, 0x83, 0x31, 0x28,
	0xa7, 0xae, 0xd3, 0xcd, 0xc6, 0xf2, 0xa8, 0xa0, 0x10, 0xf9, 0x8d, 0x97, 0x21, 0xe6, 0x39, 0xd9,
	0xb8, 0x94, 0xc4, 0x3c, 0x07, 0xaf, 0xc3, 0x22, 0xeb, 0x39, 0x66, 0x3b, 0xab, 0x48, 0x91, 0xbf,
	0xc0, 0x59, 0x58, 0xea, 0x19, 0x83, 0x8e, 0x63, 0xb4, 0xb2, 0x8b, 0x79, 0x54, 0xc8, 0x90, 0x70,
	0xa9, 0xfd, 0x86, 0xe0, 0x9a, 0xcb, 0xce, 0xfb, 0x8c, 0x7b, 0xb4, 0x69, 0x78, 0x66, 0x1b, 0xdf,
	0x81, 0xd5, 0x50, 0xd0, 0x36, 0x78, 0x9b, 0x76, 0x2c, 0xee, 0x65, 0x51, 0x3e, 0x5e, 0x48, 0x91,
	0x95, 0x40, 0x71, 0x60, 0xf0, 0xf6, 0x23, 0x8b, 0x7b, 0xf8, 0xbf, 0x90, 0x09, 0xb1, 0x12, 0x16,
	0xcb, 0xc7, 0x0b, 0xe9, 0xd2, 0x9a, 0x9f, 0x27, 0x2f, 0x36, 0x46, 0xdc, 0x91, 0x74, 0x00, 0x94,
	0x76, 0x7f, 0x87, 0x94, 0x67, 0x75, 0x19, 0xf7, 0x8c, 0x6e, 0x4f, 0x06, 0x1f, 0x27, 0x23, 0x01,
	0xde, 0x80, 0x04, 0x67, 0xe7, 0xd4, 0x76, 0xc2, 0x24, 0x38, 0x3b, 0xaf, 0x3a, 0xf8, 0x06, 0x40,
	0xc7, 0x31, 0x8d, 0x8e, 0xbf, 0xd5, 0x62, 0x3e, 0x5e, 0x48, 0x92, 0x94, 0x94, 0x48, 0x9f, 0x37,
	0x00, 0x64, 0x02, 0x32, 0xea, 0x6c, 0x22, 0x8f, 0x0a, 0x29, 0x92, 0x92, 0x12, 0x11, 0xae, 0xf6,
	0x1d, 0x02, 0x90, 0xf9, 0x5c, 0x3d, 0xcb, 0x5d, 0xd8, 0x6a, 0x31, 0xda, 0xea, 0xf7, 0x3a, 0x96,
	0x69, 0x78, 0x8c, 0x4e, 0x1b, 0xc6, 0xa4, 0x61, 0xae, 0xc5, 0xf6, 0x42, 0x10, 0x99, 0xf0, 0xf1,
	0xc6, 0x8c, 0xb5, 0x4f, 0x11, 0x60, 0xce, 0xec, 0x16, 0x1d, 0x3f, 0x8a, 0x1b, 0x00, 0x2e, 0x93,
	0x0e, 0xa9, 0xd5, 0x92, 0x85, 0xa1, 0x90, 0x54, 0x20, 0xa9, 0xb4, 0xf0, 0xbf, 0x60, 0x51, 0xe2,
	0x64, 0x41, 0xa4, 0x4b, 0x1b, 0x61, 0xc9, 0x8c, 0x39, 0x21, 0x3e, 0x06, 0xdf, 0x84, 0x8c, 0x4f,
	0x4f, 0xcb, 0x3a, 0x63, 0xdc, 0x93, 0x31, 0xa4, 0x48, 0x5a, 0xca, 0xf6, 0xa4, 0x48, 0x7b, 0x11,
	0x83, 0xcd, 0x53, 0x26, 0x30, 0x5d, 0x8b, 0x73, 0xcb, 0x3e, 0x0b, 0xc3, 0xe1, 0xf3, 0x22, 0xc1,
	0xa0, 0x5c, 0x58, 0xec, 0x79, 0x58, 0x99, 0xe2, 0x1b, 0xdf, 0x82, 0x15, 0x2e, 0xcc, 0x6d, 0x93,
	0x51, 0xbb, 0xdf, 0x6d, 0x32, 0x37, 0x28, 0xd3, 0xe5, 0x50, 0x5c, 0x95, 0xd2, 0xa9, 0xc8, 0x94,
	0xa9, 0xc8, 0xb0, 0x0d, 0x9b, 0x13, 0x21, 0x49, 0xf2, 0x19, 0x97, 0x65, 0x90, 0x2e, 0xdd, 0x0f,
	0x53, 0x9f, 0x1d, 0x7e, 0xf1, 0xd0, 0x17, 0x44, 0x0e, 0x85, 0x71, 0xdd, 0xf6, 0xdc, 0x01, 0x59,
	0xef, 0xce, 0x50, 0xe5, 0xf6, 0xe1, 0xfa, 0x6b, 0x4d, 0xb0, 0x0a, 0xf1, 0x67, 0x6c, 0x10, 0x90,
	0x20, 0x3e, 0xc5, 0xa5, 0xbb, 0x30, 0x3a, 0x7d, 0x26, 0xf3, 0x4f, 0x11, 0x7f, 0xf1, 0xbf, 0xd8,
	0x7d, 0xa4, 0x7d, 0xae, 0xc0, 0x86, 0x3c, 0xd8, 0xf7, 0x8d, 0xd1, 0xee, 0x1c, 0x46, 0xef, 0x85,
	0x8c, 0xce, 0x8c, 0xfe, 0xaa, 0x84, 0xe2, 0x8f, 0x40, 0x9d, 0xf4, 0x91, 0x4d, 0xc8, 0x8d, 0x4a,
	0x57, 0xd9, 0x28, 0xd8, 0x63, 0x65, 0x7c, 0x8f, 0xbf, 0xee, 0xbc, 0x72, 0x27, 0xb0, 0x3e, 0x6b,
	0xc7, 0x19, 0x3e, 0x6e, 0x47, 0x7d, 0xbc, 0xa6, 0xe7, 0x45, 0x0a, 0xa1, 0x01, 0x61, 0x03, 0xa4,
	0x9c, 0x79, 0x78, 0x1b, 0x92, 0x43, 0x1e, 0xd0, 0xeb, 0x9b, 0xe6, 0x10, 0x24, 0x42, 0x96, 0xad,
	0x4e, 0x6e, 0x97, 0x24, 0xfe, 0x42, 0xbb, 0x0b, 0x19, 0xbb, 0xdf, 0xe9, 0x84, 0x74, 0xcd, 0x29,
	0x2a, 0xed, 0x47, 0x04, 0xe9, 0x9e, 0xcb, 0x68, 0xcf, 0x65, 0x3d, 0xc3, 0x65, 0xef, 0xba, 0x06,
	0xff, 0x1d, 0xed, 0xc8, 0x72, 0x30, 0xa5, 0x4b, 0x38, 0x2c, 0x87, 0x91, 0x86, 0xa4, 0xc4, 0xf7,
	0xae, 0xf8, 0xd4, 0xbe, 0x44, 0xb0, 0xf4, 0x7e, 0x44, 0xaf, 0x7d, 0x81, 0x20, 0x21, 0xc6, 0xbd,
	0xe5, 0xbd, 0xeb, 0x48, 0xbe, 0x45, 0xb0, 0xca, 0xad, 0x33, 0x9b, 0xb5, 0xe8, 0xe8, 0xad, 0x81,
	0x8b, 0x90, 0xb2, 0x9d, 0x16, 0xa3, 0x96, 0x7d, 0xea, 0xc8, 0x98, 0xd2, 0xa5, 0xd5, 0x90, 0xdc,
	0xa1, 0x82, 0x24, 0xc5, 0x67, 0xc5, 0x3e, 0x75, 0x70, 0x09, 0x60, 0x64, 0x1d, 0x54, 0x35, 0x0e,
	0x8b, 0xb2, 0x3c, 0xd4, 0x90, 0x08, 0x4a, 0x4c, 0x35, 0xb1, 0xb1, 0xe1, 0xf5, 0x5d, 0x26, 0xe3,
	0xcf, 0x90, 0x91, 0x40, 0xfb, 0x18, 0x54, 0xbf, 0x1f, 0x47, 0x2c, 0x6e, 0x8a, 0x17, 0x83, 0x4f,
	0x95, 0x9c, 0xd3, 0xc8, 0x4f, 0x27, 0x90, 0x89, 0x6b, 0x3b, 0x8b, 0x9a, 0xd8, 0x2c, 0x6a, 0xb4,
	0x7d, 0x50, 0x2e, 0x4c, 0x5a, 0x9e, 0x65, 0x80, 0x66, 0x72, 0xb9, 0x09, 0x89, 0x80, 0x45, 0xff,
	0xe2, 0x07, 0x2b, 0xed, 0x0c, 0x16, 0x2f, 0x4c, 0x5a, 0x3b, 0xbe, 0xbc, 0xa7, 0xc9, 0x53, 0x89,
	0x4d, 0x57, 0x77, 0x78, 0xea, 0xf1, 0xd1, 0xa9, 0x6b, 0xbf, 0x23, 0x48, 0x5e, 0x98, 0xb4, 0x69,
	0x70, 0xeb, 0xad, 0x26, 0x40, 0x06, 0x50, 0x3b, 0x70, 0x88, 0xda, 0xe2, 0xc5, 0x68, 0x72, 0x26,
	0x4a, 0x42, 0x34, 0x90, 0xe1, 0x8b, 0x51, 0x70, 0x42, 0xa4, 0x06, 0xdf, 0x04, 0xa5, 0x27, 0x10,
	0x7e, 0x4f, 0xbf, 0x16, 0x41, 0xd4, 0x8e, 0x89, 0x54, 0x09, 0xc8, 0xb9, 0x80, 0x24, 0x66, 0x42,
	0x84, 0x0a, 0x1f, 0x00, 0x9e, 0x2a, 0x2f, 0x9e, 0x5d, 0x92, 0x06, 0xd7, 0x87, 0xed, 0x7b, 0x12,
	0x41, 0x82, 0x9a, 0x1c, 0x95, 0x0e, 0xd7, 0xce, 0x21, 0x2d, 0xf2, 0xa0, 0x66, 0xdb, 0xb0, 0xcf,
	0x18, 0xfe, 0xa7, 0x78, 0xc0, 0x70, 0x8b, 0x07, 0xe5, 0xa9, 0x46, 0x36, 0x97, 0x72, 0xe2, 0xab,
	0xc7, 0xcb, 0x2c, 0x36, 0x51, 0x66, 0x73, 0x9e, 0x56, 0x3f, 0x23, 0x48, 0xda, 0xec, 0x39, 0x95,
	0xfc, 0xbd, 0x05, 0xe5, 0x45, 0x50, 0x3e, 0x11, 0xfc, 0xc4, 0x65, 0xba, 0xb9, 0xe1, 0x0d, 0x0a,
	0x5c, 0x16, 0x3f, 0xe4, 0xcc, 0xf3, 0xa7, 0x92, 0xc4, 0xe1, 0x7f, 0x80, 0xd2, 0x1c, 0x1d, 0xca,
	0x74, 0x4a, 0x52, 0x9b, 0xbb, 0x07, 0xa9, 0xa1, 0xe1, 0x95, 0x1e, 0x14, 0x27, 0xb0, 0xe6, 0xdf,
	0xa9, 0x2b, 0xbd, 0x14, 0xe7, 0x97, 0xab, 0xf6, 0x40, 0x3c, 0x88, 0x4d, 0xe7, 0x82, 0xb9, 0x03,
	0x2a, 0x77, 0xa8, 0x1d, 0x97, 0xe7, 0xb9, 0x95, 0xe5, 0x18, 0x0b, 0xca, 0x51, 0xfb, 0x01, 0x01,
	0x1e, 0xba, 0x70, 0x99, 0xd7, 0x77, 0xed, 0x4b, 0xf8, 0x28, 0x01, 0x88, 0x86, 0xee, 0x32, 0x31,
	0x17, 0x87, 0x3f, 0x10, 0x01, 0x6b, 0x91, 0x61, 0x45, 0x52, 0x3e, 0xac, 0xce, 0x3c, 0x5c, 0x90,
	0x43, 0x80, 0x8e, 0x8e, 0x65, 0x25, 0x62, 0x20, 0xc1, 0x89, 0x00, 0x79, 0x0b, 0x96, 0xcc, 0xae,
	0x1c, 0xb9, 0xc1, 0x81, 0x2c, 0x87, 0x48, 0xbf, 0x75, 0x93, 0x84, 0xd9, 0xf5, 0xea, 0xcc, 0xd3,
	0x6e, 0x83, 0x52, 0xf3, 0xaf, 0x43, 0x5c, 0x80, 0xd1, 0x6c, 0xb7, 0x42, 0xa7, 0x15, 0x40, 0x29,
	0x0b, 0x68, 0x3e, 0x0a, 0x9d, 0xf4, 0x2b, 0x91, 0x87, 0x91, 0x16, 0x7c, 0x89, 0x23, 0x1a, 0x6b,
	0x8c, 0xb1, 0xa9, 0xc6, 0xa8, 0x11, 0x00, 0x3e, 0xb0, 0x4d, 0xca, 0x3d, 0xc3, 0x63, 0x57, 0xee,
	0xef, 0xc3, 0x3f, 0xc3, 0x58, 0xe4, 0xcf, 0x50, 0x3b, 0x87, 0xb5, 0x91, 0x4f, 0xea, 0x32, 0xde,
	0x13, 0x3f, 0xa6, 0xc3, 0x9b, 0x80, 0x22, 0x37, 0xe1, 0xe1, 0x8c, 0x29, 0x13, 0xcc, 0x89, 0x37,
	0x74, 0x01, 0x75, 0xb2, 0x0b, 0x68, 0xdf, 0x23, 0xc8, 0xd8, 0x8e, 0x67, 0x9d, 0x8a, 0x1f, 0x25,
	0xcb, 0xb1, 0x2f, 0xdd, 0x06, 0x66, 0x66, 0xf0, 0xe6, 0x19, 0x34, 0xde, 0x1c, 0x94, 0xc9, 0x3f,
	0xcd, 0x31, 0x0e, 0x17, 0xe7, 0x72, 0xa8, 0x7d, 0x86, 0x60, 0x23, 0x1a, 0xfa, 0x88, 0xb0, 0x3f,
	0x97, 0xc3, 0x58, 0x1c, 0xf1, 0xb9, 0x71, 0xdc, 0xf9, 0x3a, 0x0e, 0x4a, 0x63, 0xd0, 0x63, 0x58,
	0x85, 0x4c, 0xf5, 0xf1, 0xa3, 0x47, 0x94, 0xe8, 0xc7, 0x8f, 0xf5, 0x7a, 0x43, 0x5d, 0xc0, 0x2b,
	0x90, 0xae, 0x11, 0x9d, 0xd6, 0x88, 0x5e, 0xdb, 0x21, 0xba, 0x8a, 0x70, 0x1a, 0x96, 0xc2, 0x45,
	0x0c, 0x03, 0x24, 0xca, 0x47, 0x87, 0x87, 0x95, 0x86, 0x1a, 0xc7, 0x1b, 0xb0, 0x5a, 0xaf, 0xec,
	0x57, 0xf5, 0x3d, 0x5a, 0x3e, 0xd0, 0xcb, 0x1f, 0xd4, 0x8e, 0x2a, 0xd5, 0x86, 0xaa, 0xe0, 0x75,
	0x50, 0x1f, 0xea, 0x8d, 0xf2, 0x41, 0x54, 0xba, 0x28, 0xdc, 0x3e, 0xa9, 0xe8, 0x27, 0xb4, 0x7c,
	0xb0, 0x53, 0xdd, 0xd7, 0xd5, 0x04, 0xce, 0x40, 0xb2, 0xaa, 0x9f, 0x50, 0x21, 0x54, 0x97, 0xf0,
	0xdf, 0x60, 0xcd, 0x37, 0x0a, 0x02, 0xa1, 0xbb, 0x3b, 0x8d, 0xf2, 0x81, 0x9a, 0xc4, 0x9b, 0x80,
	0xeb, 0x7a, 0x75, 0x6f, 0x42, 0x9e, 0x12, 0x72, 0xa2, 0x97, 0x8f, 0x9e, 0xe8, 0xe4, 0x29, 0xf5,
	0x2d, 0x8f, 0x6b, 0x65, 0x15, 0x84, 0xa3, 0xa1, 0x9c, 0xe8, 0x8d, 0xc7, 0xa4, 0x2a, 0x15, 0x69,
	0x9c, 0x83, 0x4d, 0x1f, 0x77, 0x58, 0xa9, 0xd7, 0x2b, 0xd5, 0xfd, 0xd0, 0x63, 0x5d, 0xcd, 0xe0,
	0xeb, 0xb0, 0x21, 0x37, 0x99, 0x52, 0x5d, 0xc3, 0xcb, 0x00, 0xf5, 0xa7, 0xd5, 0x32, 0xad, 0x37,
	0x76, 0x1a, 0xba, 0xba, 0x2c, 0xfc, 0x8f, 0xd6, 0x94, 0xe8, 0xf5, 0xda, 0x51, 0xb5, 0xae, 0xab,
	0x2b, 0x92, 0xc9, 0xa3, 0x46, 0xe5, 0x61, 0xa5, 0xbc, 0xd3, 0xa8, 0x1c, 0x55, 0x55, 0x55, 0x78,
	0x8d, 0x4a, 0x46, 0xe0, 0x55, 0xc1, 0x46, 0x98, 0x50, 0x5d, 0x6f, 0xa8, 0x78, 0x37, 0xfb, 0xd3,
	0xcb, 0x2d, 0xf4, 0xe2, 0xe5, 0x16, 0xfa, 0xf5, 0xe5, 0x16, 0xfa, 0xe6, 0xd5, 0xd6, 0xc2, 0x8b,
	0x57, 0x5b, 0x0b, 0xbf, 0xbc, 0xda, 0x5a, 0x68, 0x26, 0xe4, 0x0b, 0xea, 0x3f, 0x7f, 0x04, 0x00,
	0x00, 0xff, 0xff, 0xd8, 0x94, 0xa1, 0x59, 0x8c, 0x12, 0x00, 0x00,
}

func (m *ConsensusMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Type))
	}
	if m.From != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.From))
	}
	if m.To != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.To))
	}
	if m.Epoch != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Epoch))
	}
	if len(m.Payload) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	return i, nil
}

func (m *RequestBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestBatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestHashList) > 0 {
		for _, s := range m.RequestHashList {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.RequestList) > 0 {
		for _, msg := range m.RequestList {
			dAtA[i] = 0x12
			i++
			i = encodeVarintRbft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Timestamp))
	}
	if m.SeqNo != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.SeqNo))
	}
	if len(m.LocalList) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.LocalList)))
		for _, b := range m.LocalList {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.BatchHash) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchHash)))
		i += copy(dAtA[i:], m.BatchHash)
	}
	return i, nil
}

func (m *HashBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HashBatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestHashList) > 0 {
		for _, s := range m.RequestHashList {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DeDuplicateRequestHashList) > 0 {
		for _, s := range m.DeDuplicateRequestHashList {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Timestamp))
	}
	return i, nil
}

func (m *SendRequestBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendRequestBatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if m.Batch != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Batch.Size()))
		n1, err := m.Batch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.BatchDigest) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchDigest)))
		i += copy(dAtA[i:], m.BatchDigest)
	}
	return i, nil
}

func (m *FetchMissingRequests) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchMissingRequests) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if m.View != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
	}
	if m.SequenceNumber != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.SequenceNumber))
	}
	if len(m.BatchDigest) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchDigest)))
		i += copy(dAtA[i:], m.BatchDigest)
	}
	if len(m.MissingRequestHashes) > 0 {
		for k, _ := range m.MissingRequestHashes {
			dAtA[i] = 0x2a
			i++
			v := m.MissingRequestHashes[k]
			mapSize := 1 + sovRbft(uint64(k)) + 1 + len(v) + sovRbft(uint64(len(v)))
			i = encodeVarintRbft(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintRbft(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintRbft(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *SendMissingRequests) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendMissingRequests) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if m.View != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
	}
	if m.SequenceNumber != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.SequenceNumber))
	}
	if len(m.BatchDigest) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchDigest)))
		i += copy(dAtA[i:], m.BatchDigest)
	}
	if len(m.MissingRequestHashes) > 0 {
		for k, _ := range m.MissingRequestHashes {
			dAtA[i] = 0x2a
			i++
			v := m.MissingRequestHashes[k]
			mapSize := 1 + sovRbft(uint64(k)) + 1 + len(v) + sovRbft(uint64(len(v)))
			i = encodeVarintRbft(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintRbft(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintRbft(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.MissingRequests) > 0 {
		for k, _ := range m.MissingRequests {
			dAtA[i] = 0x32
			i++
			v := m.MissingRequests[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovRbft(uint64(msgSize))
			}
			mapSize := 1 + sovRbft(uint64(k)) + msgSize
			i = encodeVarintRbft(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintRbft(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintRbft(dAtA, i, uint64(v.Size()))
				n2, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n2
			}
		}
	}
	return i, nil
}

func (m *RequestSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, msg := range m.Requests {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRbft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Local {
		dAtA[i] = 0x10
		i++
		if m.Local {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *NullRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NullRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	return i, nil
}

func (m *PrePrepare) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrePrepare) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if m.View != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
	}
	if m.SequenceNumber != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.SequenceNumber))
	}
	if len(m.BatchDigest) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchDigest)))
		i += copy(dAtA[i:], m.BatchDigest)
	}
	if m.HashBatch != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.HashBatch.Size()))
		n3, err := m.HashBatch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *Prepare) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Prepare) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if m.View != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
	}
	if m.SequenceNumber != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.SequenceNumber))
	}
	if len(m.BatchDigest) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchDigest)))
		i += copy(dAtA[i:], m.BatchDigest)
	}
	return i, nil
}

func (m *Commit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Commit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if m.View != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
	}
	if m.SequenceNumber != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.SequenceNumber))
	}
	if len(m.BatchDigest) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchDigest)))
		i += copy(dAtA[i:], m.BatchDigest)
	}
	return i, nil
}

func (m *SignedCheckpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignedCheckpoint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.NodeInfo.Size()))
		n4, err := m.NodeInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Checkpoint != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Checkpoint.Size()))
		n5, err := m.Checkpoint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Signature) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	return i, nil
}

func (m *FetchCheckpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchCheckpoint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ReplicaHash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.ReplicaHash)))
		i += copy(dAtA[i:], m.ReplicaHash)
	}
	if m.SequenceNumber != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.SequenceNumber))
	}
	return i, nil
}

func (m *Vc_C) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vc_C) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SequenceNumber != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.SequenceNumber))
	}
	if len(m.Digest) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.Digest)))
		i += copy(dAtA[i:], m.Digest)
	}
	return i, nil
}

func (m *Vc_PQ) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vc_PQ) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SequenceNumber != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.SequenceNumber))
	}
	if len(m.BatchDigest) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchDigest)))
		i += copy(dAtA[i:], m.BatchDigest)
	}
	if m.View != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
	}
	return i, nil
}

func (m *VcBasis) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VcBasis) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if m.View != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
	}
	if m.H != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.H))
	}
	if len(m.Cset) > 0 {
		for _, msg := range m.Cset {
			dAtA[i] = 0x22
			i++
			i = encodeVarintRbft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Pset) > 0 {
		for _, msg := range m.Pset {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintRbft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Qset) > 0 {
		for _, msg := range m.Qset {
			dAtA[i] = 0x32
			i++
			i = encodeVarintRbft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SignedCheckpoints) > 0 {
		for _, msg := range m.SignedCheckpoints {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintRbft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ViewChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewChange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Basis != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Basis.Size()))
		n6, err := m.Basis.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.Signature) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Timestamp))
	}
	return i, nil
}

func (m *NewView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewView) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if m.View != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
	}
	if len(m.Xset) > 0 {
		for k, _ := range m.Xset {
			dAtA[i] = 0x1a
			i++
			v := m.Xset[k]
			mapSize := 1 + sovRbft(uint64(k)) + 1 + len(v) + sovRbft(uint64(len(v)))
			i = encodeVarintRbft(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintRbft(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintRbft(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Bset) > 0 {
		for _, msg := range m.Bset {
			dAtA[i] = 0x22
			i++
			i = encodeVarintRbft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FetchRequestBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchRequestBatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if len(m.BatchDigest) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchDigest)))
		i += copy(dAtA[i:], m.BatchDigest)
	}
	return i, nil
}

func (m *RecoveryFetchPQC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryFetchPQC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if m.H != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.H))
	}
	return i, nil
}

func (m *RecoveryReturnPQC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryReturnPQC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if len(m.PrepreSet) > 0 {
		for _, msg := range m.PrepreSet {
			dAtA[i] = 0x12
			i++
			i = encodeVarintRbft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PreSet) > 0 {
		for _, msg := range m.PreSet {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintRbft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CmtSet) > 0 {
		for _, msg := range m.CmtSet {
			dAtA[i] = 0x22
			i++
			i = encodeVarintRbft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Pset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pset) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Set) > 0 {
		for _, msg := range m.Set {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRbft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Cset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cset) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Set) > 0 {
		for _, msg := range m.Set {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRbft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if len(m.ReplicaHash) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.ReplicaHash)))
		i += copy(dAtA[i:], m.ReplicaHash)
	}
	return i, nil
}

func (m *SyncState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.NodeInfo.Size()))
		n7, err := m.NodeInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Epoch != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Epoch))
	}
	return i, nil
}

func (m *SyncStateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncStateResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.View != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
	}
	if m.SignedCheckpoint != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.SignedCheckpoint.Size()))
		n8, err := m.SignedCheckpoint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *Notification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Notification) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Basis != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Basis.Size()))
		n9, err := m.Basis.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Epoch != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Epoch))
	}
	if len(m.Signature) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Timestamp))
	}
	if m.NodeInfo != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.NodeInfo.Size()))
		n10, err := m.NodeInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *NotificationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotificationResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Basis != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Basis.Size()))
		n11, err := m.Basis.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Epoch != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Epoch))
	}
	if m.NodeInfo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.NodeInfo.Size()))
		n12, err := m.NodeInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func encodeVarintRbft(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ConsensusMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovRbft(uint64(m.Type))
	}
	if m.From != 0 {
		n += 1 + sovRbft(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovRbft(uint64(m.To))
	}
	if m.Epoch != 0 {
		n += 1 + sovRbft(uint64(m.Epoch))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *RequestBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RequestHashList) > 0 {
		for _, s := range m.RequestHashList {
			l = len(s)
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if len(m.RequestList) > 0 {
		for _, e := range m.RequestList {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if m.Timestamp != 0 {
		n += 1 + sovRbft(uint64(m.Timestamp))
	}
	if m.SeqNo != 0 {
		n += 1 + sovRbft(uint64(m.SeqNo))
	}
	if len(m.LocalList) > 0 {
		n += 1 + sovRbft(uint64(len(m.LocalList))) + len(m.LocalList)*1
	}
	l = len(m.BatchHash)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *HashBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RequestHashList) > 0 {
		for _, s := range m.RequestHashList {
			l = len(s)
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if len(m.DeDuplicateRequestHashList) > 0 {
		for _, s := range m.DeDuplicateRequestHashList {
			l = len(s)
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if m.Timestamp != 0 {
		n += 1 + sovRbft(uint64(m.Timestamp))
	}
	return n
}

func (m *SendRequestBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.Batch != nil {
		l = m.Batch.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	l = len(m.BatchDigest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *FetchMissingRequests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovRbft(uint64(m.SequenceNumber))
	}
	l = len(m.BatchDigest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	if len(m.MissingRequestHashes) > 0 {
		for k, v := range m.MissingRequestHashes {
			_ = k
			_ = v
			mapEntrySize := 1 + sovRbft(uint64(k)) + 1 + len(v) + sovRbft(uint64(len(v)))
			n += mapEntrySize + 1 + sovRbft(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SendMissingRequests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovRbft(uint64(m.SequenceNumber))
	}
	l = len(m.BatchDigest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	if len(m.MissingRequestHashes) > 0 {
		for k, v := range m.MissingRequestHashes {
			_ = k
			_ = v
			mapEntrySize := 1 + sovRbft(uint64(k)) + 1 + len(v) + sovRbft(uint64(len(v)))
			n += mapEntrySize + 1 + sovRbft(uint64(mapEntrySize))
		}
	}
	if len(m.MissingRequests) > 0 {
		for k, v := range m.MissingRequests {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRbft(uint64(l))
			}
			mapEntrySize := 1 + sovRbft(uint64(k)) + l
			n += mapEntrySize + 1 + sovRbft(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RequestSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if m.Local {
		n += 2
	}
	return n
}

func (m *NullRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	return n
}

func (m *PrePrepare) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovRbft(uint64(m.SequenceNumber))
	}
	l = len(m.BatchDigest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.HashBatch != nil {
		l = m.HashBatch.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *Prepare) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovRbft(uint64(m.SequenceNumber))
	}
	l = len(m.BatchDigest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *Commit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovRbft(uint64(m.SequenceNumber))
	}
	l = len(m.BatchDigest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *SignedCheckpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeInfo != nil {
		l = m.NodeInfo.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.Checkpoint != nil {
		l = m.Checkpoint.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *FetchCheckpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ReplicaHash)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovRbft(uint64(m.SequenceNumber))
	}
	return n
}

func (m *Vc_C) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SequenceNumber != 0 {
		n += 1 + sovRbft(uint64(m.SequenceNumber))
	}
	l = len(m.Digest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *Vc_PQ) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SequenceNumber != 0 {
		n += 1 + sovRbft(uint64(m.SequenceNumber))
	}
	l = len(m.BatchDigest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	return n
}

func (m *VcBasis) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	if m.H != 0 {
		n += 1 + sovRbft(uint64(m.H))
	}
	if len(m.Cset) > 0 {
		for _, e := range m.Cset {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if len(m.Pset) > 0 {
		for _, e := range m.Pset {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if len(m.Qset) > 0 {
		for _, e := range m.Qset {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if len(m.SignedCheckpoints) > 0 {
		for _, e := range m.SignedCheckpoints {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	return n
}

func (m *ViewChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Basis != nil {
		l = m.Basis.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovRbft(uint64(m.Timestamp))
	}
	return n
}

func (m *NewView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	if len(m.Xset) > 0 {
		for k, v := range m.Xset {
			_ = k
			_ = v
			mapEntrySize := 1 + sovRbft(uint64(k)) + 1 + len(v) + sovRbft(uint64(len(v)))
			n += mapEntrySize + 1 + sovRbft(uint64(mapEntrySize))
		}
	}
	if len(m.Bset) > 0 {
		for _, e := range m.Bset {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	return n
}

func (m *FetchRequestBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	l = len(m.BatchDigest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *RecoveryFetchPQC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.H != 0 {
		n += 1 + sovRbft(uint64(m.H))
	}
	return n
}

func (m *RecoveryReturnPQC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if len(m.PrepreSet) > 0 {
		for _, e := range m.PrepreSet {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if len(m.PreSet) > 0 {
		for _, e := range m.PreSet {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if len(m.CmtSet) > 0 {
		for _, e := range m.CmtSet {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	return n
}

func (m *Pset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Set) > 0 {
		for _, e := range m.Set {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	return n
}

func (m *Cset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Set) > 0 {
		for _, e := range m.Set {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	return n
}

func (m *NodeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	l = len(m.ReplicaHash)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *SyncState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeInfo != nil {
		l = m.NodeInfo.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovRbft(uint64(m.Epoch))
	}
	return n
}

func (m *SyncStateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	if m.SignedCheckpoint != nil {
		l = m.SignedCheckpoint.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *Notification) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Basis != nil {
		l = m.Basis.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovRbft(uint64(m.Epoch))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovRbft(uint64(m.Timestamp))
	}
	if m.NodeInfo != nil {
		l = m.NodeInfo.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *NotificationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Basis != nil {
		l = m.Basis.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovRbft(uint64(m.Epoch))
	}
	if m.NodeInfo != nil {
		l = m.NodeInfo.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func sovRbft(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRbft(x uint64) (n int) {
	return sovRbft(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ConsensusMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: consensus_message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: consensus_message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: request_batch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: request_batch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHashList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHashList = append(m.RequestHashList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestList = append(m.RequestList, &protos.Transaction{})
			if err := m.RequestList[len(m.RequestList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNo", wireType)
			}
			m.SeqNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LocalList = append(m.LocalList, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRbft
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRbft
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.LocalList) == 0 {
					m.LocalList = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LocalList = append(m.LocalList, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalList", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HashBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: hash_batch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: hash_batch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHashList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHashList = append(m.RequestHashList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeDuplicateRequestHashList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeDuplicateRequestHashList = append(m.DeDuplicateRequestHashList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendRequestBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: send_request_batch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: send_request_batch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Batch == nil {
				m.Batch = &RequestBatch{}
			}
			if err := m.Batch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchMissingRequests) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: fetch_missing_requests: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: fetch_missing_requests: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissingRequestHashes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MissingRequestHashes == nil {
				m.MissingRequestHashes = make(map[uint64]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthRbft
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthRbft
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRbft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRbft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MissingRequestHashes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendMissingRequests) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: send_missing_requests: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: send_missing_requests: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissingRequestHashes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MissingRequestHashes == nil {
				m.MissingRequestHashes = make(map[uint64]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthRbft
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthRbft
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRbft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRbft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MissingRequestHashes[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissingRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MissingRequests == nil {
				m.MissingRequests = make(map[uint64]*protos.Transaction)
			}
			var mapkey uint64
			var mapvalue *protos.Transaction
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRbft
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthRbft
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &protos.Transaction{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRbft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRbft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MissingRequests[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: request_set: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: request_set: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, &protos.Transaction{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Local", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Local = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NullRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: null_request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: null_request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrePrepare) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: pre_prepare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: pre_prepare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashBatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HashBatch == nil {
				m.HashBatch = &HashBatch{}
			}
			if err := m.HashBatch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Prepare) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: prepare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: prepare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Commit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: commit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: commit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignedCheckpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: signed_checkpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: signed_checkpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeInfo == nil {
				m.NodeInfo = &NodeInfo{}
			}
			if err := m.NodeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Checkpoint == nil {
				m.Checkpoint = &protos.Checkpoint{}
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchCheckpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: fetch_checkpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: fetch_checkpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplicaHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vc_C) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: vc_C: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: vc_C: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Digest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vc_PQ) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: vc_PQ: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: vc_PQ: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VcBasis) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: vc_basis: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: vc_basis: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field H", wireType)
			}
			m.H = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.H |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cset = append(m.Cset, &Vc_C{})
			if err := m.Cset[len(m.Cset)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pset = append(m.Pset, &Vc_PQ{})
			if err := m.Pset[len(m.Pset)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Qset = append(m.Qset, &Vc_PQ{})
			if err := m.Qset[len(m.Qset)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedCheckpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignedCheckpoints = append(m.SignedCheckpoints, &SignedCheckpoint{})
			if err := m.SignedCheckpoints[len(m.SignedCheckpoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: view_change: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: view_change: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Basis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Basis == nil {
				m.Basis = &VcBasis{}
			}
			if err := m.Basis.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: new_view: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: new_view: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Xset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Xset == nil {
				m.Xset = make(map[uint64]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthRbft
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthRbft
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRbft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRbft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Xset[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bset = append(m.Bset, &VcBasis{})
			if err := m.Bset[len(m.Bset)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchRequestBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: fetch_request_batch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: fetch_request_batch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryFetchPQC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: recovery_fetchPQC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: recovery_fetchPQC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field H", wireType)
			}
			m.H = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.H |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryReturnPQC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: recovery_returnPQC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: recovery_returnPQC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepreSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrepreSet = append(m.PrepreSet, &PrePrepare{})
			if err := m.PrepreSet[len(m.PrepreSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreSet = append(m.PreSet, &Prepare{})
			if err := m.PreSet[len(m.PreSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmtSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CmtSet = append(m.CmtSet, &Commit{})
			if err := m.CmtSet[len(m.CmtSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Set = append(m.Set, &Prepare{})
			if err := m.Set[len(m.Set)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Set = append(m.Set, &Commit{})
			if err := m.Set[len(m.Set)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: node_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: node_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplicaHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sync_state: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sync_state: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeInfo == nil {
				m.NodeInfo = &NodeInfo{}
			}
			if err := m.NodeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncStateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sync_state_response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sync_state_response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedCheckpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignedCheckpoint == nil {
				m.SignedCheckpoint = &SignedCheckpoint{}
			}
			if err := m.SignedCheckpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Notification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: notification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: notification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Basis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Basis == nil {
				m.Basis = &VcBasis{}
			}
			if err := m.Basis.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeInfo == nil {
				m.NodeInfo = &NodeInfo{}
			}
			if err := m.NodeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotificationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: notification_response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: notification_response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Basis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Basis == nil {
				m.Basis = &VcBasis{}
			}
			if err := m.Basis.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeInfo == nil {
				m.NodeInfo = &NodeInfo{}
			}
			if err := m.NodeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRbft(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRbft
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthRbft
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRbft
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRbft(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthRbft
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRbft = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRbft   = fmt.Errorf("proto: integer overflow")
)
