// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rbft.proto

package rbftpb

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	protos "github.com/ultramesh/flato-event/inner/protos"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Type int32

const (
	Type_NULL_REQUEST           Type = 0
	Type_PRE_PREPARE            Type = 1
	Type_PREPARE                Type = 2
	Type_COMMIT                 Type = 3
	Type_CHECKPOINT             Type = 4
	Type_VIEW_CHANGE            Type = 5
	Type_NEW_VIEW               Type = 6
	Type_FETCH_REQUEST_BATCH    Type = 7
	Type_SEND_REQUEST_BATCH     Type = 8
	Type_RECOVERY_FETCH_QPC     Type = 9
	Type_RECOVERY_RETURN_QPC    Type = 10
	Type_READY_FOR_N            Type = 11
	Type_AGREE_UPDATE_N         Type = 12
	Type_UPDATE_N               Type = 13
	Type_FETCH_MISSING_REQUESTS Type = 14
	Type_SEND_MISSING_REQUESTS  Type = 15
	Type_SYNC_STATE             Type = 16
	Type_SYNC_STATE_RESPONSE    Type = 17
	Type_NOTIFICATION           Type = 18
	Type_NOTIFICATION_RESPONSE  Type = 19
	Type_CONF_CHANGE            Type = 20
	Type_REQUEST_SET            Type = 21
)

var Type_name = map[int32]string{
	0:  "NULL_REQUEST",
	1:  "PRE_PREPARE",
	2:  "PREPARE",
	3:  "COMMIT",
	4:  "CHECKPOINT",
	5:  "VIEW_CHANGE",
	6:  "NEW_VIEW",
	7:  "FETCH_REQUEST_BATCH",
	8:  "SEND_REQUEST_BATCH",
	9:  "RECOVERY_FETCH_QPC",
	10: "RECOVERY_RETURN_QPC",
	11: "READY_FOR_N",
	12: "AGREE_UPDATE_N",
	13: "UPDATE_N",
	14: "FETCH_MISSING_REQUESTS",
	15: "SEND_MISSING_REQUESTS",
	16: "SYNC_STATE",
	17: "SYNC_STATE_RESPONSE",
	18: "NOTIFICATION",
	19: "NOTIFICATION_RESPONSE",
	20: "CONF_CHANGE",
	21: "REQUEST_SET",
}

var Type_value = map[string]int32{
	"NULL_REQUEST":           0,
	"PRE_PREPARE":            1,
	"PREPARE":                2,
	"COMMIT":                 3,
	"CHECKPOINT":             4,
	"VIEW_CHANGE":            5,
	"NEW_VIEW":               6,
	"FETCH_REQUEST_BATCH":    7,
	"SEND_REQUEST_BATCH":     8,
	"RECOVERY_FETCH_QPC":     9,
	"RECOVERY_RETURN_QPC":    10,
	"READY_FOR_N":            11,
	"AGREE_UPDATE_N":         12,
	"UPDATE_N":               13,
	"FETCH_MISSING_REQUESTS": 14,
	"SEND_MISSING_REQUESTS":  15,
	"SYNC_STATE":             16,
	"SYNC_STATE_RESPONSE":    17,
	"NOTIFICATION":           18,
	"NOTIFICATION_RESPONSE":  19,
	"CONF_CHANGE":            20,
	"REQUEST_SET":            21,
}

func (x Type) String() string {
	return proto.EnumName(Type_name, int32(x))
}

func (Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{0}
}

type ConfChangeType int32

const (
	ConfChangeType_ConfChangeAddNode    ConfChangeType = 0
	ConfChangeType_ConfChangeRemoveNode ConfChangeType = 1
	ConfChangeType_ConfChangeUpdateNode ConfChangeType = 2
)

var ConfChangeType_name = map[int32]string{
	0: "ConfChangeAddNode",
	1: "ConfChangeRemoveNode",
	2: "ConfChangeUpdateNode",
}

var ConfChangeType_value = map[string]int32{
	"ConfChangeAddNode":    0,
	"ConfChangeRemoveNode": 1,
	"ConfChangeUpdateNode": 2,
}

func (x ConfChangeType) String() string {
	return proto.EnumName(ConfChangeType_name, int32(x))
}

func (ConfChangeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{1}
}

type InformType int32

const (
	InformType_FilterFinishRecovery    InformType = 0
	InformType_FilterFinishViewChange  InformType = 1
	InformType_FilterFinishUpdateN     InformType = 2
	InformType_FilterFinishStateUpdate InformType = 3
	InformType_FilterPoolFull          InformType = 4
	InformType_FilterStableCheckpoint  InformType = 5
)

var InformType_name = map[int32]string{
	0: "FilterFinishRecovery",
	1: "FilterFinishViewChange",
	2: "FilterFinishUpdateN",
	3: "FilterFinishStateUpdate",
	4: "FilterPoolFull",
	5: "FilterStableCheckpoint",
}

var InformType_value = map[string]int32{
	"FilterFinishRecovery":    0,
	"FilterFinishViewChange":  1,
	"FilterFinishUpdateN":     2,
	"FilterFinishStateUpdate": 3,
	"FilterPoolFull":          4,
	"FilterStableCheckpoint":  5,
}

func (x InformType) String() string {
	return proto.EnumName(InformType_name, int32(x))
}

func (InformType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{2}
}

type ConsensusMessage struct {
	Type    Type   `protobuf:"varint,1,opt,name=type,proto3,enum=rbftpb.Type" json:"type,omitempty"`
	From    uint64 `protobuf:"varint,2,opt,name=from,proto3" json:"from,omitempty"`
	To      uint64 `protobuf:"varint,3,opt,name=to,proto3" json:"to,omitempty"`
	Payload []byte `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *ConsensusMessage) Reset()         { *m = ConsensusMessage{} }
func (m *ConsensusMessage) String() string { return proto.CompactTextString(m) }
func (*ConsensusMessage) ProtoMessage()    {}
func (*ConsensusMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{0}
}
func (m *ConsensusMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusMessage.Merge(m, src)
}
func (m *ConsensusMessage) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusMessage proto.InternalMessageInfo

func (m *ConsensusMessage) GetType() Type {
	if m != nil {
		return m.Type
	}
	return Type_NULL_REQUEST
}

func (m *ConsensusMessage) GetFrom() uint64 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *ConsensusMessage) GetTo() uint64 {
	if m != nil {
		return m.To
	}
	return 0
}

func (m *ConsensusMessage) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type RequestBatch struct {
	RequestHashList []string              `protobuf:"bytes,1,rep,name=request_hash_list,json=requestHashList,proto3" json:"request_hash_list,omitempty"`
	RequestList     []*protos.Transaction `protobuf:"bytes,2,rep,name=request_list,json=requestList,proto3" json:"request_list,omitempty"`
	Timestamp       int64                 `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	SeqNo           uint64                `protobuf:"varint,4,opt,name=seq_no,json=seqNo,proto3" json:"seq_no,omitempty"`
	LocalList       []bool                `protobuf:"varint,5,rep,packed,name=local_list,json=localList,proto3" json:"local_list,omitempty"`
	BatchHash       string                `protobuf:"bytes,6,opt,name=batch_hash,json=batchHash,proto3" json:"batch_hash,omitempty"`
}

func (m *RequestBatch) Reset()         { *m = RequestBatch{} }
func (m *RequestBatch) String() string { return proto.CompactTextString(m) }
func (*RequestBatch) ProtoMessage()    {}
func (*RequestBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{1}
}
func (m *RequestBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestBatch.Merge(m, src)
}
func (m *RequestBatch) XXX_Size() int {
	return m.Size()
}
func (m *RequestBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestBatch.DiscardUnknown(m)
}

var xxx_messageInfo_RequestBatch proto.InternalMessageInfo

func (m *RequestBatch) GetRequestHashList() []string {
	if m != nil {
		return m.RequestHashList
	}
	return nil
}

func (m *RequestBatch) GetRequestList() []*protos.Transaction {
	if m != nil {
		return m.RequestList
	}
	return nil
}

func (m *RequestBatch) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *RequestBatch) GetSeqNo() uint64 {
	if m != nil {
		return m.SeqNo
	}
	return 0
}

func (m *RequestBatch) GetLocalList() []bool {
	if m != nil {
		return m.LocalList
	}
	return nil
}

func (m *RequestBatch) GetBatchHash() string {
	if m != nil {
		return m.BatchHash
	}
	return ""
}

type HashBatch struct {
	RequestHashList            []string `protobuf:"bytes,1,rep,name=request_hash_list,json=requestHashList,proto3" json:"request_hash_list,omitempty"`
	DeDuplicateRequestHashList []string `protobuf:"bytes,2,rep,name=de_duplicate_request_hash_list,json=deDuplicateRequestHashList,proto3" json:"de_duplicate_request_hash_list,omitempty"`
	Timestamp                  int64    `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *HashBatch) Reset()         { *m = HashBatch{} }
func (m *HashBatch) String() string { return proto.CompactTextString(m) }
func (*HashBatch) ProtoMessage()    {}
func (*HashBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{2}
}
func (m *HashBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HashBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HashBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HashBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HashBatch.Merge(m, src)
}
func (m *HashBatch) XXX_Size() int {
	return m.Size()
}
func (m *HashBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_HashBatch.DiscardUnknown(m)
}

var xxx_messageInfo_HashBatch proto.InternalMessageInfo

func (m *HashBatch) GetRequestHashList() []string {
	if m != nil {
		return m.RequestHashList
	}
	return nil
}

func (m *HashBatch) GetDeDuplicateRequestHashList() []string {
	if m != nil {
		return m.DeDuplicateRequestHashList
	}
	return nil
}

func (m *HashBatch) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

type SendRequestBatch struct {
	ReplicaId   uint64        `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	Batch       *RequestBatch `protobuf:"bytes,2,opt,name=batch,proto3" json:"batch,omitempty"`
	BatchDigest string        `protobuf:"bytes,3,opt,name=batch_digest,json=batchDigest,proto3" json:"batch_digest,omitempty"`
}

func (m *SendRequestBatch) Reset()         { *m = SendRequestBatch{} }
func (m *SendRequestBatch) String() string { return proto.CompactTextString(m) }
func (*SendRequestBatch) ProtoMessage()    {}
func (*SendRequestBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{3}
}
func (m *SendRequestBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendRequestBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendRequestBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendRequestBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendRequestBatch.Merge(m, src)
}
func (m *SendRequestBatch) XXX_Size() int {
	return m.Size()
}
func (m *SendRequestBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_SendRequestBatch.DiscardUnknown(m)
}

var xxx_messageInfo_SendRequestBatch proto.InternalMessageInfo

func (m *SendRequestBatch) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *SendRequestBatch) GetBatch() *RequestBatch {
	if m != nil {
		return m.Batch
	}
	return nil
}

func (m *SendRequestBatch) GetBatchDigest() string {
	if m != nil {
		return m.BatchDigest
	}
	return ""
}

type FetchMissingRequests struct {
	ReplicaId            uint64            `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	View                 uint64            `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
	SequenceNumber       uint64            `protobuf:"varint,3,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	BatchDigest          string            `protobuf:"bytes,4,opt,name=batch_digest,json=batchDigest,proto3" json:"batch_digest,omitempty"`
	MissingRequestHashes map[uint64]string `protobuf:"bytes,5,rep,name=missing_request_hashes,json=missingRequestHashes,proto3" json:"missing_request_hashes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *FetchMissingRequests) Reset()         { *m = FetchMissingRequests{} }
func (m *FetchMissingRequests) String() string { return proto.CompactTextString(m) }
func (*FetchMissingRequests) ProtoMessage()    {}
func (*FetchMissingRequests) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{4}
}
func (m *FetchMissingRequests) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchMissingRequests) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchMissingRequests.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchMissingRequests) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchMissingRequests.Merge(m, src)
}
func (m *FetchMissingRequests) XXX_Size() int {
	return m.Size()
}
func (m *FetchMissingRequests) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchMissingRequests.DiscardUnknown(m)
}

var xxx_messageInfo_FetchMissingRequests proto.InternalMessageInfo

func (m *FetchMissingRequests) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *FetchMissingRequests) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *FetchMissingRequests) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *FetchMissingRequests) GetBatchDigest() string {
	if m != nil {
		return m.BatchDigest
	}
	return ""
}

func (m *FetchMissingRequests) GetMissingRequestHashes() map[uint64]string {
	if m != nil {
		return m.MissingRequestHashes
	}
	return nil
}

type SendMissingRequests struct {
	ReplicaId            uint64                         `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	View                 uint64                         `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
	SequenceNumber       uint64                         `protobuf:"varint,3,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	BatchDigest          string                         `protobuf:"bytes,4,opt,name=batch_digest,json=batchDigest,proto3" json:"batch_digest,omitempty"`
	MissingRequestHashes map[uint64]string              `protobuf:"bytes,5,rep,name=missing_request_hashes,json=missingRequestHashes,proto3" json:"missing_request_hashes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	MissingRequests      map[uint64]*protos.Transaction `protobuf:"bytes,6,rep,name=missing_requests,json=missingRequests,proto3" json:"missing_requests,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SendMissingRequests) Reset()         { *m = SendMissingRequests{} }
func (m *SendMissingRequests) String() string { return proto.CompactTextString(m) }
func (*SendMissingRequests) ProtoMessage()    {}
func (*SendMissingRequests) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{5}
}
func (m *SendMissingRequests) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendMissingRequests) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendMissingRequests.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendMissingRequests) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendMissingRequests.Merge(m, src)
}
func (m *SendMissingRequests) XXX_Size() int {
	return m.Size()
}
func (m *SendMissingRequests) XXX_DiscardUnknown() {
	xxx_messageInfo_SendMissingRequests.DiscardUnknown(m)
}

var xxx_messageInfo_SendMissingRequests proto.InternalMessageInfo

func (m *SendMissingRequests) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *SendMissingRequests) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *SendMissingRequests) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *SendMissingRequests) GetBatchDigest() string {
	if m != nil {
		return m.BatchDigest
	}
	return ""
}

func (m *SendMissingRequests) GetMissingRequestHashes() map[uint64]string {
	if m != nil {
		return m.MissingRequestHashes
	}
	return nil
}

func (m *SendMissingRequests) GetMissingRequests() map[uint64]*protos.Transaction {
	if m != nil {
		return m.MissingRequests
	}
	return nil
}

type RequestSet struct {
	Requests []*protos.Transaction `protobuf:"bytes,1,rep,name=requests,proto3" json:"requests,omitempty"`
	Local    bool                  `protobuf:"varint,2,opt,name=local,proto3" json:"local,omitempty"`
}

func (m *RequestSet) Reset()         { *m = RequestSet{} }
func (m *RequestSet) String() string { return proto.CompactTextString(m) }
func (*RequestSet) ProtoMessage()    {}
func (*RequestSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{6}
}
func (m *RequestSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestSet.Merge(m, src)
}
func (m *RequestSet) XXX_Size() int {
	return m.Size()
}
func (m *RequestSet) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestSet.DiscardUnknown(m)
}

var xxx_messageInfo_RequestSet proto.InternalMessageInfo

func (m *RequestSet) GetRequests() []*protos.Transaction {
	if m != nil {
		return m.Requests
	}
	return nil
}

func (m *RequestSet) GetLocal() bool {
	if m != nil {
		return m.Local
	}
	return false
}

type NullRequest struct {
	ReplicaId uint64 `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
}

func (m *NullRequest) Reset()         { *m = NullRequest{} }
func (m *NullRequest) String() string { return proto.CompactTextString(m) }
func (*NullRequest) ProtoMessage()    {}
func (*NullRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{7}
}
func (m *NullRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NullRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NullRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NullRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NullRequest.Merge(m, src)
}
func (m *NullRequest) XXX_Size() int {
	return m.Size()
}
func (m *NullRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NullRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NullRequest proto.InternalMessageInfo

func (m *NullRequest) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

type PrePrepare struct {
	ReplicaId      uint64     `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	View           uint64     `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
	SequenceNumber uint64     `protobuf:"varint,3,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	BatchDigest    string     `protobuf:"bytes,4,opt,name=batch_digest,json=batchDigest,proto3" json:"batch_digest,omitempty"`
	HashBatch      *HashBatch `protobuf:"bytes,5,opt,name=hash_batch,json=hashBatch,proto3" json:"hash_batch,omitempty"`
}

func (m *PrePrepare) Reset()         { *m = PrePrepare{} }
func (m *PrePrepare) String() string { return proto.CompactTextString(m) }
func (*PrePrepare) ProtoMessage()    {}
func (*PrePrepare) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{8}
}
func (m *PrePrepare) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrePrepare) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrePrepare.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrePrepare) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrePrepare.Merge(m, src)
}
func (m *PrePrepare) XXX_Size() int {
	return m.Size()
}
func (m *PrePrepare) XXX_DiscardUnknown() {
	xxx_messageInfo_PrePrepare.DiscardUnknown(m)
}

var xxx_messageInfo_PrePrepare proto.InternalMessageInfo

func (m *PrePrepare) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *PrePrepare) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *PrePrepare) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *PrePrepare) GetBatchDigest() string {
	if m != nil {
		return m.BatchDigest
	}
	return ""
}

func (m *PrePrepare) GetHashBatch() *HashBatch {
	if m != nil {
		return m.HashBatch
	}
	return nil
}

type Prepare struct {
	ReplicaId      uint64 `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	View           uint64 `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
	SequenceNumber uint64 `protobuf:"varint,3,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	BatchDigest    string `protobuf:"bytes,4,opt,name=batch_digest,json=batchDigest,proto3" json:"batch_digest,omitempty"`
}

func (m *Prepare) Reset()         { *m = Prepare{} }
func (m *Prepare) String() string { return proto.CompactTextString(m) }
func (*Prepare) ProtoMessage()    {}
func (*Prepare) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{9}
}
func (m *Prepare) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Prepare) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Prepare.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Prepare) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Prepare.Merge(m, src)
}
func (m *Prepare) XXX_Size() int {
	return m.Size()
}
func (m *Prepare) XXX_DiscardUnknown() {
	xxx_messageInfo_Prepare.DiscardUnknown(m)
}

var xxx_messageInfo_Prepare proto.InternalMessageInfo

func (m *Prepare) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *Prepare) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *Prepare) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *Prepare) GetBatchDigest() string {
	if m != nil {
		return m.BatchDigest
	}
	return ""
}

type Commit struct {
	ReplicaId      uint64 `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	View           uint64 `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
	SequenceNumber uint64 `protobuf:"varint,3,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	BatchDigest    string `protobuf:"bytes,4,opt,name=batch_digest,json=batchDigest,proto3" json:"batch_digest,omitempty"`
}

func (m *Commit) Reset()         { *m = Commit{} }
func (m *Commit) String() string { return proto.CompactTextString(m) }
func (*Commit) ProtoMessage()    {}
func (*Commit) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{10}
}
func (m *Commit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Commit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Commit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Commit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Commit.Merge(m, src)
}
func (m *Commit) XXX_Size() int {
	return m.Size()
}
func (m *Commit) XXX_DiscardUnknown() {
	xxx_messageInfo_Commit.DiscardUnknown(m)
}

var xxx_messageInfo_Commit proto.InternalMessageInfo

func (m *Commit) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *Commit) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *Commit) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *Commit) GetBatchDigest() string {
	if m != nil {
		return m.BatchDigest
	}
	return ""
}

type Checkpoint struct {
	ReplicaId      uint64 `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	SequenceNumber uint64 `protobuf:"varint,2,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	Digest         string `protobuf:"bytes,3,opt,name=digest,proto3" json:"digest,omitempty"`
}

func (m *Checkpoint) Reset()         { *m = Checkpoint{} }
func (m *Checkpoint) String() string { return proto.CompactTextString(m) }
func (*Checkpoint) ProtoMessage()    {}
func (*Checkpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{11}
}
func (m *Checkpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Checkpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Checkpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Checkpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Checkpoint.Merge(m, src)
}
func (m *Checkpoint) XXX_Size() int {
	return m.Size()
}
func (m *Checkpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_Checkpoint.DiscardUnknown(m)
}

var xxx_messageInfo_Checkpoint proto.InternalMessageInfo

func (m *Checkpoint) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *Checkpoint) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *Checkpoint) GetDigest() string {
	if m != nil {
		return m.Digest
	}
	return ""
}

type Vc_C struct {
	SequenceNumber uint64 `protobuf:"varint,1,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	Digest         string `protobuf:"bytes,2,opt,name=digest,proto3" json:"digest,omitempty"`
}

func (m *Vc_C) Reset()         { *m = Vc_C{} }
func (m *Vc_C) String() string { return proto.CompactTextString(m) }
func (*Vc_C) ProtoMessage()    {}
func (*Vc_C) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{12}
}
func (m *Vc_C) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vc_C) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vc_C.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vc_C) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vc_C.Merge(m, src)
}
func (m *Vc_C) XXX_Size() int {
	return m.Size()
}
func (m *Vc_C) XXX_DiscardUnknown() {
	xxx_messageInfo_Vc_C.DiscardUnknown(m)
}

var xxx_messageInfo_Vc_C proto.InternalMessageInfo

func (m *Vc_C) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *Vc_C) GetDigest() string {
	if m != nil {
		return m.Digest
	}
	return ""
}

type Vc_PQ struct {
	SequenceNumber uint64 `protobuf:"varint,1,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	BatchDigest    string `protobuf:"bytes,2,opt,name=batch_digest,json=batchDigest,proto3" json:"batch_digest,omitempty"`
	View           uint64 `protobuf:"varint,3,opt,name=view,proto3" json:"view,omitempty"`
}

func (m *Vc_PQ) Reset()         { *m = Vc_PQ{} }
func (m *Vc_PQ) String() string { return proto.CompactTextString(m) }
func (*Vc_PQ) ProtoMessage()    {}
func (*Vc_PQ) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{13}
}
func (m *Vc_PQ) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vc_PQ) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vc_PQ.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vc_PQ) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vc_PQ.Merge(m, src)
}
func (m *Vc_PQ) XXX_Size() int {
	return m.Size()
}
func (m *Vc_PQ) XXX_DiscardUnknown() {
	xxx_messageInfo_Vc_PQ.DiscardUnknown(m)
}

var xxx_messageInfo_Vc_PQ proto.InternalMessageInfo

func (m *Vc_PQ) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *Vc_PQ) GetBatchDigest() string {
	if m != nil {
		return m.BatchDigest
	}
	return ""
}

func (m *Vc_PQ) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

type VcBasis struct {
	ReplicaId uint64   `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	View      uint64   `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
	H         uint64   `protobuf:"varint,3,opt,name=h,proto3" json:"h,omitempty"`
	Cset      []*Vc_C  `protobuf:"bytes,4,rep,name=cset,proto3" json:"cset,omitempty"`
	Pset      []*Vc_PQ `protobuf:"bytes,5,rep,name=pset,proto3" json:"pset,omitempty"`
	Qset      []*Vc_PQ `protobuf:"bytes,6,rep,name=qset,proto3" json:"qset,omitempty"`
}

func (m *VcBasis) Reset()         { *m = VcBasis{} }
func (m *VcBasis) String() string { return proto.CompactTextString(m) }
func (*VcBasis) ProtoMessage()    {}
func (*VcBasis) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{14}
}
func (m *VcBasis) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VcBasis) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VcBasis.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VcBasis) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VcBasis.Merge(m, src)
}
func (m *VcBasis) XXX_Size() int {
	return m.Size()
}
func (m *VcBasis) XXX_DiscardUnknown() {
	xxx_messageInfo_VcBasis.DiscardUnknown(m)
}

var xxx_messageInfo_VcBasis proto.InternalMessageInfo

func (m *VcBasis) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *VcBasis) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *VcBasis) GetH() uint64 {
	if m != nil {
		return m.H
	}
	return 0
}

func (m *VcBasis) GetCset() []*Vc_C {
	if m != nil {
		return m.Cset
	}
	return nil
}

func (m *VcBasis) GetPset() []*Vc_PQ {
	if m != nil {
		return m.Pset
	}
	return nil
}

func (m *VcBasis) GetQset() []*Vc_PQ {
	if m != nil {
		return m.Qset
	}
	return nil
}

type ViewChange struct {
	Basis     *VcBasis `protobuf:"bytes,1,opt,name=basis,proto3" json:"basis,omitempty"`
	Signature []byte   `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	Timestamp int64    `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *ViewChange) Reset()         { *m = ViewChange{} }
func (m *ViewChange) String() string { return proto.CompactTextString(m) }
func (*ViewChange) ProtoMessage()    {}
func (*ViewChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{15}
}
func (m *ViewChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViewChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewChange.Merge(m, src)
}
func (m *ViewChange) XXX_Size() int {
	return m.Size()
}
func (m *ViewChange) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewChange.DiscardUnknown(m)
}

var xxx_messageInfo_ViewChange proto.InternalMessageInfo

func (m *ViewChange) GetBasis() *VcBasis {
	if m != nil {
		return m.Basis
	}
	return nil
}

func (m *ViewChange) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *ViewChange) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

type NewView struct {
	ReplicaId uint64            `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	View      uint64            `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
	Xset      map[uint64]string `protobuf:"bytes,3,rep,name=xset,proto3" json:"xset,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Bset      []*VcBasis        `protobuf:"bytes,4,rep,name=bset,proto3" json:"bset,omitempty"`
}

func (m *NewView) Reset()         { *m = NewView{} }
func (m *NewView) String() string { return proto.CompactTextString(m) }
func (*NewView) ProtoMessage()    {}
func (*NewView) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{16}
}
func (m *NewView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewView.Merge(m, src)
}
func (m *NewView) XXX_Size() int {
	return m.Size()
}
func (m *NewView) XXX_DiscardUnknown() {
	xxx_messageInfo_NewView.DiscardUnknown(m)
}

var xxx_messageInfo_NewView proto.InternalMessageInfo

func (m *NewView) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *NewView) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *NewView) GetXset() map[uint64]string {
	if m != nil {
		return m.Xset
	}
	return nil
}

func (m *NewView) GetBset() []*VcBasis {
	if m != nil {
		return m.Bset
	}
	return nil
}

type FetchRequestBatch struct {
	ReplicaId   uint64 `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	BatchDigest string `protobuf:"bytes,2,opt,name=batch_digest,json=batchDigest,proto3" json:"batch_digest,omitempty"`
}

func (m *FetchRequestBatch) Reset()         { *m = FetchRequestBatch{} }
func (m *FetchRequestBatch) String() string { return proto.CompactTextString(m) }
func (*FetchRequestBatch) ProtoMessage()    {}
func (*FetchRequestBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{17}
}
func (m *FetchRequestBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchRequestBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchRequestBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchRequestBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchRequestBatch.Merge(m, src)
}
func (m *FetchRequestBatch) XXX_Size() int {
	return m.Size()
}
func (m *FetchRequestBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchRequestBatch.DiscardUnknown(m)
}

var xxx_messageInfo_FetchRequestBatch proto.InternalMessageInfo

func (m *FetchRequestBatch) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *FetchRequestBatch) GetBatchDigest() string {
	if m != nil {
		return m.BatchDigest
	}
	return ""
}

type RecoveryFetchPQC struct {
	ReplicaId uint64 `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	H         uint64 `protobuf:"varint,2,opt,name=h,proto3" json:"h,omitempty"`
}

func (m *RecoveryFetchPQC) Reset()         { *m = RecoveryFetchPQC{} }
func (m *RecoveryFetchPQC) String() string { return proto.CompactTextString(m) }
func (*RecoveryFetchPQC) ProtoMessage()    {}
func (*RecoveryFetchPQC) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{18}
}
func (m *RecoveryFetchPQC) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryFetchPQC) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecoveryFetchPQC.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecoveryFetchPQC) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryFetchPQC.Merge(m, src)
}
func (m *RecoveryFetchPQC) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryFetchPQC) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryFetchPQC.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryFetchPQC proto.InternalMessageInfo

func (m *RecoveryFetchPQC) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *RecoveryFetchPQC) GetH() uint64 {
	if m != nil {
		return m.H
	}
	return 0
}

type RecoveryReturnPQC struct {
	ReplicaId uint64        `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	PrepreSet []*PrePrepare `protobuf:"bytes,2,rep,name=prepre_set,json=prepreSet,proto3" json:"prepre_set,omitempty"`
	PreSet    []*Prepare    `protobuf:"bytes,3,rep,name=pre_set,json=preSet,proto3" json:"pre_set,omitempty"`
	CmtSet    []*Commit     `protobuf:"bytes,4,rep,name=cmt_set,json=cmtSet,proto3" json:"cmt_set,omitempty"`
}

func (m *RecoveryReturnPQC) Reset()         { *m = RecoveryReturnPQC{} }
func (m *RecoveryReturnPQC) String() string { return proto.CompactTextString(m) }
func (*RecoveryReturnPQC) ProtoMessage()    {}
func (*RecoveryReturnPQC) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{19}
}
func (m *RecoveryReturnPQC) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryReturnPQC) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecoveryReturnPQC.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecoveryReturnPQC) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryReturnPQC.Merge(m, src)
}
func (m *RecoveryReturnPQC) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryReturnPQC) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryReturnPQC.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryReturnPQC proto.InternalMessageInfo

func (m *RecoveryReturnPQC) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *RecoveryReturnPQC) GetPrepreSet() []*PrePrepare {
	if m != nil {
		return m.PrepreSet
	}
	return nil
}

func (m *RecoveryReturnPQC) GetPreSet() []*Prepare {
	if m != nil {
		return m.PreSet
	}
	return nil
}

func (m *RecoveryReturnPQC) GetCmtSet() []*Commit {
	if m != nil {
		return m.CmtSet
	}
	return nil
}

type Pset struct {
	Set []*Prepare `protobuf:"bytes,1,rep,name=set,proto3" json:"set,omitempty"`
}

func (m *Pset) Reset()         { *m = Pset{} }
func (m *Pset) String() string { return proto.CompactTextString(m) }
func (*Pset) ProtoMessage()    {}
func (*Pset) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{20}
}
func (m *Pset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pset.Merge(m, src)
}
func (m *Pset) XXX_Size() int {
	return m.Size()
}
func (m *Pset) XXX_DiscardUnknown() {
	xxx_messageInfo_Pset.DiscardUnknown(m)
}

var xxx_messageInfo_Pset proto.InternalMessageInfo

func (m *Pset) GetSet() []*Prepare {
	if m != nil {
		return m.Set
	}
	return nil
}

type Cset struct {
	Set []*Commit `protobuf:"bytes,1,rep,name=set,proto3" json:"set,omitempty"`
}

func (m *Cset) Reset()         { *m = Cset{} }
func (m *Cset) String() string { return proto.CompactTextString(m) }
func (*Cset) ProtoMessage()    {}
func (*Cset) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{21}
}
func (m *Cset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cset.Merge(m, src)
}
func (m *Cset) XXX_Size() int {
	return m.Size()
}
func (m *Cset) XXX_DiscardUnknown() {
	xxx_messageInfo_Cset.DiscardUnknown(m)
}

var xxx_messageInfo_Cset proto.InternalMessageInfo

func (m *Cset) GetSet() []*Commit {
	if m != nil {
		return m.Set
	}
	return nil
}

type ReadyForN struct {
	ReplicaId   uint64 `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	NewNodeInfo string `protobuf:"bytes,2,opt,name=new_node_info,json=newNodeInfo,proto3" json:"new_node_info,omitempty"`
	ExpectN     uint64 `protobuf:"varint,3,opt,name=expect_n,json=expectN,proto3" json:"expect_n,omitempty"`
}

func (m *ReadyForN) Reset()         { *m = ReadyForN{} }
func (m *ReadyForN) String() string { return proto.CompactTextString(m) }
func (*ReadyForN) ProtoMessage()    {}
func (*ReadyForN) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{22}
}
func (m *ReadyForN) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadyForN) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadyForN.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadyForN) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadyForN.Merge(m, src)
}
func (m *ReadyForN) XXX_Size() int {
	return m.Size()
}
func (m *ReadyForN) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadyForN.DiscardUnknown(m)
}

var xxx_messageInfo_ReadyForN proto.InternalMessageInfo

func (m *ReadyForN) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *ReadyForN) GetNewNodeInfo() string {
	if m != nil {
		return m.NewNodeInfo
	}
	return ""
}

func (m *ReadyForN) GetExpectN() uint64 {
	if m != nil {
		return m.ExpectN
	}
	return 0
}

type AgreeUpdateN struct {
	Basis   *VcBasis `protobuf:"bytes,1,opt,name=basis,proto3" json:"basis,omitempty"`
	Flag    bool     `protobuf:"varint,2,opt,name=flag,proto3" json:"flag,omitempty"`
	Id      uint64   `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
	Info    string   `protobuf:"bytes,4,opt,name=info,proto3" json:"info,omitempty"`
	N       int64    `protobuf:"varint,5,opt,name=n,proto3" json:"n,omitempty"`
	ExpectN uint64   `protobuf:"varint,6,opt,name=expect_n,json=expectN,proto3" json:"expect_n,omitempty"`
}

func (m *AgreeUpdateN) Reset()         { *m = AgreeUpdateN{} }
func (m *AgreeUpdateN) String() string { return proto.CompactTextString(m) }
func (*AgreeUpdateN) ProtoMessage()    {}
func (*AgreeUpdateN) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{23}
}
func (m *AgreeUpdateN) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AgreeUpdateN) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AgreeUpdateN.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AgreeUpdateN) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AgreeUpdateN.Merge(m, src)
}
func (m *AgreeUpdateN) XXX_Size() int {
	return m.Size()
}
func (m *AgreeUpdateN) XXX_DiscardUnknown() {
	xxx_messageInfo_AgreeUpdateN.DiscardUnknown(m)
}

var xxx_messageInfo_AgreeUpdateN proto.InternalMessageInfo

func (m *AgreeUpdateN) GetBasis() *VcBasis {
	if m != nil {
		return m.Basis
	}
	return nil
}

func (m *AgreeUpdateN) GetFlag() bool {
	if m != nil {
		return m.Flag
	}
	return false
}

func (m *AgreeUpdateN) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *AgreeUpdateN) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

func (m *AgreeUpdateN) GetN() int64 {
	if m != nil {
		return m.N
	}
	return 0
}

func (m *AgreeUpdateN) GetExpectN() uint64 {
	if m != nil {
		return m.ExpectN
	}
	return 0
}

type UpdateN struct {
	Flag      bool              `protobuf:"varint,1,opt,name=flag,proto3" json:"flag,omitempty"`
	ReplicaId uint64            `protobuf:"varint,2,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	Id        uint64            `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
	N         int64             `protobuf:"varint,4,opt,name=n,proto3" json:"n,omitempty"`
	View      uint64            `protobuf:"varint,5,opt,name=view,proto3" json:"view,omitempty"`
	Xset      map[uint64]string `protobuf:"bytes,6,rep,name=xset,proto3" json:"xset,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Bset      []*VcBasis        `protobuf:"bytes,7,rep,name=bset,proto3" json:"bset,omitempty"`
}

func (m *UpdateN) Reset()         { *m = UpdateN{} }
func (m *UpdateN) String() string { return proto.CompactTextString(m) }
func (*UpdateN) ProtoMessage()    {}
func (*UpdateN) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{24}
}
func (m *UpdateN) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateN) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateN.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateN) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateN.Merge(m, src)
}
func (m *UpdateN) XXX_Size() int {
	return m.Size()
}
func (m *UpdateN) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateN.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateN proto.InternalMessageInfo

func (m *UpdateN) GetFlag() bool {
	if m != nil {
		return m.Flag
	}
	return false
}

func (m *UpdateN) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *UpdateN) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UpdateN) GetN() int64 {
	if m != nil {
		return m.N
	}
	return 0
}

func (m *UpdateN) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *UpdateN) GetXset() map[uint64]string {
	if m != nil {
		return m.Xset
	}
	return nil
}

func (m *UpdateN) GetBset() []*VcBasis {
	if m != nil {
		return m.Bset
	}
	return nil
}

type SyncState struct {
	ReplicaId uint64 `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
}

func (m *SyncState) Reset()         { *m = SyncState{} }
func (m *SyncState) String() string { return proto.CompactTextString(m) }
func (*SyncState) ProtoMessage()    {}
func (*SyncState) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{25}
}
func (m *SyncState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncState.Merge(m, src)
}
func (m *SyncState) XXX_Size() int {
	return m.Size()
}
func (m *SyncState) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncState.DiscardUnknown(m)
}

var xxx_messageInfo_SyncState proto.InternalMessageInfo

func (m *SyncState) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

type SyncStateResponse struct {
	ReplicaId    uint64        `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	View         uint64        `protobuf:"varint,2,opt,name=view,proto3" json:"view,omitempty"`
	N            uint64        `protobuf:"varint,3,opt,name=n,proto3" json:"n,omitempty"`
	RouterInfo   []byte        `protobuf:"bytes,4,opt,name=router_info,json=routerInfo,proto3" json:"router_info,omitempty"`
	CurrentState *ServiceState `protobuf:"bytes,5,opt,name=current_state,json=currentState,proto3" json:"current_state,omitempty"`
}

func (m *SyncStateResponse) Reset()         { *m = SyncStateResponse{} }
func (m *SyncStateResponse) String() string { return proto.CompactTextString(m) }
func (*SyncStateResponse) ProtoMessage()    {}
func (*SyncStateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{26}
}
func (m *SyncStateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncStateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncStateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncStateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncStateResponse.Merge(m, src)
}
func (m *SyncStateResponse) XXX_Size() int {
	return m.Size()
}
func (m *SyncStateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncStateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SyncStateResponse proto.InternalMessageInfo

func (m *SyncStateResponse) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

func (m *SyncStateResponse) GetView() uint64 {
	if m != nil {
		return m.View
	}
	return 0
}

func (m *SyncStateResponse) GetN() uint64 {
	if m != nil {
		return m.N
	}
	return 0
}

func (m *SyncStateResponse) GetRouterInfo() []byte {
	if m != nil {
		return m.RouterInfo
	}
	return nil
}

func (m *SyncStateResponse) GetCurrentState() *ServiceState {
	if m != nil {
		return m.CurrentState
	}
	return nil
}

// notification message
type Notification struct {
	Basis     *VcBasis `protobuf:"bytes,1,opt,name=basis,proto3" json:"basis,omitempty"`
	Signature []byte   `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	Timestamp int64    `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReplicaId uint64   `protobuf:"varint,4,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
}

func (m *Notification) Reset()         { *m = Notification{} }
func (m *Notification) String() string { return proto.CompactTextString(m) }
func (*Notification) ProtoMessage()    {}
func (*Notification) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{27}
}
func (m *Notification) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Notification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Notification.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Notification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Notification.Merge(m, src)
}
func (m *Notification) XXX_Size() int {
	return m.Size()
}
func (m *Notification) XXX_DiscardUnknown() {
	xxx_messageInfo_Notification.DiscardUnknown(m)
}

var xxx_messageInfo_Notification proto.InternalMessageInfo

func (m *Notification) GetBasis() *VcBasis {
	if m != nil {
		return m.Basis
	}
	return nil
}

func (m *Notification) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *Notification) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Notification) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

type NotificationResponse struct {
	Basis      *VcBasis `protobuf:"bytes,1,opt,name=basis,proto3" json:"basis,omitempty"`
	N          uint64   `protobuf:"varint,2,opt,name=n,proto3" json:"n,omitempty"`
	RouterInfo []byte   `protobuf:"bytes,3,opt,name=router_info,json=routerInfo,proto3" json:"router_info,omitempty"`
	ReplicaId  uint64   `protobuf:"varint,4,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
}

func (m *NotificationResponse) Reset()         { *m = NotificationResponse{} }
func (m *NotificationResponse) String() string { return proto.CompactTextString(m) }
func (*NotificationResponse) ProtoMessage()    {}
func (*NotificationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{28}
}
func (m *NotificationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotificationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NotificationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NotificationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotificationResponse.Merge(m, src)
}
func (m *NotificationResponse) XXX_Size() int {
	return m.Size()
}
func (m *NotificationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NotificationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NotificationResponse proto.InternalMessageInfo

func (m *NotificationResponse) GetBasis() *VcBasis {
	if m != nil {
		return m.Basis
	}
	return nil
}

func (m *NotificationResponse) GetN() uint64 {
	if m != nil {
		return m.N
	}
	return 0
}

func (m *NotificationResponse) GetRouterInfo() []byte {
	if m != nil {
		return m.RouterInfo
	}
	return nil
}

func (m *NotificationResponse) GetReplicaId() uint64 {
	if m != nil {
		return m.ReplicaId
	}
	return 0
}

type Peer struct {
	Id      uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Context []byte `protobuf:"bytes,2,opt,name=context,proto3" json:"context,omitempty"`
}

func (m *Peer) Reset()         { *m = Peer{} }
func (m *Peer) String() string { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()    {}
func (*Peer) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{29}
}
func (m *Peer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Peer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Peer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Peer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Peer.Merge(m, src)
}
func (m *Peer) XXX_Size() int {
	return m.Size()
}
func (m *Peer) XXX_DiscardUnknown() {
	xxx_messageInfo_Peer.DiscardUnknown(m)
}

var xxx_messageInfo_Peer proto.InternalMessageInfo

func (m *Peer) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Peer) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

type Router struct {
	Peers []*Peer `protobuf:"bytes,1,rep,name=peers,proto3" json:"peers,omitempty"`
}

func (m *Router) Reset()         { *m = Router{} }
func (m *Router) String() string { return proto.CompactTextString(m) }
func (*Router) ProtoMessage()    {}
func (*Router) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{30}
}
func (m *Router) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Router) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Router.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Router) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Router.Merge(m, src)
}
func (m *Router) XXX_Size() int {
	return m.Size()
}
func (m *Router) XXX_DiscardUnknown() {
	xxx_messageInfo_Router.DiscardUnknown(m)
}

var xxx_messageInfo_Router proto.InternalMessageInfo

func (m *Router) GetPeers() []*Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

type ConfChange struct {
	NodeID          uint64          `protobuf:"varint,1,opt,name=NodeID,proto3" json:"NodeID,omitempty"`
	Type            ConfChangeType  `protobuf:"varint,2,opt,name=type,proto3,enum=rbftpb.ConfChangeType" json:"type,omitempty"`
	Context         []byte          `protobuf:"bytes,3,opt,name=context,proto3" json:"context,omitempty"`
	VerifiedReplica map[uint64]bool `protobuf:"bytes,4,rep,name=verified_replica,json=verifiedReplica,proto3" json:"verified_replica,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *ConfChange) Reset()         { *m = ConfChange{} }
func (m *ConfChange) String() string { return proto.CompactTextString(m) }
func (*ConfChange) ProtoMessage()    {}
func (*ConfChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{31}
}
func (m *ConfChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfChange.Merge(m, src)
}
func (m *ConfChange) XXX_Size() int {
	return m.Size()
}
func (m *ConfChange) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfChange.DiscardUnknown(m)
}

var xxx_messageInfo_ConfChange proto.InternalMessageInfo

func (m *ConfChange) GetNodeID() uint64 {
	if m != nil {
		return m.NodeID
	}
	return 0
}

func (m *ConfChange) GetType() ConfChangeType {
	if m != nil {
		return m.Type
	}
	return ConfChangeType_ConfChangeAddNode
}

func (m *ConfChange) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *ConfChange) GetVerifiedReplica() map[uint64]bool {
	if m != nil {
		return m.VerifiedReplica
	}
	return nil
}

type ConfState struct {
	QuorumRouter *Router `protobuf:"bytes,1,opt,name=quorum_router,json=quorumRouter,proto3" json:"quorum_router,omitempty"`
}

func (m *ConfState) Reset()         { *m = ConfState{} }
func (m *ConfState) String() string { return proto.CompactTextString(m) }
func (*ConfState) ProtoMessage()    {}
func (*ConfState) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{32}
}
func (m *ConfState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfState.Merge(m, src)
}
func (m *ConfState) XXX_Size() int {
	return m.Size()
}
func (m *ConfState) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfState.DiscardUnknown(m)
}

var xxx_messageInfo_ConfState proto.InternalMessageInfo

func (m *ConfState) GetQuorumRouter() *Router {
	if m != nil {
		return m.QuorumRouter
	}
	return nil
}

type ServiceState struct {
	Applied uint64 `protobuf:"varint,1,opt,name=applied,proto3" json:"applied,omitempty"`
	Digest  string `protobuf:"bytes,2,opt,name=digest,proto3" json:"digest,omitempty"`
}

func (m *ServiceState) Reset()         { *m = ServiceState{} }
func (m *ServiceState) String() string { return proto.CompactTextString(m) }
func (*ServiceState) ProtoMessage()    {}
func (*ServiceState) Descriptor() ([]byte, []int) {
	return fileDescriptor_4294ee733f83ad1d, []int{33}
}
func (m *ServiceState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceState.Merge(m, src)
}
func (m *ServiceState) XXX_Size() int {
	return m.Size()
}
func (m *ServiceState) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceState.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceState proto.InternalMessageInfo

func (m *ServiceState) GetApplied() uint64 {
	if m != nil {
		return m.Applied
	}
	return 0
}

func (m *ServiceState) GetDigest() string {
	if m != nil {
		return m.Digest
	}
	return ""
}

func init() {
	proto.RegisterEnum("rbftpb.Type", Type_name, Type_value)
	proto.RegisterEnum("rbftpb.ConfChangeType", ConfChangeType_name, ConfChangeType_value)
	proto.RegisterEnum("rbftpb.InformType", InformType_name, InformType_value)
	proto.RegisterType((*ConsensusMessage)(nil), "rbftpb.consensus_message")
	proto.RegisterType((*RequestBatch)(nil), "rbftpb.request_batch")
	proto.RegisterType((*HashBatch)(nil), "rbftpb.hash_batch")
	proto.RegisterType((*SendRequestBatch)(nil), "rbftpb.send_request_batch")
	proto.RegisterType((*FetchMissingRequests)(nil), "rbftpb.fetch_missing_requests")
	proto.RegisterMapType((map[uint64]string)(nil), "rbftpb.fetch_missing_requests.MissingRequestHashesEntry")
	proto.RegisterType((*SendMissingRequests)(nil), "rbftpb.send_missing_requests")
	proto.RegisterMapType((map[uint64]string)(nil), "rbftpb.send_missing_requests.MissingRequestHashesEntry")
	proto.RegisterMapType((map[uint64]*protos.Transaction)(nil), "rbftpb.send_missing_requests.MissingRequestsEntry")
	proto.RegisterType((*RequestSet)(nil), "rbftpb.request_set")
	proto.RegisterType((*NullRequest)(nil), "rbftpb.null_request")
	proto.RegisterType((*PrePrepare)(nil), "rbftpb.pre_prepare")
	proto.RegisterType((*Prepare)(nil), "rbftpb.prepare")
	proto.RegisterType((*Commit)(nil), "rbftpb.commit")
	proto.RegisterType((*Checkpoint)(nil), "rbftpb.checkpoint")
	proto.RegisterType((*Vc_C)(nil), "rbftpb.vc_C")
	proto.RegisterType((*Vc_PQ)(nil), "rbftpb.vc_PQ")
	proto.RegisterType((*VcBasis)(nil), "rbftpb.vc_basis")
	proto.RegisterType((*ViewChange)(nil), "rbftpb.view_change")
	proto.RegisterType((*NewView)(nil), "rbftpb.new_view")
	proto.RegisterMapType((map[uint64]string)(nil), "rbftpb.new_view.XsetEntry")
	proto.RegisterType((*FetchRequestBatch)(nil), "rbftpb.fetch_request_batch")
	proto.RegisterType((*RecoveryFetchPQC)(nil), "rbftpb.recovery_fetchPQC")
	proto.RegisterType((*RecoveryReturnPQC)(nil), "rbftpb.recovery_returnPQC")
	proto.RegisterType((*Pset)(nil), "rbftpb.Pset")
	proto.RegisterType((*Cset)(nil), "rbftpb.Cset")
	proto.RegisterType((*ReadyForN)(nil), "rbftpb.ready_for_n")
	proto.RegisterType((*AgreeUpdateN)(nil), "rbftpb.agree_update_n")
	proto.RegisterType((*UpdateN)(nil), "rbftpb.update_n")
	proto.RegisterMapType((map[uint64]string)(nil), "rbftpb.update_n.XsetEntry")
	proto.RegisterType((*SyncState)(nil), "rbftpb.sync_state")
	proto.RegisterType((*SyncStateResponse)(nil), "rbftpb.sync_state_response")
	proto.RegisterType((*Notification)(nil), "rbftpb.notification")
	proto.RegisterType((*NotificationResponse)(nil), "rbftpb.notification_response")
	proto.RegisterType((*Peer)(nil), "rbftpb.peer")
	proto.RegisterType((*Router)(nil), "rbftpb.router")
	proto.RegisterType((*ConfChange)(nil), "rbftpb.conf_change")
	proto.RegisterMapType((map[uint64]bool)(nil), "rbftpb.conf_change.VerifiedReplicaEntry")
	proto.RegisterType((*ConfState)(nil), "rbftpb.conf_state")
	proto.RegisterType((*ServiceState)(nil), "rbftpb.service_state")
}

func init() { proto.RegisterFile("rbft.proto", fileDescriptor_4294ee733f83ad1d) }

var fileDescriptor_4294ee733f83ad1d = []byte{
	// 1926 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0x4f, 0x6f, 0x23, 0x49,
	0x15, 0x4f, 0xdb, 0x6d, 0xc7, 0x7e, 0x76, 0x92, 0x9e, 0xca, 0x9f, 0xf5, 0x04, 0x26, 0x64, 0x5b,
	0x88, 0xf5, 0xce, 0xee, 0x26, 0x90, 0x95, 0xd8, 0xd5, 0x5e, 0xc0, 0x71, 0x3a, 0x89, 0xc5, 0x8c,
	0xe3, 0x94, 0x9d, 0x19, 0xe6, 0xb0, 0x2a, 0x75, 0xda, 0x65, 0xbb, 0x35, 0x76, 0xb5, 0xd3, 0x55,
	0xf6, 0x4c, 0xce, 0x48, 0x0b, 0x17, 0x24, 0x38, 0xc2, 0x37, 0xe0, 0x8c, 0xb8, 0x70, 0xe1, 0xca,
	0x81, 0xc3, 0x1c, 0x39, 0xa2, 0x19, 0x89, 0x8f, 0x81, 0x50, 0x55, 0x75, 0xfb, 0x5f, 0x1c, 0x3c,
	0x19, 0x01, 0x3b, 0xb7, 0xae, 0xf7, 0x5e, 0xbd, 0xf7, 0xab, 0x5f, 0xbd, 0xf7, 0xaa, 0xaa, 0x01,
	0xc2, 0xcb, 0x96, 0xd8, 0xeb, 0x87, 0x81, 0x08, 0x50, 0x5a, 0x7e, 0xf7, 0x2f, 0xb7, 0x7f, 0xd2,
	0xf6, 0x45, 0x67, 0x70, 0xb9, 0xe7, 0x05, 0xbd, 0xfd, 0x41, 0x57, 0x84, 0x6e, 0x8f, 0xf2, 0xce,
	0x7e, 0xab, 0xeb, 0x8a, 0xe0, 0x33, 0x3a, 0xa4, 0x4c, 0xec, 0xfb, 0x8c, 0xd1, 0x70, 0x5f, 0xcd,
	0xe2, 0xfb, 0x22, 0x74, 0x19, 0x77, 0x3d, 0xe1, 0x07, 0x4c, 0x3b, 0xb2, 0x39, 0xdc, 0xf3, 0x02,
	0xc6, 0x29, 0xe3, 0x03, 0x4e, 0x7a, 0x94, 0x73, 0xb7, 0x4d, 0xd1, 0x2e, 0x98, 0xe2, 0xba, 0x4f,
	0x0b, 0xc6, 0xae, 0x51, 0x5c, 0x3d, 0xc8, 0xef, 0xe9, 0x60, 0x7b, 0x8d, 0xeb, 0x3e, 0xc5, 0x4a,
	0x83, 0x10, 0x98, 0xad, 0x30, 0xe8, 0x15, 0x12, 0xbb, 0x46, 0xd1, 0xc4, 0xea, 0x1b, 0xad, 0x42,
	0x42, 0x04, 0x85, 0xa4, 0x92, 0x24, 0x44, 0x80, 0x0a, 0xb0, 0xdc, 0x77, 0xaf, 0xbb, 0x81, 0xdb,
	0x2c, 0x98, 0xbb, 0x46, 0x31, 0x8f, 0xe3, 0xa1, 0xfd, 0x4f, 0x03, 0x56, 0x42, 0x7a, 0x35, 0xa0,
	0x5c, 0x90, 0x4b, 0x57, 0x78, 0x1d, 0xf4, 0x10, 0xee, 0xc5, 0x82, 0x8e, 0xcb, 0x3b, 0xa4, 0xeb,
	0x73, 0x51, 0x30, 0x76, 0x93, 0xc5, 0x2c, 0x5e, 0x8b, 0x14, 0xa7, 0x2e, 0xef, 0x3c, 0xf2, 0xb9,
	0x40, 0x3f, 0x86, 0x7c, 0x6c, 0xab, 0xcc, 0x12, 0xbb, 0xc9, 0x62, 0xee, 0x60, 0x5d, 0x2f, 0x88,
	0xef, 0x35, 0xc6, 0x6b, 0xc4, 0xb9, 0xc8, 0x50, 0xcd, 0xfb, 0x2e, 0x64, 0x85, 0xdf, 0xa3, 0x5c,
	0xb8, 0xbd, 0xbe, 0x82, 0x99, 0xc4, 0x63, 0x01, 0xda, 0x84, 0x34, 0xa7, 0x57, 0x84, 0x05, 0x0a,
	0xac, 0x89, 0x53, 0x9c, 0x5e, 0x55, 0x03, 0xf4, 0x00, 0xa0, 0x1b, 0x78, 0x6e, 0x57, 0x87, 0x4a,
	0xed, 0x26, 0x8b, 0x19, 0x9c, 0x55, 0x12, 0xe5, 0xf3, 0x01, 0x80, 0x5a, 0x80, 0x42, 0x5d, 0x48,
	0xef, 0x1a, 0xc5, 0x2c, 0xce, 0x2a, 0x89, 0x84, 0x6b, 0xff, 0xde, 0x00, 0x50, 0xeb, 0xb9, 0xfb,
	0x2a, 0x0f, 0x61, 0xa7, 0x49, 0x49, 0x73, 0xd0, 0xef, 0xfa, 0x9e, 0x2b, 0x28, 0xb9, 0x39, 0x31,
	0xa1, 0x26, 0x6e, 0x37, 0xe9, 0x51, 0x6c, 0x84, 0x67, 0x7c, 0xfc, 0xc7, 0x15, 0xdb, 0xbf, 0x30,
	0x00, 0x71, 0xca, 0x9a, 0x64, 0x7a, 0x2b, 0x1e, 0x00, 0x84, 0x54, 0x39, 0x24, 0x7e, 0x53, 0xa5,
	0x80, 0x89, 0xb3, 0x91, 0xa4, 0xd2, 0x44, 0x9f, 0x40, 0x4a, 0xd9, 0xa9, 0xad, 0xcf, 0x1d, 0x6c,
	0xc6, 0xc9, 0x31, 0xe5, 0x04, 0x6b, 0x1b, 0xf4, 0x21, 0xe4, 0x35, 0x3d, 0x4d, 0xbf, 0x4d, 0xb9,
	0x50, 0x18, 0xb2, 0x38, 0xa7, 0x64, 0x47, 0x4a, 0x64, 0xbf, 0x4a, 0xc0, 0x56, 0x8b, 0x4a, 0x9b,
	0x9e, 0xcf, 0xb9, 0xcf, 0xda, 0x31, 0x1c, 0xbe, 0x08, 0x09, 0x02, 0x73, 0xe8, 0xd3, 0x17, 0x71,
	0x0e, 0xca, 0x6f, 0xf4, 0x11, 0xac, 0x71, 0x39, 0x9d, 0x79, 0x94, 0xb0, 0x41, 0xef, 0x92, 0x86,
	0x51, 0x42, 0xae, 0xc6, 0xe2, 0xaa, 0x92, 0xde, 0x40, 0x66, 0xde, 0x40, 0x86, 0x18, 0x6c, 0xcd,
	0x40, 0x52, 0xe4, 0x53, 0xae, 0xd2, 0x20, 0x77, 0xf0, 0x65, 0xbc, 0xf4, 0xf9, 0xf0, 0xf7, 0x1e,
	0x6b, 0xc1, 0xc4, 0xa6, 0x50, 0xee, 0x30, 0x11, 0x5e, 0xe3, 0x8d, 0xde, 0x1c, 0xd5, 0xf6, 0x09,
	0xdc, 0xbf, 0x75, 0x0a, 0xb2, 0x20, 0xf9, 0x9c, 0x5e, 0x47, 0x24, 0xc8, 0x4f, 0xb4, 0x01, 0xa9,
	0xa1, 0xdb, 0x1d, 0x50, 0xb5, 0xfe, 0x2c, 0xd6, 0x83, 0xaf, 0x12, 0x5f, 0x1a, 0xf6, 0x37, 0x26,
	0x6c, 0xaa, 0x8d, 0x7d, 0xdf, 0x18, 0xed, 0x2d, 0x60, 0xf4, 0x8b, 0x98, 0xd1, 0xb9, 0xe8, 0xef,
	0x4a, 0x28, 0xfa, 0x1a, 0xac, 0x59, 0x1f, 0x85, 0xb4, 0x0a, 0x74, 0x70, 0x97, 0x40, 0x51, 0x8c,
	0xb5, 0xe9, 0x18, 0xff, 0xbd, 0xfd, 0xda, 0x7e, 0x0a, 0x1b, 0xf3, 0x22, 0xce, 0xf1, 0xf1, 0xf1,
	0xa4, 0x8f, 0x5b, 0x7a, 0xde, 0x44, 0x22, 0x34, 0x20, 0x6e, 0x80, 0x84, 0x53, 0x81, 0xf6, 0x21,
	0x33, 0xe2, 0xc1, 0xb8, 0xbd, 0x69, 0x8e, 0x8c, 0x24, 0x64, 0xd5, 0xea, 0x54, 0xb8, 0x0c, 0xd6,
	0x03, 0xfb, 0x33, 0xc8, 0xb3, 0x41, 0xb7, 0x1b, 0xd3, 0xb5, 0x20, 0xa9, 0xec, 0xbf, 0x18, 0x90,
	0xeb, 0x87, 0x94, 0xf4, 0x43, 0xda, 0x77, 0x43, 0xfa, 0x6d, 0xe7, 0xe0, 0x8f, 0x26, 0x3b, 0x72,
	0x21, 0xa5, 0x78, 0x44, 0x71, 0x3a, 0x8c, 0x35, 0x38, 0x2b, 0xbf, 0x0f, 0xe5, 0xa7, 0xfd, 0x2b,
	0x03, 0x96, 0xdf, 0x0f, 0xf4, 0xf6, 0x2f, 0x0d, 0x48, 0x7b, 0x41, 0xaf, 0xe7, 0x8b, 0x6f, 0x1b,
	0x49, 0x17, 0xc0, 0xeb, 0x50, 0xef, 0x79, 0x3f, 0xf0, 0xd9, 0x42, 0x30, 0x73, 0x02, 0x27, 0xe6,
	0x06, 0xde, 0x82, 0xf4, 0xd4, 0x51, 0x11, 0x8d, 0xec, 0x13, 0x30, 0x87, 0x1e, 0x29, 0xcf, 0x73,
	0x64, 0x2c, 0x70, 0x94, 0x98, 0x72, 0xd4, 0x86, 0xd4, 0xd0, 0x23, 0xb5, 0xf3, 0xb7, 0xf7, 0x34,
	0xcb, 0x45, 0xe2, 0x66, 0x4e, 0xc5, 0x5c, 0x27, 0xc7, 0x5c, 0xdb, 0x7f, 0x34, 0x20, 0x33, 0xf4,
	0xc8, 0xa5, 0xcb, 0xfd, 0x77, 0xea, 0xbb, 0x79, 0x30, 0x3a, 0x91, 0x43, 0xa3, 0x23, 0x6f, 0x64,
	0x1e, 0xa7, 0x72, 0x23, 0x64, 0xd9, 0x8e, 0x6e, 0x64, 0x92, 0x13, 0xac, 0x34, 0xe8, 0x43, 0x30,
	0xfb, 0xd2, 0x42, 0x77, 0xd2, 0x95, 0x09, 0x8b, 0xda, 0x39, 0x56, 0x2a, 0x69, 0x72, 0x25, 0x4d,
	0xd2, 0x73, 0x4d, 0xa4, 0xca, 0xbe, 0x82, 0x9c, 0x8c, 0x4e, 0xbc, 0x8e, 0xcb, 0xda, 0x14, 0xfd,
	0x40, 0x1e, 0xf6, 0xdc, 0xe7, 0x0a, 0x72, 0xee, 0xc0, 0x9a, 0x98, 0xa2, 0xe4, 0x58, 0xab, 0xe5,
	0x45, 0x83, 0xfb, 0x6d, 0xe6, 0x8a, 0x41, 0xa8, 0x7b, 0x53, 0x1e, 0x8f, 0x05, 0x0b, 0xae, 0x21,
	0x7f, 0x33, 0x20, 0xc3, 0xe8, 0x0b, 0xa2, 0x56, 0xfd, 0x0e, 0x44, 0xed, 0x81, 0xf9, 0x52, 0xae,
	0x2a, 0xa9, 0x56, 0xb5, 0x1d, 0x43, 0x8c, 0x5d, 0xee, 0xfd, 0x9c, 0x53, 0xa1, 0x3b, 0xb8, 0xb2,
	0x43, 0xdf, 0x07, 0xf3, 0x72, 0x4c, 0xe5, 0xcd, 0x25, 0x29, 0xed, 0xf6, 0x17, 0x90, 0x1d, 0x4d,
	0xbc, 0xd3, 0xe1, 0xfb, 0x14, 0xd6, 0xf5, 0x7d, 0xe0, 0x4e, 0xb7, 0xaa, 0xc5, 0x49, 0x66, 0xff,
	0x54, 0x5e, 0x1e, 0xbd, 0x60, 0x48, 0xc3, 0x6b, 0xa2, 0x22, 0xd4, 0xce, 0xcb, 0x8b, 0xdc, 0xaa,
	0x24, 0x4a, 0x44, 0x49, 0x64, 0xff, 0xd9, 0x00, 0x34, 0x72, 0x11, 0x52, 0x31, 0x08, 0xd9, 0x5b,
	0xf8, 0x38, 0x00, 0x90, 0xcd, 0x2f, 0xa4, 0xf2, 0x0c, 0x19, 0x5d, 0xb6, 0x23, 0xd6, 0x26, 0x1a,
	0x3b, 0xce, 0x6a, 0xb3, 0x3a, 0x15, 0xa8, 0xa8, 0x1a, 0x26, 0x19, 0x6f, 0xcb, 0xda, 0xc4, 0x04,
	0x65, 0x9c, 0x8e, 0x2c, 0x3f, 0x82, 0x65, 0xaf, 0xa7, 0x8e, 0xa7, 0x68, 0x43, 0x56, 0x63, 0x4b,
	0xdd, 0xe6, 0x70, 0xda, 0xeb, 0x89, 0x3a, 0x15, 0xf6, 0xc7, 0x60, 0xd6, 0x74, 0x12, 0x27, 0xa5,
	0xb1, 0x31, 0xdf, 0xad, 0xd4, 0xd9, 0x45, 0x30, 0xcb, 0xd2, 0x74, 0x77, 0xd2, 0x74, 0xd6, 0xaf,
	0xb2, 0x7c, 0x2e, 0x0f, 0x48, 0xb7, 0x79, 0x4d, 0x5a, 0x41, 0x48, 0xd8, 0x22, 0x26, 0x6c, 0x58,
	0x91, 0x59, 0xc5, 0x82, 0x26, 0x25, 0x3e, 0x6b, 0x05, 0xf1, 0x2e, 0x31, 0xfa, 0xa2, 0x1a, 0x34,
	0x69, 0x85, 0xb5, 0x02, 0x74, 0x1f, 0x32, 0xf4, 0x65, 0x9f, 0x7a, 0x82, 0xb0, 0xa8, 0x7a, 0x97,
	0xf5, 0xb8, 0x6a, 0xff, 0xce, 0x80, 0x55, 0xb7, 0x1d, 0x52, 0x4a, 0x06, 0xfd, 0xa6, 0xbc, 0xd2,
	0xb3, 0xb7, 0xae, 0x2f, 0xf9, 0xdc, 0xea, 0xba, 0xed, 0xe8, 0x1c, 0x56, 0xdf, 0xf2, 0xb9, 0xe5,
	0x37, 0xe3, 0xe7, 0x96, 0xaf, 0x6a, 0x43, 0x81, 0xd2, 0xbd, 0x5a, 0x7d, 0xcb, 0xfd, 0x67, 0xea,
	0x8c, 0x4b, 0x62, 0x83, 0x4d, 0x61, 0x4b, 0x4f, 0x63, 0xfb, 0x97, 0x01, 0x99, 0x11, 0xaa, 0x38,
	0x9a, 0x31, 0x11, 0x6d, 0x9a, 0x9a, 0xc4, 0x2c, 0x35, 0xb3, 0x60, 0x54, 0x60, 0x33, 0x0e, 0x1c,
	0x97, 0x6d, 0x6a, 0x4e, 0xd9, 0xa6, 0xa7, 0xcb, 0x36, 0x06, 0x71, 0x6b, 0xd9, 0x2e, 0xff, 0x6f,
	0xca, 0xf6, 0x13, 0x00, 0x7e, 0xcd, 0x3c, 0xc2, 0x85, 0x2b, 0x16, 0x9d, 0xf2, 0xb2, 0xb7, 0xaf,
	0x8f, 0xad, 0x49, 0x48, 0x79, 0x5f, 0xbe, 0xa1, 0xdf, 0xb1, 0xcd, 0xc7, 0x89, 0x62, 0x30, 0xf4,
	0x3d, 0xc8, 0x85, 0xc1, 0x40, 0xd0, 0x90, 0x8c, 0xb6, 0x32, 0x8f, 0x41, 0x8b, 0x54, 0x7a, 0x7d,
	0x05, 0x2b, 0xde, 0x20, 0x0c, 0x29, 0x13, 0x3a, 0x76, 0x74, 0x81, 0xd9, 0x1c, 0xdf, 0x67, 0xc3,
	0xa1, 0xef, 0x51, 0xad, 0xc4, 0xf9, 0xc8, 0xb6, 0x2e, 0x47, 0xf6, 0x6f, 0x0d, 0xc8, 0xb3, 0x40,
	0xf8, 0x2d, 0xf9, 0x56, 0xf4, 0x03, 0xf6, 0xff, 0xe8, 0xee, 0x33, 0x94, 0x98, 0xb3, 0x4c, 0xfe,
	0xda, 0x80, 0xcd, 0x49, 0x4c, 0x63, 0x2e, 0xdf, 0x16, 0x9c, 0x22, 0x30, 0x71, 0x0b, 0x81, 0xc9,
	0x1b, 0x04, 0x2e, 0xc0, 0xf3, 0x43, 0x30, 0xfb, 0x94, 0x86, 0x51, 0x3e, 0x1b, 0xa3, 0x7c, 0x2e,
	0xc0, 0xb2, 0x17, 0x30, 0x41, 0x5f, 0x8a, 0x88, 0x80, 0x78, 0x68, 0x7f, 0x0a, 0x69, 0xed, 0x1e,
	0xd9, 0x90, 0x92, 0x73, 0xe3, 0xbb, 0xf5, 0xe8, 0x90, 0x96, 0x42, 0xac, 0x55, 0xf6, 0x37, 0x09,
	0xc8, 0x79, 0x01, 0x6b, 0xc5, 0x07, 0xec, 0x16, 0xa4, 0x55, 0xeb, 0x38, 0x8a, 0x62, 0x45, 0x23,
	0xf4, 0x69, 0xf4, 0x07, 0x26, 0xa1, 0xfe, 0xc0, 0x14, 0xc6, 0xbd, 0x6b, 0x34, 0x95, 0x88, 0xf1,
	0xdf, 0x98, 0x09, 0x74, 0xc9, 0x29, 0x74, 0xa8, 0x0e, 0xd6, 0x90, 0x86, 0x7e, 0xcb, 0xa7, 0xf2,
	0x99, 0xaf, 0x56, 0x19, 0xf5, 0xd9, 0xe2, 0x1c, 0x9f, 0x7b, 0x4f, 0x22, 0x5b, 0xac, 0x4d, 0xa3,
	0x87, 0xcf, 0x70, 0x5a, 0xba, 0x7d, 0x08, 0x1b, 0xf3, 0x0c, 0x17, 0xd5, 0x5b, 0x66, 0xb2, 0xde,
	0x4a, 0x00, 0x2a, 0xb0, 0xae, 0xb7, 0xcf, 0x61, 0xe5, 0x6a, 0x10, 0x84, 0x83, 0x1e, 0xd1, 0x5c,
	0x46, 0x9b, 0x3e, 0xea, 0xd9, 0x5a, 0x8a, 0xf3, 0xda, 0x08, 0xab, 0x91, 0x5d, 0x82, 0x95, 0xa9,
	0x74, 0x97, 0x34, 0xb8, 0xfd, 0x7e, 0xd7, 0xa7, 0xf1, 0xce, 0xc5, 0xc3, 0xdb, 0x6e, 0x83, 0x0f,
	0xff, 0x94, 0x04, 0xb3, 0x21, 0x19, 0xb4, 0x20, 0x5f, 0xbd, 0x78, 0xf4, 0x88, 0x60, 0xe7, 0xfc,
	0xc2, 0xa9, 0x37, 0xac, 0x25, 0xb4, 0x06, 0xb9, 0x1a, 0x76, 0x48, 0x0d, 0x3b, 0xb5, 0x12, 0x76,
	0x2c, 0x03, 0xe5, 0x60, 0x39, 0x1e, 0x24, 0x10, 0x40, 0xba, 0x7c, 0xf6, 0xf8, 0x71, 0xa5, 0x61,
	0x25, 0xd1, 0x2a, 0x40, 0xf9, 0xd4, 0x29, 0xff, 0xac, 0x76, 0x56, 0xa9, 0x36, 0x2c, 0x53, 0xce,
	0x7c, 0x52, 0x71, 0x9e, 0x92, 0xf2, 0x69, 0xa9, 0x7a, 0xe2, 0x58, 0x29, 0x94, 0x87, 0x4c, 0xd5,
	0x79, 0x4a, 0xa4, 0xd0, 0x4a, 0xa3, 0x0f, 0x60, 0xfd, 0xd8, 0x69, 0x94, 0x4f, 0xe3, 0x58, 0xe4,
	0xb0, 0xd4, 0x28, 0x9f, 0x5a, 0xcb, 0x68, 0x0b, 0x50, 0xdd, 0xa9, 0x1e, 0xcd, 0xc8, 0x33, 0x52,
	0x8e, 0x9d, 0xf2, 0xd9, 0x13, 0x07, 0x3f, 0x23, 0x7a, 0xe6, 0x79, 0xad, 0x6c, 0x65, 0xa5, 0xa3,
	0x91, 0x1c, 0x3b, 0x8d, 0x0b, 0x5c, 0x55, 0x0a, 0x90, 0x00, 0xb0, 0x53, 0x3a, 0x7a, 0x46, 0x8e,
	0xcf, 0x30, 0xa9, 0x5a, 0x39, 0x84, 0x60, 0xb5, 0x74, 0x82, 0x1d, 0x87, 0x5c, 0xd4, 0x8e, 0x4a,
	0x0d, 0x87, 0x54, 0xad, 0xbc, 0x04, 0x35, 0x1a, 0xad, 0xa0, 0x6d, 0xd8, 0xd2, 0xae, 0x1f, 0x57,
	0xea, 0xf5, 0x4a, 0xf5, 0x24, 0x06, 0x51, 0xb7, 0x56, 0xd1, 0x7d, 0xd8, 0x54, 0xb8, 0x6e, 0xa8,
	0xd6, 0xe4, 0xd2, 0xeb, 0xcf, 0xaa, 0x65, 0x52, 0x6f, 0x94, 0x1a, 0x8e, 0x65, 0x49, 0x48, 0xe3,
	0x31, 0xc1, 0x4e, 0xbd, 0x76, 0x56, 0xad, 0x3b, 0xd6, 0x3d, 0xc5, 0xef, 0x59, 0xa3, 0x72, 0x5c,
	0x29, 0x97, 0x1a, 0x95, 0xb3, 0xaa, 0x85, 0xa4, 0xd7, 0x49, 0xc9, 0xd8, 0x78, 0x5d, 0xe2, 0x2f,
	0x9f, 0x55, 0x8f, 0x63, 0x02, 0x37, 0xf4, 0x82, 0x34, 0x29, 0x75, 0xa7, 0x61, 0x6d, 0x3e, 0xfc,
	0x1a, 0xac, 0xd9, 0x52, 0x40, 0x9b, 0x70, 0xaf, 0x1c, 0xb0, 0x56, 0x59, 0x89, 0x4a, 0xcd, 0xa6,
	0xac, 0x24, 0x6b, 0x09, 0x15, 0x60, 0x63, 0x2c, 0xc6, 0xb4, 0x17, 0x0c, 0xa9, 0xd2, 0x18, 0xd3,
	0x9a, 0x0b, 0x75, 0xee, 0x28, 0x4d, 0xe2, 0xe1, 0x1f, 0x0c, 0xc8, 0xc9, 0xfe, 0x11, 0xf6, 0x48,
	0x54, 0x5f, 0x1b, 0xc7, 0x7e, 0x57, 0xd0, 0xf0, 0xd8, 0x67, 0x3e, 0xef, 0xe0, 0xe8, 0x0e, 0x65,
	0x2d, 0x29, 0xde, 0x26, 0x34, 0x4f, 0x7c, 0xfa, 0x42, 0xfb, 0xb3, 0x0c, 0xb5, 0xd1, 0x13, 0xba,
	0x28, 0x82, 0x95, 0x40, 0xdf, 0x81, 0x0f, 0x26, 0x15, 0xaa, 0x3b, 0x6b, 0xad, 0x95, 0x94, 0x7b,
	0xa5, 0x95, 0xb5, 0x20, 0xe8, 0x1e, 0x0f, 0xba, 0x5d, 0xcb, 0x1c, 0x47, 0xa9, 0x0b, 0xf7, 0xb2,
	0x4b, 0xcb, 0xa3, 0x77, 0x97, 0x95, 0x3a, 0x2c, 0xfc, 0xf5, 0xf5, 0x8e, 0xf1, 0xea, 0xf5, 0x8e,
	0xf1, 0x8f, 0xd7, 0x3b, 0xc6, 0x6f, 0xde, 0xec, 0x2c, 0xbd, 0x7a, 0xb3, 0xb3, 0xf4, 0xf7, 0x37,
	0x3b, 0x4b, 0x97, 0x69, 0xf5, 0xb6, 0xff, 0xfc, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xc0, 0xdd,
	0x50, 0x59, 0x38, 0x16, 0x00, 0x00,
}

func (m *ConsensusMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Type))
	}
	if m.From != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.From))
	}
	if m.To != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.To))
	}
	if len(m.Payload) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	return i, nil
}

func (m *RequestBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestBatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestHashList) > 0 {
		for _, s := range m.RequestHashList {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.RequestList) > 0 {
		for _, msg := range m.RequestList {
			dAtA[i] = 0x12
			i++
			i = encodeVarintRbft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Timestamp))
	}
	if m.SeqNo != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.SeqNo))
	}
	if len(m.LocalList) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.LocalList)))
		for _, b := range m.LocalList {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.BatchHash) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchHash)))
		i += copy(dAtA[i:], m.BatchHash)
	}
	return i, nil
}

func (m *HashBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HashBatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestHashList) > 0 {
		for _, s := range m.RequestHashList {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DeDuplicateRequestHashList) > 0 {
		for _, s := range m.DeDuplicateRequestHashList {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Timestamp))
	}
	return i, nil
}

func (m *SendRequestBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendRequestBatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if m.Batch != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Batch.Size()))
		n1, err := m.Batch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.BatchDigest) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchDigest)))
		i += copy(dAtA[i:], m.BatchDigest)
	}
	return i, nil
}

func (m *FetchMissingRequests) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchMissingRequests) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if m.View != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
	}
	if m.SequenceNumber != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.SequenceNumber))
	}
	if len(m.BatchDigest) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchDigest)))
		i += copy(dAtA[i:], m.BatchDigest)
	}
	if len(m.MissingRequestHashes) > 0 {
		for k := range m.MissingRequestHashes {
			dAtA[i] = 0x2a
			i++
			v := m.MissingRequestHashes[k]
			mapSize := 1 + sovRbft(uint64(k)) + 1 + len(v) + sovRbft(uint64(len(v)))
			i = encodeVarintRbft(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintRbft(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintRbft(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *SendMissingRequests) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendMissingRequests) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if m.View != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
	}
	if m.SequenceNumber != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.SequenceNumber))
	}
	if len(m.BatchDigest) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchDigest)))
		i += copy(dAtA[i:], m.BatchDigest)
	}
	if len(m.MissingRequestHashes) > 0 {
		for k := range m.MissingRequestHashes {
			dAtA[i] = 0x2a
			i++
			v := m.MissingRequestHashes[k]
			mapSize := 1 + sovRbft(uint64(k)) + 1 + len(v) + sovRbft(uint64(len(v)))
			i = encodeVarintRbft(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintRbft(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintRbft(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.MissingRequests) > 0 {
		for k := range m.MissingRequests {
			dAtA[i] = 0x32
			i++
			v := m.MissingRequests[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovRbft(uint64(msgSize))
			}
			mapSize := 1 + sovRbft(uint64(k)) + msgSize
			i = encodeVarintRbft(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintRbft(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintRbft(dAtA, i, uint64(v.Size()))
				n2, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n2
			}
		}
	}
	return i, nil
}

func (m *RequestSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, msg := range m.Requests {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRbft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Local {
		dAtA[i] = 0x10
		i++
		if m.Local {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *NullRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NullRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	return i, nil
}

func (m *PrePrepare) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrePrepare) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if m.View != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
	}
	if m.SequenceNumber != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.SequenceNumber))
	}
	if len(m.BatchDigest) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchDigest)))
		i += copy(dAtA[i:], m.BatchDigest)
	}
	if m.HashBatch != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.HashBatch.Size()))
		n3, err := m.HashBatch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *Prepare) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Prepare) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if m.View != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
	}
	if m.SequenceNumber != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.SequenceNumber))
	}
	if len(m.BatchDigest) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchDigest)))
		i += copy(dAtA[i:], m.BatchDigest)
	}
	return i, nil
}

func (m *Commit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Commit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if m.View != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
	}
	if m.SequenceNumber != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.SequenceNumber))
	}
	if len(m.BatchDigest) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchDigest)))
		i += copy(dAtA[i:], m.BatchDigest)
	}
	return i, nil
}

func (m *Checkpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Checkpoint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if m.SequenceNumber != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.SequenceNumber))
	}
	if len(m.Digest) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.Digest)))
		i += copy(dAtA[i:], m.Digest)
	}
	return i, nil
}

func (m *Vc_C) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vc_C) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SequenceNumber != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.SequenceNumber))
	}
	if len(m.Digest) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.Digest)))
		i += copy(dAtA[i:], m.Digest)
	}
	return i, nil
}

func (m *Vc_PQ) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vc_PQ) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SequenceNumber != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.SequenceNumber))
	}
	if len(m.BatchDigest) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchDigest)))
		i += copy(dAtA[i:], m.BatchDigest)
	}
	if m.View != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
	}
	return i, nil
}

func (m *VcBasis) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VcBasis) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if m.View != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
	}
	if m.H != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.H))
	}
	if len(m.Cset) > 0 {
		for _, msg := range m.Cset {
			dAtA[i] = 0x22
			i++
			i = encodeVarintRbft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Pset) > 0 {
		for _, msg := range m.Pset {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintRbft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Qset) > 0 {
		for _, msg := range m.Qset {
			dAtA[i] = 0x32
			i++
			i = encodeVarintRbft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ViewChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewChange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Basis != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Basis.Size()))
		n4, err := m.Basis.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Signature) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Timestamp))
	}
	return i, nil
}

func (m *NewView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewView) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if m.View != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
	}
	if len(m.Xset) > 0 {
		for k := range m.Xset {
			dAtA[i] = 0x1a
			i++
			v := m.Xset[k]
			mapSize := 1 + sovRbft(uint64(k)) + 1 + len(v) + sovRbft(uint64(len(v)))
			i = encodeVarintRbft(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintRbft(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintRbft(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Bset) > 0 {
		for _, msg := range m.Bset {
			dAtA[i] = 0x22
			i++
			i = encodeVarintRbft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FetchRequestBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchRequestBatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if len(m.BatchDigest) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.BatchDigest)))
		i += copy(dAtA[i:], m.BatchDigest)
	}
	return i, nil
}

func (m *RecoveryFetchPQC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryFetchPQC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if m.H != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.H))
	}
	return i, nil
}

func (m *RecoveryReturnPQC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryReturnPQC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if len(m.PrepreSet) > 0 {
		for _, msg := range m.PrepreSet {
			dAtA[i] = 0x12
			i++
			i = encodeVarintRbft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PreSet) > 0 {
		for _, msg := range m.PreSet {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintRbft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CmtSet) > 0 {
		for _, msg := range m.CmtSet {
			dAtA[i] = 0x22
			i++
			i = encodeVarintRbft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Pset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pset) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Set) > 0 {
		for _, msg := range m.Set {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRbft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Cset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cset) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Set) > 0 {
		for _, msg := range m.Set {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRbft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReadyForN) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadyForN) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if len(m.NewNodeInfo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.NewNodeInfo)))
		i += copy(dAtA[i:], m.NewNodeInfo)
	}
	if m.ExpectN != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ExpectN))
	}
	return i, nil
}

func (m *AgreeUpdateN) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AgreeUpdateN) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Basis != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Basis.Size()))
		n5, err := m.Basis.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Flag {
		dAtA[i] = 0x10
		i++
		if m.Flag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Id != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Id))
	}
	if len(m.Info) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.Info)))
		i += copy(dAtA[i:], m.Info)
	}
	if m.N != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.N))
	}
	if m.ExpectN != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ExpectN))
	}
	return i, nil
}

func (m *UpdateN) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateN) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flag {
		dAtA[i] = 0x8
		i++
		if m.Flag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReplicaId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if m.Id != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Id))
	}
	if m.N != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.N))
	}
	if m.View != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
	}
	if len(m.Xset) > 0 {
		for k := range m.Xset {
			dAtA[i] = 0x32
			i++
			v := m.Xset[k]
			mapSize := 1 + sovRbft(uint64(k)) + 1 + len(v) + sovRbft(uint64(len(v)))
			i = encodeVarintRbft(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintRbft(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintRbft(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Bset) > 0 {
		for _, msg := range m.Bset {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintRbft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SyncState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	return i, nil
}

func (m *SyncStateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncStateResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	if m.View != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.View))
	}
	if m.N != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.N))
	}
	if len(m.RouterInfo) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.RouterInfo)))
		i += copy(dAtA[i:], m.RouterInfo)
	}
	if m.CurrentState != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.CurrentState.Size()))
		n6, err := m.CurrentState.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *Notification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Notification) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Basis != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Basis.Size()))
		n7, err := m.Basis.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Signature) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Timestamp))
	}
	if m.ReplicaId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	return i, nil
}

func (m *NotificationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotificationResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Basis != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Basis.Size()))
		n8, err := m.Basis.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.N != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.N))
	}
	if len(m.RouterInfo) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.RouterInfo)))
		i += copy(dAtA[i:], m.RouterInfo)
	}
	if m.ReplicaId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.ReplicaId))
	}
	return i, nil
}

func (m *Peer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Peer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Id))
	}
	if len(m.Context) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.Context)))
		i += copy(dAtA[i:], m.Context)
	}
	return i, nil
}

func (m *Router) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Router) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Peers) > 0 {
		for _, msg := range m.Peers {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRbft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ConfChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfChange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.NodeID))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Type))
	}
	if len(m.Context) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.Context)))
		i += copy(dAtA[i:], m.Context)
	}
	if len(m.VerifiedReplica) > 0 {
		for k := range m.VerifiedReplica {
			dAtA[i] = 0x22
			i++
			v := m.VerifiedReplica[k]
			mapSize := 1 + sovRbft(uint64(k)) + 1 + 1
			i = encodeVarintRbft(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintRbft(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	return i, nil
}

func (m *ConfState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QuorumRouter != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.QuorumRouter.Size()))
		n9, err := m.QuorumRouter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *ServiceState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Applied != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRbft(dAtA, i, uint64(m.Applied))
	}
	if len(m.Digest) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRbft(dAtA, i, uint64(len(m.Digest)))
		i += copy(dAtA[i:], m.Digest)
	}
	return i, nil
}

func encodeVarintRbft(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ConsensusMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovRbft(uint64(m.Type))
	}
	if m.From != 0 {
		n += 1 + sovRbft(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovRbft(uint64(m.To))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *RequestBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RequestHashList) > 0 {
		for _, s := range m.RequestHashList {
			l = len(s)
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if len(m.RequestList) > 0 {
		for _, e := range m.RequestList {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if m.Timestamp != 0 {
		n += 1 + sovRbft(uint64(m.Timestamp))
	}
	if m.SeqNo != 0 {
		n += 1 + sovRbft(uint64(m.SeqNo))
	}
	if len(m.LocalList) > 0 {
		n += 1 + sovRbft(uint64(len(m.LocalList))) + len(m.LocalList)*1
	}
	l = len(m.BatchHash)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *HashBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RequestHashList) > 0 {
		for _, s := range m.RequestHashList {
			l = len(s)
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if len(m.DeDuplicateRequestHashList) > 0 {
		for _, s := range m.DeDuplicateRequestHashList {
			l = len(s)
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if m.Timestamp != 0 {
		n += 1 + sovRbft(uint64(m.Timestamp))
	}
	return n
}

func (m *SendRequestBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.Batch != nil {
		l = m.Batch.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	l = len(m.BatchDigest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *FetchMissingRequests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovRbft(uint64(m.SequenceNumber))
	}
	l = len(m.BatchDigest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	if len(m.MissingRequestHashes) > 0 {
		for k, v := range m.MissingRequestHashes {
			_ = k
			_ = v
			mapEntrySize := 1 + sovRbft(uint64(k)) + 1 + len(v) + sovRbft(uint64(len(v)))
			n += mapEntrySize + 1 + sovRbft(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SendMissingRequests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovRbft(uint64(m.SequenceNumber))
	}
	l = len(m.BatchDigest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	if len(m.MissingRequestHashes) > 0 {
		for k, v := range m.MissingRequestHashes {
			_ = k
			_ = v
			mapEntrySize := 1 + sovRbft(uint64(k)) + 1 + len(v) + sovRbft(uint64(len(v)))
			n += mapEntrySize + 1 + sovRbft(uint64(mapEntrySize))
		}
	}
	if len(m.MissingRequests) > 0 {
		for k, v := range m.MissingRequests {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRbft(uint64(l))
			}
			mapEntrySize := 1 + sovRbft(uint64(k)) + l
			n += mapEntrySize + 1 + sovRbft(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RequestSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if m.Local {
		n += 2
	}
	return n
}

func (m *NullRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	return n
}

func (m *PrePrepare) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovRbft(uint64(m.SequenceNumber))
	}
	l = len(m.BatchDigest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.HashBatch != nil {
		l = m.HashBatch.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *Prepare) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovRbft(uint64(m.SequenceNumber))
	}
	l = len(m.BatchDigest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *Commit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovRbft(uint64(m.SequenceNumber))
	}
	l = len(m.BatchDigest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *Checkpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovRbft(uint64(m.SequenceNumber))
	}
	l = len(m.Digest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *Vc_C) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SequenceNumber != 0 {
		n += 1 + sovRbft(uint64(m.SequenceNumber))
	}
	l = len(m.Digest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *Vc_PQ) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SequenceNumber != 0 {
		n += 1 + sovRbft(uint64(m.SequenceNumber))
	}
	l = len(m.BatchDigest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	return n
}

func (m *VcBasis) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	if m.H != 0 {
		n += 1 + sovRbft(uint64(m.H))
	}
	if len(m.Cset) > 0 {
		for _, e := range m.Cset {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if len(m.Pset) > 0 {
		for _, e := range m.Pset {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if len(m.Qset) > 0 {
		for _, e := range m.Qset {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	return n
}

func (m *ViewChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Basis != nil {
		l = m.Basis.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovRbft(uint64(m.Timestamp))
	}
	return n
}

func (m *NewView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	if len(m.Xset) > 0 {
		for k, v := range m.Xset {
			_ = k
			_ = v
			mapEntrySize := 1 + sovRbft(uint64(k)) + 1 + len(v) + sovRbft(uint64(len(v)))
			n += mapEntrySize + 1 + sovRbft(uint64(mapEntrySize))
		}
	}
	if len(m.Bset) > 0 {
		for _, e := range m.Bset {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	return n
}

func (m *FetchRequestBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	l = len(m.BatchDigest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *RecoveryFetchPQC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.H != 0 {
		n += 1 + sovRbft(uint64(m.H))
	}
	return n
}

func (m *RecoveryReturnPQC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if len(m.PrepreSet) > 0 {
		for _, e := range m.PrepreSet {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if len(m.PreSet) > 0 {
		for _, e := range m.PreSet {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	if len(m.CmtSet) > 0 {
		for _, e := range m.CmtSet {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	return n
}

func (m *Pset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Set) > 0 {
		for _, e := range m.Set {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	return n
}

func (m *Cset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Set) > 0 {
		for _, e := range m.Set {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	return n
}

func (m *ReadyForN) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	l = len(m.NewNodeInfo)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.ExpectN != 0 {
		n += 1 + sovRbft(uint64(m.ExpectN))
	}
	return n
}

func (m *AgreeUpdateN) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Basis != nil {
		l = m.Basis.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.Flag {
		n += 2
	}
	if m.Id != 0 {
		n += 1 + sovRbft(uint64(m.Id))
	}
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.N != 0 {
		n += 1 + sovRbft(uint64(m.N))
	}
	if m.ExpectN != 0 {
		n += 1 + sovRbft(uint64(m.ExpectN))
	}
	return n
}

func (m *UpdateN) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flag {
		n += 2
	}
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.Id != 0 {
		n += 1 + sovRbft(uint64(m.Id))
	}
	if m.N != 0 {
		n += 1 + sovRbft(uint64(m.N))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	if len(m.Xset) > 0 {
		for k, v := range m.Xset {
			_ = k
			_ = v
			mapEntrySize := 1 + sovRbft(uint64(k)) + 1 + len(v) + sovRbft(uint64(len(v)))
			n += mapEntrySize + 1 + sovRbft(uint64(mapEntrySize))
		}
	}
	if len(m.Bset) > 0 {
		for _, e := range m.Bset {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	return n
}

func (m *SyncState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	return n
}

func (m *SyncStateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	if m.View != 0 {
		n += 1 + sovRbft(uint64(m.View))
	}
	if m.N != 0 {
		n += 1 + sovRbft(uint64(m.N))
	}
	l = len(m.RouterInfo)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.CurrentState != nil {
		l = m.CurrentState.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *Notification) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Basis != nil {
		l = m.Basis.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovRbft(uint64(m.Timestamp))
	}
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	return n
}

func (m *NotificationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Basis != nil {
		l = m.Basis.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.N != 0 {
		n += 1 + sovRbft(uint64(m.N))
	}
	l = len(m.RouterInfo)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	if m.ReplicaId != 0 {
		n += 1 + sovRbft(uint64(m.ReplicaId))
	}
	return n
}

func (m *Peer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovRbft(uint64(m.Id))
	}
	l = len(m.Context)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *Router) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Peers) > 0 {
		for _, e := range m.Peers {
			l = e.Size()
			n += 1 + l + sovRbft(uint64(l))
		}
	}
	return n
}

func (m *ConfChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovRbft(uint64(m.NodeID))
	}
	if m.Type != 0 {
		n += 1 + sovRbft(uint64(m.Type))
	}
	l = len(m.Context)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	if len(m.VerifiedReplica) > 0 {
		for k, v := range m.VerifiedReplica {
			_ = k
			_ = v
			mapEntrySize := 1 + sovRbft(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovRbft(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ConfState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QuorumRouter != nil {
		l = m.QuorumRouter.Size()
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func (m *ServiceState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Applied != 0 {
		n += 1 + sovRbft(uint64(m.Applied))
	}
	l = len(m.Digest)
	if l > 0 {
		n += 1 + l + sovRbft(uint64(l))
	}
	return n
}

func sovRbft(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRbft(x uint64) (n int) {
	return sovRbft(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ConsensusMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: consensus_message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: consensus_message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: request_batch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: request_batch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHashList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHashList = append(m.RequestHashList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestList = append(m.RequestList, &protos.Transaction{})
			if err := m.RequestList[len(m.RequestList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNo", wireType)
			}
			m.SeqNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LocalList = append(m.LocalList, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRbft
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRbft
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.LocalList) == 0 {
					m.LocalList = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LocalList = append(m.LocalList, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalList", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HashBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: hash_batch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: hash_batch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHashList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestHashList = append(m.RequestHashList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeDuplicateRequestHashList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeDuplicateRequestHashList = append(m.DeDuplicateRequestHashList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendRequestBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: send_request_batch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: send_request_batch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Batch == nil {
				m.Batch = &RequestBatch{}
			}
			if err := m.Batch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchMissingRequests) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: fetch_missing_requests: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: fetch_missing_requests: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissingRequestHashes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MissingRequestHashes == nil {
				m.MissingRequestHashes = make(map[uint64]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthRbft
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthRbft
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRbft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRbft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MissingRequestHashes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendMissingRequests) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: send_missing_requests: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: send_missing_requests: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissingRequestHashes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MissingRequestHashes == nil {
				m.MissingRequestHashes = make(map[uint64]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthRbft
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthRbft
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRbft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRbft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MissingRequestHashes[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissingRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MissingRequests == nil {
				m.MissingRequests = make(map[uint64]*protos.Transaction)
			}
			var mapkey uint64
			var mapvalue *protos.Transaction
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRbft
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthRbft
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &protos.Transaction{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRbft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRbft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MissingRequests[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: request_set: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: request_set: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, &protos.Transaction{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Local", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Local = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NullRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: null_request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: null_request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrePrepare) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: pre_prepare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: pre_prepare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashBatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HashBatch == nil {
				m.HashBatch = &HashBatch{}
			}
			if err := m.HashBatch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Prepare) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: prepare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: prepare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Commit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: commit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: commit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Checkpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: checkpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: checkpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Digest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vc_C) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: vc_C: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: vc_C: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Digest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vc_PQ) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: vc_PQ: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: vc_PQ: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VcBasis) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: vc_basis: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: vc_basis: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field H", wireType)
			}
			m.H = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.H |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cset = append(m.Cset, &Vc_C{})
			if err := m.Cset[len(m.Cset)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pset = append(m.Pset, &Vc_PQ{})
			if err := m.Pset[len(m.Pset)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Qset = append(m.Qset, &Vc_PQ{})
			if err := m.Qset[len(m.Qset)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: view_change: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: view_change: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Basis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Basis == nil {
				m.Basis = &VcBasis{}
			}
			if err := m.Basis.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: new_view: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: new_view: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Xset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Xset == nil {
				m.Xset = make(map[uint64]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthRbft
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthRbft
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRbft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRbft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Xset[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bset = append(m.Bset, &VcBasis{})
			if err := m.Bset[len(m.Bset)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchRequestBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: fetch_request_batch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: fetch_request_batch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDigest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDigest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryFetchPQC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: recovery_fetchPQC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: recovery_fetchPQC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field H", wireType)
			}
			m.H = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.H |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryReturnPQC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: recovery_returnPQC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: recovery_returnPQC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepreSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrepreSet = append(m.PrepreSet, &PrePrepare{})
			if err := m.PrepreSet[len(m.PrepreSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreSet = append(m.PreSet, &Prepare{})
			if err := m.PreSet[len(m.PreSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmtSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CmtSet = append(m.CmtSet, &Commit{})
			if err := m.CmtSet[len(m.CmtSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Set = append(m.Set, &Prepare{})
			if err := m.Set[len(m.Set)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Set = append(m.Set, &Commit{})
			if err := m.Set[len(m.Set)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadyForN) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ready_for_n: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ready_for_n: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewNodeInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewNodeInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectN", wireType)
			}
			m.ExpectN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpectN |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AgreeUpdateN) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: agree_update_n: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: agree_update_n: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Basis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Basis == nil {
				m.Basis = &VcBasis{}
			}
			if err := m.Basis.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Flag = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			m.N = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.N |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectN", wireType)
			}
			m.ExpectN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpectN |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateN) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: update_n: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: update_n: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Flag = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			m.N = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.N |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Xset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Xset == nil {
				m.Xset = make(map[uint64]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthRbft
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthRbft
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRbft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRbft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Xset[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bset = append(m.Bset, &VcBasis{})
			if err := m.Bset[len(m.Bset)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sync_state: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sync_state: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncStateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: sync_state_response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: sync_state_response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			m.N = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.N |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterInfo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouterInfo = append(m.RouterInfo[:0], dAtA[iNdEx:postIndex]...)
			if m.RouterInfo == nil {
				m.RouterInfo = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CurrentState == nil {
				m.CurrentState = &ServiceState{}
			}
			if err := m.CurrentState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Notification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: notification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: notification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Basis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Basis == nil {
				m.Basis = &VcBasis{}
			}
			if err := m.Basis.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotificationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: notification_response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: notification_response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Basis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Basis == nil {
				m.Basis = &VcBasis{}
			}
			if err := m.Basis.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			m.N = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.N |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterInfo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouterInfo = append(m.RouterInfo[:0], dAtA[iNdEx:postIndex]...)
			if m.RouterInfo == nil {
				m.RouterInfo = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaId", wireType)
			}
			m.ReplicaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Peer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: peer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: peer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = append(m.Context[:0], dAtA[iNdEx:postIndex]...)
			if m.Context == nil {
				m.Context = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Router) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: router: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: router: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peers = append(m.Peers, &Peer{})
			if err := m.Peers[len(m.Peers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: conf_change: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: conf_change: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ConfChangeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = append(m.Context[:0], dAtA[iNdEx:postIndex]...)
			if m.Context == nil {
				m.Context = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifiedReplica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VerifiedReplica == nil {
				m.VerifiedReplica = make(map[uint64]bool)
			}
			var mapkey uint64
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRbft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRbft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRbft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRbft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.VerifiedReplica[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: conf_state: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: conf_state: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuorumRouter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QuorumRouter == nil {
				m.QuorumRouter = &Router{}
			}
			if err := m.QuorumRouter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: service_state: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: service_state: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applied", wireType)
			}
			m.Applied = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Applied |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRbft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Digest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRbft(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRbft
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRbft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRbft
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthRbft
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRbft
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRbft(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthRbft
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRbft = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRbft   = fmt.Errorf("proto: integer overflow")
)
